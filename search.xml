<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git-dos]]></title>
    <url>%2F2017%2F12%2F25%2Fgit-dos%2F</url>
    <content type="text"><![CDATA[工作中用到的 git 命令 dos 博客链接123456789101112131415161718192021222324252627282930313233github创建静态页面发布静态页面1查看远程分支git branch -va2切换远程分支git checkout -t origin/gh-pages3发布静态网页add -&gt; commit -&gt; push-----------------------------1查看当前分支git branch* gh-pages2添加文件到库中git commit -a -m &quot;first commit&quot;3提交代码到远程分支git push origin gh-pages----------------------------- 创建文件夹 git init git add README.md git remote add origin https://git.coding.net/BlankCat/elephant-blog-api.git git push -u origin master第二次git add *git commit -m “zjf”git push]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[develop-tool-curl]]></title>
    <url>%2F2017%2F12%2F25%2Fdevelop-tool-curl%2F</url>
    <content type="text"><![CDATA[curl学习使用 curl官网 curl使用方法–博客总结]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[url-tool-link]]></title>
    <url>%2F2017%2F12%2F25%2Furl-tool-link%2F</url>
    <content type="text"><![CDATA[开发中用到的 导航链接 ，url链接 ，在线工具 开发使用导航url –&gt; gitnavi 代码天气预报 –&gt; wttr 查询IP地址 –&gt; ip 在线工具【时间戳，端口号检测】 –&gt; tool在线工具【常见计算统计工具】 –&gt; tool在线工具【数字转换成钱大小写】 –&gt; tool在线工具【摩斯电码 字体编码解码】 –&gt; tool html–pdf转换工具 –&gt;可以将网页转换成各种格式的文件 抓包工具 Fiddler –&gt; 抓包]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>url</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[life-study-skills]]></title>
    <url>%2F2017%2F12%2F25%2Flife-study-skills%2F</url>
    <content type="text"><![CDATA[文章导读： 在过去未被自己流程化的情况下，自己学习新的东西的时候一直是处理迷迷糊糊的状态，直到我看到这张思维导图，我瞬间就理清自己平时在学习东西时候那混乱的思维了。可能平时我们也是这样做的，可是我们从来没有认真思考过或是整理过这样的思绪。也许你认为这样不重要，但是对我而言，有记录的东西，代表可以被流程化，这可以帮助特定情况下的我。下面跟着这张思维导图，我们一起来整理 Maven 的材料。 它是什么? 术语定义 Maven 官网定义：http://maven.apache.org/ 百度百科定义：http://baike.baidu.com/view/336103.htm 维基百科定义：https://zh.wikipedia.org/wiki/Apache_Maven 在 Wiki 上还需要注意如下，这些有助于你站在更加宏观的角度看待它，但是可能需要积累： 参见 补充阅读 参考资料 外部链接 它的历史? Google 搜索：Maven History Google 搜索：Maven 区别、Maven difference Google 搜索：Maven 使用场景 Google 搜索：What is Maven Google 搜索：To use or not to use Maven Google 搜索：Maven use case 在 Google 搜索结果页最下面，看它提示的搜索关键字内容，看是否有版本上的区别。 同类常见技术（按技术出现时间正序） Ant Gradle 同类技术比较： Google 搜索：Ant Maven Gradle 比如文章： 学习前提/依赖 要有 Java 基础相关 为什么会出现123456Google 搜索：关键字：为什么用 maven关键字：why use maven关键字：What does Maven do关键字：Why do we need Maven关键字：Why should we use Maven 哪些人不喜欢它123Google 搜索：关键字：不用 maven关键字：Why I Don&apos;t Use Maven 为什么学习它12345老师让学的？解决工作问题？提高效率？知识储备？灵机一动？ 我要怎么做（按优先级从高到低排序）123456789101112131415161718192021222324252627282930313233343536373839404142434445看教程官网快速入门文档在官网中查看带有下面几个关键字的链接：Getting StartedQuick StartGetting Started Guidesusage pageTutorialsGuidesDevelopment GuidesDocumentationDocsScreencastsbest practices在极客学院搜索对应的教学视频（我是年 VIP）Google 搜索：Maven 视频 教程 百度云网盘Google 搜索：Maven 视频 教程微博-搜索相关内容：http://weibo.com公众号-搜索相关内容：http://weixin.sogou.com/京东-图书：http://book.jd.com/YouTube-搜索相关内容：http://youtube.com/自己写 Demo参考别人 DemoGtihub 搜索 Demo：https://github.com/search/advancedGit@OSC 搜索 Demo：http://git.oschina.net/项目场景模拟、提高遇到问题找官网 FAQ：https://maven.apache.org/general.htmlQQ 群组讨论Google 搜索下面关键字方法：Maven site:stackoverflow.comMaven site:quora.comMaven site:xitu.ioMaven site:toutiao.ioMaven site:segmentfault.comMaven site:jianshu.comMaven site:zhihu.comMaven site:blog.csdn.netMaven site:cnblogs.comMaven site:blog.51cto.comMaven site:oschina.netMaven site:iteye.comMaven site:importnew.com 归纳整理并分享12345678910111213141516整理为知笔记里面内容浏览器书签简书中收藏：http://www.jianshu.com/bookmarks简书中喜欢：http://www.jianshu.com/favourites开发者头条中收藏：http://toutiao.io/favorites微博中收藏：http://weibo.com/favRSS 订阅：http://www.inoreader.com/无法订阅的博客使用 Feed43 生成 RSS：http://feed43.com/分享写博客分享到开发者头条分享到简书分享到微信公众号系统整理 Demo 在 Github 上 过程细节12345678Google 搜索必备：Maven site:www.youmeek.com，表示搜索结果局限于在：www.youmeek.com 这个站点Maven link:www.youmeek.com，返回所有链接到 www.youmeek.com 的网页r elated:www.qq.com，查找类似 www.youmeek.com 的网站cache:www.youmeek.com，查找 www.youmeek.com 的历史快照结束语我猜测你可能需要 VPN 或是 Shadowsocks 我的学习、归纳方法（以学习 Maven 为例）]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[life-work-2017-12-20]]></title>
    <url>%2F2017%2F12%2F20%2Flife-work-2017-12-20%2F</url>
    <content type="text"><![CDATA[三岁学说话，一生学闭嘴！工作的时候不要带着情绪去工作，今天上班发火了，引以为戒…完成的工作 hexo 博客 添加搜索功能 idea 修改代码风格 学习 shiro windows 和 linux 的tree使用]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-search-plugin]]></title>
    <url>%2F2017%2F12%2F20%2Fhexo-search-plugin%2F</url>
    <content type="text"><![CDATA[##hexo 搜索插件原文链接之前安装过第三方的搜索服务，贼蛋疼。都不免费了。 也有自己安装插件，然后写js的，麻烦 后来找到两个插件，安装之后就搞定了 感谢开发的作者！！！ 安装插件记得要在站点根目录执行下面的安装操作 1.安装 hexo-generator-search 1npm install hexo-generator-search --save 2.安装 hexo-generator-searchdb 1npm install hexo-generator-searchdb --save 启用搜索编辑站点文件_config.yml，添加以下内容开启搜索12345search:path: search.xmlfield: postformat: htmllimit: 10000 编辑主题文件_config.yml，启用本地搜索功能： 123# Local searchlocal_search:enable: true]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-爬虫]]></title>
    <url>%2F2017%2F12%2F19%2Fjava-%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[java爬虫技术 博客 github oschina 官网]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[develop-language-node.js]]></title>
    <url>%2F2017%2F12%2F19%2Fdevelop-language-node-js%2F</url>
    <content type="text"><![CDATA[loopbackjs 官网 node.js 博客学习]]></content>
      <categories>
        <category>dev-language</category>
      </categories>
      <tags>
        <tag>dev-language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[develop-tool-link-url]]></title>
    <url>%2F2017%2F12%2F19%2Fdevelop-tool-link-url%2F</url>
    <content type="text"><![CDATA[《刘瑜写给女儿的信：愿你慢慢长大 》小布谷，愿你慢慢长大。愿你有好运气，如果没有，愿你在不幸中学会慈悲。愿你被很多人爱，如果没有，愿你在寂寞中学会宽容。愿你一生一世每天都可以睡到自然醒。 ##开发中好的url链接1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950LeetCode题目汇总http://blog.csdn.net/Yano_nankai/article/category/5853703/1https://www.zybuluo.com/Yano/note/255755webpack手册http://zhaoda.net/webpack-handbook/module-system.htmlredux手册http://cn.redux.js.org/docs/react-redux/api.htmlreact+redux实战http://blog.csdn.net/sinat_17775997/article/details/52311448store+reduxhttp://cn.redux.js.org/docs/basics/Store.htmlreactNative+f8-apphttps://f8-app.liaohuqiu.net/tutorials/building-the-f8-app/data/es6教程http://es6.ruanyifeng.com/markdown在线编辑器http://mahua.jser.me/清除缓存chrome://settings/clearBrowserDatachrome://cache/reactXP官方文档https://microsoft.github.io/reactxp/docs/components/button.htmllinux命令http://blog.chinaunix.net/uid-87889-id-2014303.htmljson校验工具http://json.cn/bejsonchrome快捷键http://www.cnblogs.com/mikalshao/archive/2010/11/03/1868568.html]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[develop-framework-CKEditor]]></title>
    <url>%2F2017%2F12%2F19%2Fdevelop-framework-CKEditor%2F</url>
    <content type="text"><![CDATA[开发框架之–富文本编辑器 博客地址 CKEditor+CKFinder+jsp 将CKEditor集成到Java开发环境中]]></content>
      <categories>
        <category>framework</category>
      </categories>
      <tags>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[develop-windows-dos]]></title>
    <url>%2F2017%2F12%2F19%2Fdevelop-windows-dos%2F</url>
    <content type="text"><![CDATA[《刘瑜写给女儿的信：愿你慢慢长大 》小布谷，愿你慢慢长大。愿你有好运气，如果没有，愿你在不幸中学会慈悲。愿你被很多人爱，如果没有，愿你在寂寞中学会宽容。愿你一生一世每天都可以睡到自然醒。 ##常见windows命令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283局域网查看工具(LanSee)V1.72破解版http://download.csdn.net/download/yanfei23/2317770http://z.download.csdn.net/download/zh830814/281895Windows下查看电脑信息的命令查看当前ip: cmd-----&gt;ipconfig/all查看电脑配置 ----&gt;dxdiag查看注册表信息 ----&gt;regedit查看系统属性 ----&gt;sysdm.cpl查看系统信息 ----&gt;msinfo32 查看网络 nbtstat -aAn a 远程主机的名称，便可知NETBIOS A 远程主机的ip 便可知NETBIOS n 列出本地主机的NETBIOS查看网络状态 netstat -ar a 查看本地机器的所有的端口 可以有效发现、防范木马，及知道机器所开的服务信息。用法 netstat -a IP r 列出当前的路由信息 告知本地机器的网关、子网掩码。 用法：netstat -r IP跟踪路由信息 tracert IP 如果电脑的运行、控制面板、命令提示符被禁用了 一：---&gt;gpedit.msc---&gt;用户配置--&gt;管理模块--&gt;系统（单击选中）--&gt;右边找到“阻止访问命令提示符”，鼠标双击，弹出窗口，点选“未配置”--&gt;应用--确定 二：---&gt;gpedit.msc---&gt;用户配置--&gt;管理模块--&gt;控制面板（单击选中）--&gt;右边找到“禁止访问控制面板”，鼠标双击，弹出窗口，点选“未配置”--&gt;应用--确定 三：---&gt;c:\windows\regedit.exe, HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer,在右边空白处右键，选择“新建”的“DWORD”,然后输入名字“NoRun”，然后双击它，=============================================================================查看局域网内所有IP ：arp -a查看局域网内所有主机名： net view查看IP地址对应的主机名和MAC地址： nststat -a 192.168.0.101=============================================================================linux 查看系统信息命令(比较全)# uname -a # 查看内核/操作系统/CPU信息 # head -n 1 /etc/issue # 查看操作系统版本 # cat /proc/cpuinfo # 查看CPU信息 # hostname # 查看计算机名 # lspci -tv # 列出所有PCI设备 # lsusb -tv # 列出所有USB设备 # lsmod # 列出加载的内核模块 # env # 查看环境变量资源 # free -m # 查看内存使用量和交换区使用量 # df -h # 查看各分区使用情况 # du -sh &lt;目录名&gt; # 查看指定目录的大小 # grep MemTotal /proc/meminfo # 查看内存总量 # grep MemFree /proc/meminfo # 查看空闲内存量 # uptime # 查看系统运行时间、用户数、负载 # cat /proc/loadavg # 查看系统负载磁盘和分区 # mount | column -t # 查看挂接的分区状态 # fdisk -l # 查看所有分区 # swapon -s # 查看所有交换分区 # hdparm -i /dev/hda # 查看磁盘参数(仅适用于IDE设备) # dmesg | grep IDE # 查看启动时IDE设备检测状况网络 # ifconfig # 查看所有网络接口的属性 # iptables -L # 查看防火墙设置 # route -n # 查看路由表 # netstat -lntp # 查看所有监听端口 # netstat -antp # 查看所有已经建立的连接 # netstat -s # 查看网络统计信息进程 # ps -ef # 查看所有进程 # top # 实时显示进程状态用户 # w # 查看活动用户 # id &lt;用户名&gt; # 查看指定用户信息 # last # 查看用户登录日志 # cut -d: -f1 /etc/passwd # 查看系统所有用户 # cut -d: -f1 /etc/group # 查看系统所有组 # crontab -l # 查看当前用户的计划任务服务 # chkconfig –list # 列出所有系统服务 # chkconfig –list | grep on # 列出所有启动的系统服务程序 # rpm -qa # 查看所有安装的软件包]]></content>
      <categories>
        <category>开发技巧</category>
      </categories>
      <tags>
        <tag>开发技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pdf-book-resource-url]]></title>
    <url>%2F2017%2F12%2F19%2Fpdf-book-resource-url%2F</url>
    <content type="text"><![CDATA[pdf 资源下载bestcbooks.comjava1234.com]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>pdf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[develop-apache-kafka-frame-work]]></title>
    <url>%2F2017%2F12%2F19%2Fdevelop-apache-kafka-frame-work%2F</url>
    <content type="text"><![CDATA[《刘瑜写给女儿的信：愿你慢慢长大 》小布谷，愿你慢慢长大。愿你有好运气，如果没有，愿你在不幸中学会慈悲。愿你被很多人爱，如果没有，愿你在寂寞中学会宽容。愿你一生一世每天都可以睡到自然醒。 ##apache kafka 资源总结123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990kafka资源整理https://yq.aliyun.com/articles/69501kafka中文教程http://www.orchome.com/kafka/index?spm=5176.100239.blogcont69501.5.5zZkfXkafka英文版:https://kafka.apache.org/0100/documentation.html?spm=5176.100239.blogcont69501.6.5zZkfXhttps://kafka.apache.org/0100/documentation.html?spm=5176.100239.blogcont69501.7.5zZkfX#streamsapikafka 0.10新特性https://www.iteblog.com/archives/1677.htmlkafka 机制: http://blog.arganzheng.me/posts/kafka-in-action.html http://www.infoq.com/cn/profile/%E9%83%AD%E4%BF%8A https://www.oschina.net/translate/kafka-designkafka优化： http://www.infoq.com/cn/articles/linkedIn-improving-kafkakafka技术内幕:http://zqhxuyuan.github.io/2017/01/01/Kafka-Code-Index/kafka文件存储机制:http://tech.meituan.com/kafka-fs-design-theory.htmlkafka zookeeper存储结构:http://blog.csdn.net/lizhitao/article/details/23744675kafka源码解析:http://zqhxuyuan.github.io/tags/kafka/https://zqhxuyuan1.gitbooks.io/kafka/content/index.html身份认证和安全机制:https://wangzzu.github.io/2016/07/29/sasl-plain-kafka/优秀博客:http://www.jasongj.com/tags/Kafka/https://my.oschina.net/ielts0909http://dongxicheng.org/search-engine/kafka/https://my.oschina.net/ielts0909/blog/117489https://my.oschina.net/u/591402/blog/145090http://rockybean.github.io/2012/07/30/jafka-design/http://www.cnblogs.com/cyfonly/p/5954614.html优秀博文http://www.jasongj.com/2015/01/02/Kafka%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/kakfa kafka message delivery guarantee:http://blog.csdn.net/odailidong/article/details/49735475kakfa ISR:http://zqhxuyuan.github.io/2016/01/14/2016-01-14-Kafka-ISR/http://www.cnblogs.com/fxjwind/p/4972244.htmlhttp://zqhxuyuan.github.io/2016/01/13/2016-01-13-Kafka-Picture/Kafka实战：从RDBMS到Hadoop，七步实现实时传输http://geek.csdn.net/news/detail/97941]]></content>
      <categories>
        <category>framework</category>
      </categories>
      <tags>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[develop-tool-register-code]]></title>
    <url>%2F2017%2F12%2F19%2Fdevelop-tool-register-code%2F</url>
    <content type="text"><![CDATA[idea注册码 123http://idea.lanyus.com/ https://www.iteblog.com/archives/1542.html http://idea.iteblog.com/key.php]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[develop-language-scala]]></title>
    <url>%2F2017%2F12%2F19%2Fdevelop-language-scala%2F</url>
    <content type="text"><![CDATA[scala官网 scala.js官网 scala教程参考 常用类库 / 常用类库 / 常用类库]]></content>
      <categories>
        <category>dev-language</category>
      </categories>
      <tags>
        <tag>dev-language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[develop-skill-xshell-dos]]></title>
    <url>%2F2017%2F12%2F19%2Fdevelop-skill-xshell-dos%2F</url>
    <content type="text"><![CDATA[windows 的一些操作，dos命令帮助快速开发，提高工作效率！ 管理员的方式启动电脑 管理员方式启动电脑dos123456compmgmt.msc系统工具→本地用户和组→用户Win+Break系统属性 ##开发常用的xshell命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307线上文件路径\\192.168.1.206\softMgr\jcbase工程服务器地址121.40.51.43 用户名:root密码oGcnhnrjmnififtc2GX3v6bfXVxnqPrkSu7jcfxp启动服务器/etc/init.d/tomcat2 restarttail -f /usr/local/tomcat2/logs/catalina-daemon.outcd /data0/wwwroot/lscd base端口号 9282http://base.zfwx.com去host文件里面根据域名找对应的iphttp://base.zfwx.com/register.do;jsessionid=2273D8E3BE7EEE9124BB8082EE045D2C=====================================================================207服务器查看zookeeper查看服务是否启动192.168.1.207用户名root密码asdf!@#$vi 编辑保存=====================================================================查询redis服务121.40.34.17用户名root密码pfrNzrgp6ajpfrNzrgp6aQQV9mepi4jpfrNzrgp6aQ查询redisps -ef |grep rediscd /usr/local/redis/binls启动客户端软件./redis-cli选择库select 3 选择3号库okget |lstangrongzhi 查询出对应的值key *key ===================================================================设置时效，过期后就自动删除set a fexpire a 144000/3600 4个小时查看时效ttl a=====================================================================//30机器 data0目录是工程目录政法网校api114.55.36.30用户名root密码hvHS0ih6tVltyysoovZr8ccQlaesd2启动服务器/etc/init.d/tomcat2 restarttail -f /usr/local/tomcat1/logs/catalina-daemon.outapi 监听的端口号：6088=====================================================================115.29.221.112mobile工程测试服务器用户名root密码115.29.221.112 z0gmq5gpKbpXzuxmjlnwfYYpie9y9DygdpfbMkqR5098端口5099端口步骤1进入tomcat的conf执行命令cat server.xml产看工程部署目录步骤2查看tomcat的环境变量cat /etc/profile查看tomcat环境变量步骤3进入/etc/init.d目录下查看有没有tomcat的启动脚本执行命令(在tomcat的脚本上面检索环境变量)grep &quot;CATALINA_HOME&quot; /etc/init.d/tomcat启动服务器/etc/init.d/tomcat2 restarttail -f /usr/local/tomcat1/logs/catalina-daemon.out112机器部署这所有的服务/data0/service/*_service=====================================================================207机器zookeeper配置192.168.1.207用户名root密码测试端口是否成功telnet 192.168.1.207 2181 课程详情接口http://mm.zfwx.com/tdk/get_detail.json?courseId=3288去购买接口http://mm.zfwx.com/tdk/gopay_mysignup.json?courseId=3288select distinct cg_id as id,cg_name as name,cs.cg_count as count from dj_cscategory cs where cs.cg_count != 0 and cg_pcategory = -10 and cg_belong LIKE &apos;%1%&apos; order by cg_order;mobile 端口5098===================================================================查看注册中心注册的服务进入zookeeper的安装目录，进入bin 目录 cd /usr/local/zookeeper/bin./zkCli.shls /dubbo/com.blank.service.servicename===========================查看服务端口http://itindex.net/detail/53125-dubbo-%E6%9C%8D%E5%8A%A1-telnethttp://alibaba.github.io/dubbo-doc-static/Telnet+Command+Reference-zh-showComments=true&amp;showCommentArea=true.htm======================================================================管理后台界面账号yangdebao密码yangdebaohttp://admin.zfwx.com/admin/index.jsp-----------定位action------------打开管理后台界面随便找一个url--&gt;右键--&gt;在新的标签页面打开（t）http://admin.zfwx.com/admin/DjStucourse/batchSelectCourseForMembers.do分析这个路由规则--admin（管理后台）-- （DjStucourse:DjStucourseAction 定位到action）---（batchSelectCourseForMembers方法）-----------定位模板------------定位界面在路由方法里面return STUSELECT_JSP;这个页面规则protected static final String STUSELECT_JSP = &quot;/admin/DjStucourse/stuselectcs.jsp&quot;;ctrl+shift+r查找到对应的jsp页面-----------模板讲解------------http://admin.zfwx.com/admin/DjCourse/edit.do?courseId=3501&amp;edit.jsp页面嵌入一个模板&lt;%@ include file=&quot;form_include.jsp&quot; %&gt;jsp中struts2框架的标签&lt;s:form&gt;&lt;/s:form&gt; /**推送消息添加**/课程列表--课程&amp;选课--操作（推送）121.40.51.45用户名:root密码7Nxddaup2HEcBeq3jrrnzabumuvDSxndyUdypuc5zfwx_api 8088步骤1进入tomcat的conf执行命令cat server.xml产看工程部署目录步骤2查看tomcat的环境变量cat /etc/profile查看tomcat环境变量步骤3进入/etc/init.d目录下查看有没有tomcat的启动脚本执行命令(在tomcat的脚本上面检索环境变量)grep &quot;CATALINA_HOME&quot; /etc/init.d/tomcat启动服务器/etc/init.d/tomcat2 restarttail -f /usr/local/tomcat1/logs/catalina-daemon.out----------------------------------步骤1进入tomcat的conf执行命令cat server.xml产看工程部署目录步骤2查看tomcat的环境变量cat /etc/profile查看tomcat环境变量步骤3进入/etc/init.d目录下查看有没有tomcat的启动脚本执行命令(在tomcat的脚本上面检索环境变量)grep &quot;CATALINA_HOME&quot; /etc/init.d/tomcat/etc/init.d/tomcat2 restarttail -f /usr/local/tomcat1/logs/catalina-daemon.out账号密码:yangdebaohttp://admin.zfwx.com/admin/index.jsp---------------------------------------------------线上代码查找win+r\\192.168.1.206\softMgr\jc测试服务器数据库密码djcourse密码 ssh密钥z0gmq5gpKbpXzuxmjlnwfYYpie9y9DygdpfbMkqRcasserver密码 ssh密钥7Nxddaup2HEcBeq3jrrnzabumuvDSxndyUdypuc5=======================================================================1查看tomcat监听的端口号2 ps -ef| grep tomcat netstat -ntlp | grep 端口号/进程号3 jps4 杀死进程5 重启tomcat=========================================================================查看进程号lsof -i | grep 端口号lsof -i:端口号netstat -ntlp| grep 端口号例子：nststat -nflp|grep 20884lsof -i:20884lsof -i | grep 20884]]></content>
      <categories>
        <category>开发技巧</category>
      </categories>
      <tags>
        <tag>开发技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[develop-skill-route-names]]></title>
    <url>%2F2017%2F12%2F19%2Fdevelop-skill-route-names%2F</url>
    <content type="text"><![CDATA[##开发技巧(接口，路由命名)参考下面的网站路由规则12345web服务标准链接学习好的官网的路由规则http://ws-i.org/http://uddi.xml.org/uddi-orghttp://www.alibabagroup.com/cn/global/home 方法命名规则转自123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137单词eclipse使用git遇到的单词Browse 浏览push 推送Configuration 配置team 团队upgrade 升级cleanup 清理clone 克隆repository 仓库master 主要history 历史repositories 库ignore 忽略patch 补丁reset 复位,还原untracked 跟踪staged 上演modified 被改进的compare mode 比较模式team synchronizing 团队同步commit时:author 作者committer 提交者 commit 提交到本地仓库stashes 将push to upstream 推到上游fetch from upstream 从上游取push branch 推支pull 拉取remote 远程references 引用switch to 切换到advanced 先进的synchronize workspace 同步工作区merge tool 合并工具merge 合并rebase 垫底refresh 刷新Clone Git repository 克隆Git仓库discon nect 断开连接create patch 创建补丁apply patch 应用修补程序add to index 添加到索引remove from index 从索引中删除show in repositories view 显示仓库视图checkout as new local branch 作为新的本地分支结账checkout commit 结帐提交git view 仓库branches 分支 local 局部 remote tracking 远程跟踪create branch 创建分支paste repository path or url 粘贴库路径或网址working directory 工作目录添加索引 好处？EGIT中只要Commit就可以默认将untracked的文件添加到索引再提交更新，不需要分开操作/////////////////////////////////////////////////////////////////////// Maven学习遇到的单词Apache 一个开放源码的网页服务器timestamp 时间戳dependency 依赖injection 注入dependency injection 依赖注入Archetype 原型maven 专家selection 选择skip 跳跃simple 简单的plan 计划skip Archetype selection 跳过原型选择Create a simple project 创建一个简单的项目configuration 配置restore defaults 恢复默认值choose 选择existing 目前的choose an existing server 选择一个现有的的服务器manually 手动的define 定义reason 理由missing 错过config 配置preferences 参数选择runtime 执行时间environment 环境runtime environment 运行环境Annotation 注释source 来源resource 资源DataSource 数据源Artifact ID 组中模块的名称group id 组标识符scan 扫描不是很全，欢迎补充！///////////////////////////////////////////////////////////////////////spring学习单词Component 组成include 包含filter 过滤scan 扫描status 状态report 报告status report 状态报告source 来源not 不found 创立，建立for 因为source not found for没有找到来源jetty 码头skills 技能background 背景音乐in 在...之内，按照run in background 在后台运行不是很全，欢迎补充！]]></content>
      <categories>
        <category>开发技巧</category>
      </categories>
      <tags>
        <tag>开发技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chrome-hot-key]]></title>
    <url>%2F2017%2F12%2F19%2Fchrome-hot-key%2F</url>
    <content type="text"><![CDATA[《刘瑜写给女儿的信：愿你慢慢长大 》小布谷，愿你慢慢长大。愿你有好运气，如果没有，愿你在不幸中学会慈悲。愿你被很多人爱，如果没有，愿你在寂寞中学会宽容。愿你一生一世每天都可以睡到自然醒。 文章转自 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051chrome窗口和标签页快捷键： Ctrl+N 打开新窗口 Ctrl+T 打开新标签页 Ctrl+Shift+N 在隐身模式下打开新窗口 Ctrl+Shift+T 重新打开上次关闭的标签页。谷歌浏览器可记住最近关闭的 10 个标签页。 Ctrl+O，然后选择文件 在谷歌浏览器中打开计算机上的文件 按住 Ctrl 键，然后点击链接 从后台在新标签页中打开链接，但您仍停留在当前标签页中 按住 Ctrl+Shift 键，然后点击链接 在新标签页中打开链接，同时切换到新打开的标签页 按住 Shift 键，然后点击链接 在 新窗口 中打开链接 Alt+F4 关闭当前窗口 Ctrl+W 或 Ctrl+F4 关闭当前标签页或弹出式窗口Ctrl+1 到 Ctrl+8 切换到指定位置编号的标签页。您按下的数字代表标签页横条上的相应标签位置。 Ctrl+9 切换到最后一个标签页Ctrl+Tab 或 Ctrl+PgDown 切换到下一个标签页 Ctrl+Shift+Tab 或 Ctrl+PgUp 切换到上一个标签页 Alt+Home 打开主页 PgDown键（pg Dn）PgUp键（pg Up）ctrl+Home 浏览器顶部ctrl+End 浏览器底部打开谷歌chrome浏览器各功能的快捷键 Ctrl+B 打开和关闭书签栏 Ctrl+Shift+B 打开书签管理器 Ctrl+H 查看”历史记录”页 Ctrl+J 查看”下载”页 Shift+Escape 查看任务管理器 (Escape键左上角esc)chrome网页快捷键 Ctrl+P 打印当前页 Ctrl+S 保存当前页 F5 重新加载当前页 Esc 停止加载当前页 Ctrl+D 将当前网页加入书签 Ctrl+U 查看源代码 将链接拖动到书签栏 将链接加入书签 Ctrl++，或者按住 Ctrl 键并向上滚动鼠标滚轮 放大网页上的所有内容 Ctrl+-，或者按住 Ctrl 键并向下滚动鼠标滚轮 缩小网页上的所有内容 Ctrl+0 将网页上的所有内容都恢复到正常大小 chrome文字快捷键]]></content>
      <categories>
        <category>hot-key</category>
      </categories>
      <tags>
        <tag>hot-key</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chome-plugins]]></title>
    <url>%2F2017%2F12%2F19%2Fchome-plugins%2F</url>
    <content type="text"><![CDATA[###[常用的谷歌插件] Infinity Momentum for Chrome 美丽瞬间 click&amp;clean 清除插件 react Developer Tools redux devTools 插件 JsonView 插件 谷歌访问助手 扩展程序DevTools Theme: Zero Dark Matrix 黑色主题github地址]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jeecms]]></title>
    <url>%2F2017%2F11%2F06%2Fjeecms%2F</url>
    <content type="text"><![CDATA[官网jeecms官网 JEECMS开发文档 csdn-jeecms ##Jeecsm使用框架包括： springMVC， hibernate(数据持久层框架)， Quartz(作业调度框架)， ant(自动编译构建框架，在自动生成模版类时用到)， Httpclient， c3p数据池， ehcache缓存框架， dom4j框架（解析xml）， DWR框架(该框架可以通过js调用Java函数)， Lucene全文检索框架， Jcaptcha验证码生成框架， sl4f和Log4j日志框架， Jmagick图片处理框架， JODConverter文件转化框架及FCK编辑器及Freemarker框架 ##Jeecsm框架包结构： Jeecsm有三大主要包分别为core(核心包)，common(公共类库包)和csm(网站主要包) Action:页面交互层包，包含与页面交互类 Dao:DAO层包，包含封装数据操作类 Web:包含与页面有关的拦截器、过滤器、校验器等 Security:包含与安全有关联的类 Manager：业务逻辑层包，包含业务处理类 Entity:模型层包，包含数据模型类 Tpl:包含模版文件管理类，包括上传，删除等 Lucene:包含整站全文检索处理类 Staticpage:静态页面处理模块，包含与静态页面生成有关的类，包括该功能模块的页面交互层,DAO层和业务逻辑层包对象 Statistic:统计功能模块，包含与统计相关的处理类，包括该功能模块的页面交互层,DAO层和业务逻辑层包对象 Task:包含定时处理任务，定时器等 Tmplate:包含模版生成类，及模版文档 Common包都是一些工具包，就不详解释 Core核心包：封装与系统架构基础，如：登录，文件上传，图片模版保存等 Bhm包：包含全部hibernate配置文件，将配置文件和实体类分离 Base包：该包下全部对象都是抽象类，其封装数据模型及其基本操作，与模型类一一对应 模型类：继承Base包对应的抽象类，主要封装一些额外数据操作 总结 数据模型包中将Hibernate配置文件抽到一个包中管理，有利配置文件维护，将逻辑操作和数据模型分离，有利系统维护和问题域定位（这一点我们可以借鉴） 混合式包结构设计，网站业务逻辑按分层结构设计，而功能使用模块结构。前者灵活性和性能高但不利于维护，后者维护性和伸缩性好但不灵活。这导致站内业务不同层之间高耦合，不利于站内业务维护。 函数体中构建数据库操作语句，应视情况而定，与数据库交流频率多的语句应当作类的静态属性存放，不应该也放在函数体中，这将导致，内存消耗大，JVM虚拟机会频繁调用CG回收器。（如：用户访问） 动态构建sql语句应该使用StringBuilder或StringBuffer(线程安全),不应该在函数中通过“+”连接（除非是一条语句） 增加一个web包用来存放与容器有关的拦截器或过滤器，有利于维护和问题域定位(可以借鉴） 转jeecms中一些分析 拦截器： 后台管理拦截器:com.jeecms.cms.web.AdminContextInterceptor前台拦截器:FrontContextInterceptor 都会把site信息和user信息设置到request和线程变量中 UnifiedUser: 用户信息及登录信息表，记录用户基本信息及最后一次登录的信息 Authentication: 记录每次的登录信息 认证时抛出用户不存在的异常 国际化通用模板技术现在比较主流的是Velocity和Freemarker。如果我们的Web应用程序要启用这两种技术渲染视图，那么，spring MVC提供了FreeMarkerView和VelocityView两种View实现。因为二者都是基于同样的理念构建视图，所以，FreeMarkerView和VelocityView有着共同的父类AbstractTemplateViewAbstractTemplateView定义了几个boolean属性，让我们可以决定是否公开暴露某些数据给最终的合并过程，如下所述。private boolean exposeSpringMacroHelpers = true。是否需要为Spring提供的宏（macro）公开一个需要的RequestContext对象，默认需要，将以”springMacroRequestContext”为键公开一个RequestContext给合并过程。这样freeswitch就可以使用RequestContext中的方法获取国际化信息 权限控制拦截器在postHandler中取出用户的权限集合放到ModelMap中，自定义指令cms_perm，类：PermistionDirective，从ModelMap中取出用户权限集合，判断url是在其中 页面管理top.html显示登录用户信息，日期，上面的一排菜单点击top菜单，如栏目，跳转到/frame/channel_main.do，显示frame/channel_main.html，它是一个包含left和right的框架页，channel/v_left.do和channel/v_list.doleft显示刷新按钮和模型管理按钮，采用JavaScript加载v_tree.do，显示树菜单,v_tree.html是json数据，用于jQuery的treeview函数的数据源 ##linkblog link2 关于FreeMaker的开源项目介绍 H:\archive\17-06-06\jeecms框架学习]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[project-name]]></title>
    <url>%2F2017%2F11%2F06%2Fproject-name%2F</url>
    <content type="text"><![CDATA[alliance_api alliance_service base base_api base_service bbs bdlk cas dailyreport demo_api demo_client demo_service design dianda dianda_manage dianjing_model dianjing_util dianting dianting_manage djDef djframework djframework-ui djph_api djph_service djyFe expert-api expert-service facetoface_api facetoface_mobile facetoface_service group haijian library_api library_service mail_api mail_service member_api member_service sfjd sfml_api sfml_pc sfml_service shop-api shop-service stustats_api stustats_service ui_worklog wangqun wdwq_api wdwq_client wdwq_service wxdy wxgr wxht_old wxqt wxqt_old wxsy_api wxsy_service xhht zfwx zfwx-admin zfwx-android zfwx-api zfwx-ios zfwx-ios-2 zfwx-pad zyjs_api zyjs_service]]></content>
      <categories>
        <category>开发技巧</category>
      </categories>
      <tags>
        <tag>project</tag>
        <tag>工程名称</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cas-01]]></title>
    <url>%2F2017%2F11%2F06%2Fcas-01%2F</url>
    <content type="text"><![CDATA[Cas认证基本概念 SSO Single Sign On 单点登录 TGT Ticket Granting Ticket 用户身份凭证票据（令牌，存在与浏览器与S端） ST Service Ticket 服务许可凭证票据（随机参数，每次S端校验后作废） TGC Ticket Granting Cookie 存放用户身份认证票据（存放令牌）的cookie ，浏览器关闭就失效 认证过程 1 web1的客户端检测到session无令牌凭证信息，将用户重定向到casserver 2 s端检测到传来的请求没有带（st）证书 参数，所以跳转到Login界面进行用户登陆验证 3 s端登陆认证结束后生成TGT令牌 和 随机的Ticket-ST证书 ，并在用户的浏览器写入cookie STC，随后让用户的浏览器重定向到web1应用中，并将随机参数ST证书带上一起带过去，之后web1的cas客户端将检测到此ST证书参数，发送到Server端进行校验，校验成功后，服务端主动销毁此ST证书，并继续返回web1应用中，web应用此时将令牌信息写入自己的Session中，从而完成用户的单点登陆认证。服务端同样的也会用一个Map记录web1假如到单点登陆范围。 4 带参重定向到web1 5 拿到ST参数发送到s端进行校验 6 校验成功，进入web1应用，w1将令牌凭证TGT写如session web2 发出请求 此时用户第一次访问web2应用，web2在自己的session中无法找到令牌信息。所以将用户重定向到S端，S端拿到用户浏览器传来的cookie，从里面读取TGT，生成一个随机的ST证书，返回w2，w2拿到ST证书，就立即和S端进行校验，S端校验成功后，立即销毁此ST证书，并将web2加入到单点登陆范围内，用户此时在web2中进行业务操作，web2同样也会在seesion中记录此令牌凭证的，至此完成用户单点登陆功能 当用户下次访问web1或者web2的时候，由于各自session中都能拿到TGT信息，只需要从中的取到每次请求时所带的ST证书参数即可和S端进行交互校验正确后达到一站登陆，N站访问的SSO效果。校验最后一登陆的信息。 w2让用户浏览器带cookie重定向到S端 s端从cookie中找到了TGT，生成ST证书返回到w2 w2根据参数ST返回到S端进行校验 校验成功后可以访问W2，W2的令牌写入Session 【H:\archive\17-06-06\cas架构】]]></content>
      <categories>
        <category>cas</category>
      </categories>
      <tags>
        <tag>cas</tag>
        <tag>sso</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Driving-skills]]></title>
    <url>%2F2017%2F08%2F26%2FDriving-skills%2F</url>
    <content type="text"><![CDATA[=^^= 以下是本人考驾照的一些总结，仅供参考，恕请勿喷！=^^= 开车习惯 只要不加油就备刹车 右脚不是在油门就是在刹车上。 停车跟车距离，看到前车的车轮胎，就是安全车距。 先挂档，再打灯 车随路走，路正车正，路歪车歪 拐弯处停车，先踩离合器，再踩刹车 注意停车踩刹车，不要着急，着急什么。说话不紧不慢的。 松离合，有震动，油离配合，加速起步 开始注意 档起步，一级一级加档减档 离合器不能离开左脚 考试系安全带 起步打灯 停车，空挡，拉手刹 反光镜调试 四分之一车身， 四分之一地上， 天地各一半。 左右车身占四分之一， 上下各一半。 驾照考试错误 倒库，提前打轮 侧方停车，最后左打轮，进车位 库在哪个方向，往哪个方向打轮 两次打灯，侧方停车打灯，坡起打灯 经常犯的错误，停车刹车 脚搭在油门，轻轻加油。 半坡起步错误–手刹按到底 脚使点劲，平行踩离合，不是脚尖踩离合 半坡起步技巧 半坡起步 车速降下来，离合器抬一点，车速降下来，离合器抬一点。 自己与空调缝隙，杆，三点一线 半坡起步 右转向灯，对箭头 对点对杆，踩刹车，拉手刹 左转向灯，方向盘左90度，松离合器到抖动 加油到20-30，油门听到轰隆声，松手刹 反光镜过杆，回正方向盘 杆子和空调第三格子对齐。 倒库 直行1号线消失，右打满 车头正了。一圈半回正。 行至到7号线中间，停车，踩刹车 挂倒档， 后视镜下沿三指头距离回正， 右打满，继续倒车 库位角两指，回正，倒车 库位角消失，右打满 看左边与4号线平行，车头正，一圈半回正方向盘 倒到平行，回正 倒车直，左透视镜下沿与黄线两指多一点，停车刚刚好。 直角转弯技巧 直角转弯，扳手挨着黄线，左打满 看远处左黄线与门把手平行，左打满，转弯回正 直角转弯。右透视镜与黄线重合，方向盘打满，转正就ok s型转弯 车速压速。 侧方停车 三个点 压车速，到侧方停车牌，打右转向灯 箭头一寸，右打满，倒车， 对着右下角点，左一圈半调整。 左扳手与黄线交叉，转正 前进档，左转向 右雨刷与白线交叉，向右 s转弯，往前边走边打弯 进车到打转向 车速越快，不能猛打方向盘 收油，踩离合，换档 收油，准备刹车，准备刹车 离合到底。 上车后操作顺序 1调整坐椅 2打左灯，举手 开始考试 松手刹，提，按，压 反光镜的下沿出现角 防止溜车 1踩离合，踩刹车 2轻松离合车抖动，松刹车 ##倒库，倒车技巧 看后视镜，哪边宽，往哪调，调90度，然后回正。 黄线在门把手的中间 ##正确挂挡 横着用劲，竖着不用劲 ##考试步骤 看镜子 扭头看盲区 转弯的时候 半连动就是起步离合的位置，轻加油门。 不要猛抬离合器。 停车，踩离合，踩刹车，轻点刹车 离合踩到底，轻点刹车。停车。 轻踏缓抬 油离配合 方向盘够使就可以了。 半坡，油离配合， 快速起步， 停车起步， 轻点离合，踩刹车，起步，松刹车，油离配合。 半坡起步， 轻抬离合器，踩刹车，踩油门。松刹车 下车逆时针。 开车门左边右边左右手接替]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gitpage-push]]></title>
    <url>%2F2017%2F08%2F26%2Fgitpage-push%2F</url>
    <content type="text"><![CDATA[查看远程分支 1git branch -va 切换远程分支12git checkout -t origin/2.0.0git checkout -t origin/gh-pages 发布静态网页 add -&gt; commit -&gt; push这里要注意一下，我是直接新建的库，然后发布的，所以，没有master分支，只有gh-pages分支，github只会将你的gh-pages分支部署上去，不会动你的其他分支的东西。所以，我们要将改动提交到gh-pages分支上，再push。 1234myindex$ git branch * gh-pagesmyindex$ git commit -a -m &quot;first commit&quot;myindex$ git push origin gh-pages 总结github创建静态页面发布静态页面123456781查看远程分支git branch -va2切换远程分支git checkout -t origin/gh-pages3发布静态网页add -&gt; commit -&gt; push 步骤1234567891查看当前分支git branch * gh-pages2添加文件到库中git commit -a -m &quot;first commit&quot;3提交代码到远程分支git push origin gh-pages git 提交代码步骤12345678910111213141516171819 创建文件夹 git init git add README.md git remote add origin https://git.coding.net/BlankCat/elephant-blog-api.git git push -u origin master 第二次git add *git commit -m “zjf”git push` 参考链接]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-black-them]]></title>
    <url>%2F2017%2F03%2F06%2Fhexo-black-them%2F</url>
    <content type="text"><![CDATA[Guidehexo主题:知乎黑色主题:github]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[google-search]]></title>
    <url>%2F2017%2F03%2F06%2Fgoogle-search%2F</url>
    <content type="text"><![CDATA[《刘瑜写给女儿的信：愿你慢慢长大 》小布谷，愿你慢慢长大。愿你有好运气，如果没有，愿你在不幸中学会慈悲。愿你被很多人爱，如果没有，愿你在寂寞中学会宽容。愿你一生一世每天都可以睡到自然醒。 I am BlankCat，welcome to my blog； 技术要点1234567891011121314151617181920212223242526272829303132搜索引擎1完整匹配 mysql foreign key 关键字加空格 "mysql foreign key"2筛选 就要求Google返回含有mysql foreign key但不存在nodejs的文章。 减号-的使用 "mysql foreign key" - "nodejs"3通配符 "mysql connect error *" 返回所有已知的关于MySQL连接错误的文章。 4站内搜索 程序找bug，stackoverflow是我个人觉得可信度最高也最全面的一个网站 "mysql foreign key" site:stackoverflow.com "mysql foreign key" site:baidu.com5语言和日期 像2shou叔这种英语阅读能力不过关的人，遇到急事就不能一篇篇翻原版文档了， 不得不求助国内的二手货；这时，Google界面上的一个小按钮就帮上大忙了： 点击搜索工具 - 不限语言，下拉选择所有简体中文网页， 一下子就回到了祖国母亲的怀抱。有时用新出的库版本，别忘了隔壁那个不限日期按钮 ，可以帮你找到最最新鲜的技术文章。6Tab键使用 输入某个网址，再点击Tab baidu.com+按tab键 搜索关键字7谷歌的安全搜索怎么关闭 搜索网址加个参数：&amp;safe=off]]></content>
      <categories>
        <category>Google</category>
      </categories>
      <tags>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[skill]]></title>
    <url>%2F2017%2F02%2F23%2Fskill%2F</url>
    <content type="text"><![CDATA[I am BlankCat ，welcome to my blog； 技术要点``` bash #####Android总结 oncreate – 上一个界面传值 查看上一个界面传值是干啥用的？–&gt;看变量注释 布局文件叫什么布局文件layout 2看网络请求回掉 onData开头的网络请求回掉 哪个网络请求对应哪个回调去找点击事件查看是哪个网络请求 ctrl+k 查找下一个 找控件去找布局文件的Sting.xml文件 string_activity_voicelecture.xml布局文件 找到布局文件 ctrl+h 全局搜索布局文件的内容 3.查找出所有的布局资源文件的引用 查找到布局文件是在我门的 3.找到对应的控件去找到id去Activity里面找点击事件 debug dbms–&gt;应用进程–&gt;点击debug f6下一步 debug 4 EventBus 接收界面： EventBus.getDefault().register(this); onDestroy解注册 EventBus.getDefault().unregister(this); onEventMainThread()这个方法中接收定义的方法 发送界面： EventBus.getDefault().post(new PayEvent()) 发送自定义的事件，发送Event之后,只要注册EventBus的Activity中的onEventMainThread()方法会接收一个自定义的Event A发送，B,C,D界面接收同一个事件 自定义不同的EventBus，发生用不同的Eventbus发送，这样写太麻烦，也比较浪费性能 定义一个Event事件，这个事件里面加标记，在事件中判断Event的类型tag值进行判断。 微信支付流程 http://www.mamicode.com/info-detail-469919.html 支付宝支付流程 http://blog.csdn.net/tspangle/article/details/39932963 1支付流程，支付成功之后，后台发通知，前端App接收通知，然后提示支付成功 支付成功，后台和前台都会收到来自微信的回掉接口，以后台收到的为准 前端接到App的通知后，会发一个handler，通知界面已经接到消息 BaiduPushMessageReceiver 2渐变的listView 渐变的listView 3界面传数据Bundle传参数 4 android 设置自动点击事件就是不触发就执行点击事件的onclick方法 安卓桌面开发显示小控件 App Widgets ######################################html5 js总结########################################################## 手机浏览器h5项目 https://github.com/ScorpionJay/oneH5 https://github.com/ScorpionJay/react-redux-demo http://reactnative.cn/ 用reactjs写h5 angualarjs 前端框架 angualarjs 写后台管理系统项目，说的后台是后台管理项目 Angualarjs教程 http://www.tuicool.com/articles/BZzUVrb 当然react angularjs 后台是可以跑的 它们设计的方向是这样 现在还没 写组件 然后在什么上跑 就看渲染了 但是这里的服务器跑 还不是很了解 react native 项目 https://github.com/helengray/XiFan react native 大牛博客 http://blog.csdn.net/it_talk 前端js特效网站（**） http://js1k.com/ 前端学习历程 http://bbs.jointforce.com/topic/19501]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK8-Stream详解]]></title>
    <url>%2F2017%2F02%2F05%2Fjdk8-4%2F</url>
    <content type="text"><![CDATA[StreamJava 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言+多核时代综合影响的产物。 Collection提供了新的stream()方法 流不存储值，通过管道的方式获取值 本质是函数式的，对流的操作会产生一个结果，不过并不会修改底层的数据源，集合可以作为流底层数据源 延迟查找，很多流操作（过滤、映射、排序等）都可以延迟实现 Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。流由3部分构成： 源 零个或多个中间操作 终止操作 流操作的分类： 惰性求值（中间操作） 及早求值（终止操作） 创建流的几种方式123456789101112public class StreamTest &#123; public static void main(String[] args) &#123; Stream stream = Stream.of("hello", "world", "hello world"); String[] strArray = new String[]&#123;"hello", "world", "hello world"&#125;; Stream stream1 = Stream.of(strArray); Stream stream2 = Arrays.stream(strArray); List&lt;String&gt; list = Arrays.asList(strArray); Stream stream3 = list.stream(); &#125;&#125; 流的简单使用1234567891011public class StreamTest2 &#123; public static void main(String[] args) &#123; IntStream.of(new int[]&#123;5, 6, 7&#125;).forEach(System.out::println); System.out.println("--------"); // 不包含8 IntStream.range(3, 8).forEach(System.out::println); System.out.println("--------"); // 包含8 IntStream.rangeClosed(3, 8).forEach(System.out::println); &#125;&#125; 进一步应用1234567public class StreamTest3 &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6); System.out.println(list.stream().map(i -&gt; 2 * i).reduce(0, Integer::sum)); &#125;&#125; Stream转换为数组和集合1234567891011121314151617181920212223242526272829303132public class StreamTest4 &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; stream = Stream.of("hello", "world", "hello world");// String[] strArray = stream.toArray(i -&gt; new String[i]);// Arrays.asList(strArray).forEach(System.out::println);// String[] strArray = stream.toArray(String[]::new);// Arrays.asList(strArray).forEach(System.out::println);// List&lt;String&gt; list = stream.collect(Collectors.toList());// list.forEach(System.out::println); // 第一个参数是要返回的容器，第二个参数是对每一个结果进行处理，第三个参数是把所有处理过的结果组装进要返回的list// List&lt;String&gt; list = stream.collect(() -&gt; new ArrayList(), (theList, item) -&gt; theList.add(item), (theList1, theList2) -&gt; theList1.addAll(theList2));// List&lt;String&gt; list = stream.collect(ArrayList::new, ArrayList::add, ArrayList::addAll);// list.forEach(System.out::println); // 另一个重载的collect方法// List&lt;String&gt; list = stream.collect(Collectors.toCollection(ArrayList::new));// list.forEach(System.out::println); // 转换为Set// Set&lt;String&gt; set = stream.collect(Collectors.toCollection(TreeSet::new));// set.forEach(System.out::println); // 拼接字符串 String str = stream.collect(Collectors.joining()); System.out.println(str); &#125;&#125; map和flatMap1234567891011121314151617public class StreamTest5 &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = Arrays.asList("hello", "world", "helloworld", "test"); list.stream().map(String::toUpperCase).collect(Collectors.toList()).forEach(System.out::println); System.out.println("-------------"); List&lt;Integer&gt; list2 = Arrays.asList(1, 2, 3, 4, 5); list2.stream().map(item -&gt; item * item).collect(Collectors.toList()).forEach(System.out::println); System.out.println("-------------"); // flapMap是把流里的List也打开成一整个流 Stream&lt;List&lt;Integer&gt;&gt; stream = Stream.of(Arrays.asList(1), Arrays.asList(2, 3), Arrays.asList(4, 5, 6)); stream.flatMap(theList -&gt; theList.stream()).map(item -&gt; item).forEach(System.out::println); &#125;&#125; 其他方法1234567891011121314151617181920212223242526272829303132333435363738394041public class StreamTest6 &#123; public static void main(String[] args) &#123;// Stream&lt;String&gt; stream = Stream.generate(UUID.randomUUID()::toString);// stream.findFirst().ifPresent(System.out::println); // iterate会产生一个无限流，所以要配合limit使用 Stream&lt;Integer&gt; stream = Stream.iterate(1, item -&gt; item + 2).limit(6);// stream.forEach(System.out::println); //找出该流中大于2的元素，然后将每个月元素乘以2，然后过滤掉流中的前两个元素，然后再取流中的前两个元素，最后求出流中元素的总和。 // 1,3,5,7,9,11 结果是32// Integer integer = stream.filter(item -&gt; item &gt; 2).mapToInt(item -&gt; item * 2)// .skip(2).limit(2).sum();// System.out.println(integer);// IntSummaryStatistics intSummaryStatistics = stream.filter(item -&gt; item &gt; 2).mapToInt(item -&gt; item * 2)// .skip(2).limit(2).summaryStatistics();// System.out.println(intSummaryStatistics.getCount());// System.out.println(intSummaryStatistics.getMax());// System.out.println(intSummaryStatistics.getMin());// System.out.println(stream);// System.out.println(stream.filter(item -&gt; item &gt; 2)); // 这句代码会抛异常: stream has already been operated upon or closed// System.out.println(stream.distinct()); // 正确的调用方式如下 System.out.println(stream); Stream&lt;Integer&gt; stream2 = stream.filter(item -&gt; item &gt; 2); System.out.println(stream2); Stream&lt;Integer&gt; stream3 = stream2.distinct(); System.out.println(stream3); &#125;&#125; 中间操作和终止操作本质上的区别中间操作都会返回一个Stream对象，比如说返回Stream。终止操作则不会返回Stream类型，可能不返回值，也可能返回其他类型的单个值。 1234567891011121314151617public class StreamTest7 &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = Arrays.asList("hello", "world", "hello world"); // map是一个中间操作，是惰性的，在没有遇到终止操作的时候，中间操作是不会执行的 Stream&lt;String&gt; test = list.stream().map(item -&gt; &#123; String result = item.substring(0, 1).toUpperCase() + item.substring(1); System.out.println("test"); return result; &#125;); // 这句代码才会输入map方法中的test test.forEach(System.out::println); &#125;&#125; 123456789public class StreamTest8 &#123; public static void main(String[] args) &#123; // 这段代码虽然输出了正确的结果，但是程序不会终止，因为distinct一直在为无限流不停的去重 IntStream.iterate(0, i -&gt; (i + 1 ) % 2).distinct().limit(6).forEach(System.out::println); // 下面才是正确的方式 IntStream.iterate(0, i -&gt; (i + 1 ) % 2).limit(6).distinct().forEach(System.out::println); &#125;&#125; 串行流和并行流的区别Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。 12345678910111213141516171819202122232425262728293031323334public class StreamTest9 &#123; public static void main(String[] args) &#123; // 准备500w个uuid来用不同的流进行排序 List&lt;String&gt; list = new ArrayList&lt;&gt;(5000000); for (int i = 0; i &lt; 5000000; i++) &#123; list.add(UUID.randomUUID().toString()); &#125; System.out.println("开始排序"); long startTime = System.nanoTime(); list.stream().sorted().count(); long endTime = System.nanoTime(); long millis = TimeUnit.NANOSECONDS.toMillis(endTime - startTime); System.out.println("排序耗时：" + millis); startTime = System.nanoTime(); list.parallelStream().sorted().count(); endTime = System.nanoTime(); millis = TimeUnit.NANOSECONDS.toMillis(endTime - startTime); System.out.println("排序耗时：" + millis); /** * 开始排序 * 排序耗时：6500 * 排序耗时：3394 */ &#125;&#125; 流的短路123456789101112131415public class StreamTest10 &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = Arrays.asList("hello", "world", "hello world"); // 打印长度为5的第一个单词// list.stream().mapToInt(String::length).filter(length -&gt; length == 5).findFirst().ifPresent(System.out::println); // 下面只会输入出hello和5，因为流针对每一个元素的统一应用所有操作，所以直接找到了第一个hello list.stream().mapToInt(item -&gt; &#123; int length = item.length(); System.out.println(item); return length; &#125;).filter(length -&gt; length == 5).findFirst().ifPresent(System.out::println); &#125;&#125; flatMap的应用场景1234567public class StreamTest11 &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = Arrays.asList("hello welcome", "world hello", "hello world hello", "hello welcome"); // 找出所有单词并且去重 list.stream().flatMap(item -&gt; Arrays.stream(item.split(" "))).distinct().forEach(System.out::println); &#125;&#125; 进一步应用 1234567891011public class StreamTest12 &#123; public static void main(String[] args) &#123; List&lt;String&gt; list1 = Arrays.asList("Hi", "Hello", "你好"); List&lt;String&gt; list2 = Arrays.asList("zhangsan", "lisi", "wangwu", "zhaoliu"); List&lt;String&gt; result = list1.stream().flatMap(item -&gt; list2.stream().map(item2 -&gt; item + " " + item2)).collect(Collectors.toList()); result.forEach(System.out::println); &#125;&#125; 分组：group by操作1234567891011121314151617181920212223242526272829303132333435363738public class StreamTest13 &#123; public static void main(String[] args) &#123; Student student1 = new Student("zhangsan", 100, 20); Student student2 = new Student("lisi", 90, 20); Student student3 = new Student("wangwu", 90, 30); Student student4 = new Student("zhangsan", 80, 40); List&lt;Student&gt; students = Arrays.asList(student1, student2, student3, student4); // select * from student group by name; /* * 传统方式： * 1. 循环列表 * 2. 取出学生名字 * 3. 检查map中是否存在该名字，不存在则直接添加到该map中；存在则将map中的List对象取出来，然后将该Student对象添加到List中 * 4. 返回map对象 */ // 流方式，一行代码 Map&lt;String, List&lt;Student&gt;&gt; map = students.stream().collect(Collectors.groupingBy(Student::getName)); System.out.println(map); // select count(*) from student group by name; Map&lt;String, Long&gt; map1 = students.stream().collect(Collectors.groupingBy(Student::getName, Collectors.counting())); System.out.println(map1); // 每个人的平均分 Map&lt;String, Double&gt; map2 = students.stream().collect(Collectors.groupingBy(Student::getName, Collectors.averagingDouble(Student::getScore))); System.out.println(map2); // 分区是分组的一种特例，就是用条件来分为两组 Map&lt;Boolean, List&lt;Student&gt;&gt; map3 = students.stream().collect(Collectors.partitioningBy(student -&gt; student.getScore() &gt;= 90)); System.out.println(map3); &#125;&#125;]]></content>
      <categories>
        <category>jdk8</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK8-方法引用]]></title>
    <url>%2F2017%2F02%2F05%2Fjdk8-3%2F</url>
    <content type="text"><![CDATA[方法引用方法引用：method reference方法引用实际上是个Lambda表达式的一种语法糖。 我们可以将方法引用看作是一个函数指针，function pointer。 方法引用共分为4类： 类名::静态方法名 1234567891011121314151617181920public class MethodReferenceTest &#123; public static void main(String[] args) &#123; Student student1 = new Student("zhangsan", 10); Student student2 = new Student("lisi", 90); Student student3 = new Student("wangwu", 50); Student student4 = new Student("zhaoliu", 40); List&lt;Student&gt; students = Arrays.asList(student1, student2, student3, student4); // 这是常规的lambda表达式写法 students.sort((o1, o2) -&gt; Student.compareStudentByScore(o1, o2)); students.forEach(student -&gt; System.out.println(student.getScore())); System.out.println("-----------"); // 下面展示方法引用的写法，这就是上面的代码的语法糖，更简洁 students.sort(Student::compareStudentByName); students.forEach(student -&gt; System.out.println(student.getName())); &#125;&#125; 引用名::实例方法名 123456789 public class StudentComparator &#123; public int compareStudentByScore(Student student1, Student student2) &#123; return student1.getScore() - student2.getScore(); &#125; public int compareStudentByName(Student student1, Student student2) &#123; return student1.getName().compareToIgnoreCase(student2.getName()); &#125;&#125; 这里演示了如何使用 123StudentComparator studentComparator = new StudentComparator(); students.sort((o1, o2) -&gt; studentComparator.compareStudentByScore(o1, o2)); students.sort(studentComparator::compareStudentByScore); 类名::实例方法名 新增2个方法 1234567public int compareByScore(Student student) &#123; return this.getScore() - student.getScore(); &#125; public int comparByeName(Student student) &#123; return this.getName().compareToIgnoreCase(student.getName()); &#125; 然后演示 123456//使用lambda表达式和类型对象的实例方法 students.sort((o1, o2) -&gt; o1.compareByScore(o2)); // 使用方法引用 // 引用的是类型对象的实例方法 // 这种方式的调用，lambda表达式的第一个参数是作为调用方，然后其他的lambda表达式参数都作为实例方法的参数传入 students.sort(Student::compareByScore); 构造方法引用：类名::new 123Supplier&lt;Student&gt; supplier = () -&gt; new Student(); // 构造方法引用 Supplier&lt;Student&gt; supplier2 = Student::new;]]></content>
      <categories>
        <category>jdk8</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK8-Optional详解]]></title>
    <url>%2F2017%2F01%2F17%2Fjdk8-2%2F</url>
    <content type="text"><![CDATA[在Java中我们会经常遇到NullPointerException异常，代码里就少不了很多这样的代码 123if(null != obj) &#123; .......&#125; Java 8中的Optional是一个可以包含或不可以包含非空值的容器对象，在 Stream API中很多地方也都使用到了Optional。这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。 我们应该怎么使用Optional这个类呢。 1234567891011121314151617181920public class OptionalTest &#123; public static void main(String[] args) &#123; Optional&lt;String&gt; optional = Optional.of("hello"); // 这是传统方式的代码书写方式// if (optional.isPresent()) &#123;// System.out.println(optional.get());// &#125; // 我们应该用函数式风格来使用Optional optional.ifPresent(System.out::println); System.out.println("------"); System.out.println(optional.orElse("world")); System.out.println("------"); System.out.println(optional.orElseGet(() -&gt; "nihao")); &#125;&#125; 下面再展示一个具体的应用场景 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Employee &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;public class Company &#123; private String name; private List&lt;Employee&gt; employeeList; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public List&lt;Employee&gt; getEmployeeList() &#123; return employeeList; &#125; public void setEmployeeList(List&lt;Employee&gt; employeeList) &#123; this.employeeList = employeeList; &#125;&#125;public class OptionalTest2 &#123; public static void main(String[] args) &#123; Employee employee = new Employee(); employee.setName("zhangsan"); Employee employee2 = new Employee(); employee2.setName("lisi"); Company company = new Company(); company.setName("company1"); List&lt;Employee&gt; employeeList = Arrays.asList(employee, employee2); company.setEmployeeList(employeeList); // 下面的代码使用函数式的风格开发，避免了null判断以及条件分支等等代码 Optional&lt;Company&gt; optional = Optional.ofNullable(company); System.out.println(optional.map(theCompany -&gt; theCompany.getEmployeeList()).orElse(Collections.emptyList())); &#125;&#125;]]></content>
      <categories>
        <category>jdk8</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Security配置cors跨域访问]]></title>
    <url>%2F2016%2F12%2F29%2Fspring-security-cors%2F</url>
    <content type="text"><![CDATA[http://docs.spring.io/spring/docs/current/spring-framework-reference/html/cors.html 文档看似很清晰的描述了如何在Spring 4.2之后启用cors跨域访问，网上搜索介绍这样的帖子也不少。也提到了说什么如果用了Spring Security的话要采用filter的方式来配置。下面这段话就是官方文档 In order to support CORS with filter-based security frameworks like Spring Security, or with other libraries that do not support natively CORS, Spring Framework also provides a CorsFilter. Instead of using @CrossOrigin or WebMvcConfigurer#addCorsMappings(CorsRegistry), you need to register a custom filter defined like bellow:123456789101112131415161718192021import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import org.springframework.web.filter.CorsFilter;public class MyCorsFilter extends CorsFilter &#123; public MyCorsFilter() &#123; super(configurationSource()); &#125; private static UrlBasedCorsConfigurationSource configurationSource() &#123; CorsConfiguration config = new CorsConfiguration(); config.setAllowCredentials(true); config.addAllowedOrigin("http://domain1.com"); config.addAllowedHeader("*"); config.addAllowedMethod("*"); UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration("/**", config); return source; &#125;&#125; 在经过测试之后，实在是无论采用哪一种方式都不行，实在是太费解了，debug了半天跨域的时候GET方法根本连DispatchServlet都不进去，POST方法倒是可以跨域，发现POST请求是根据header的origin来判断是否跨域。 还是想着从Spring Security这边来入手，结果就发现HttpSecurity类提供了这么一个方法。 123456789101112/** * Adds a &#123;@link CorsFilter&#125; to be used. If a bean by the name of corsFilter is * provided, that &#123;@link CorsFilter&#125; is used. Else if corsConfigurationSource is * defined, then that &#123;@link CorsConfiguration&#125; is used. Otherwise, if Spring MVC is * on the classpath a &#123;@link HandlerMappingIntrospector&#125; is used. * * @return the &#123;@link CorsConfigurer&#125; for customizations * @throws Exception */public CorsConfigurer&lt;HttpSecurity&gt; cors() throws Exception &#123; return getOrApply(new CorsConfigurer&lt;HttpSecurity&gt;());&#125; 我抱着试一试的心态，加上了这句话代码。 123456789101112131415161718192021222324252627@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.headers() .frameOptions() .sameOrigin() .and() // disable CSRF, http basic, form login .csrf().disable() // 跨域支持 .cors().and() .httpBasic().disable() // .formLogin().disable() // ReST is stateless, no sessions .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) // .and() // return 403 when not authenticated .exceptionHandling().authenticationEntryPoint(new NoAuthenticationEntryPoint()); // Let child classes set up authorization paths setupAuthorization(http); http.addFilterBefore(jsonWebTokenFilter, UsernamePasswordAuthenticationFilter.class);&#125; 就是.cors().and()这句了，然后还是采用addCorsMappings方法来配置。 12345678910111213@Configurationpublic class WebConfig extends WebMvcConfigurerAdapter &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping("/api/**") .allowedOrigins("http://domain2.com") .allowedMethods("PUT", "DELETE") .allowedHeaders("header1", "header2", "header3") .exposedHeaders("header1", "header2") .allowCredentials(false).maxAge(3600); &#125;&#125; 结果当然是成功了，Spring的文档也老是跟不上节奏，还是需要自己多探索和思考。希望能帮到遇到这个问题的朋友们。]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK8-Lambda表达式初步与函数式接口]]></title>
    <url>%2F2016%2F12%2F19%2Fjdk8-1%2F</url>
    <content type="text"><![CDATA[Lambda表达式初步与函数式接口“Lambda 表达式”(lambda expression)是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包（注意和数学传统意义上的不同）。 为何需要Lambda表达式 在Java中，我们无法将函数作为参数传递给一个方法，也无法声明返回一个函数的方法。 在JavaScript中，函数参数一个函数，返回值是另一个函数的情况是非常常见的；JavaScript是一门非常典型的函数式语言。 Java匿名内部类示例： 123456new Thread(new Runnable() &#123; @Override public void run() &#123; // do something &#125;&#125;); 这样写是有点繁琐的，在Java8中可以直接下面这样写 123new Thread(() -&gt; &#123; // do something &#125;); 在Java8的循环中，我们也可以很方便的使用Lambda表达式。示例如下： 123456789List&lt;Integer&gt; list = Arrays.assList(1,2,3,4,5);// foreach语法for(Integer i : list) &#123; System.out.println(i); &#125;// JDK8新增的forEach方法list.forEach(i -&gt; System.out.println(i));// 这种只有一行代码，一个参数的调用，我们甚至还可以再简化一点list.forEach(System.out::println); 看forEach的方法源码 123456default void forEach(Consumer&lt;? super T&gt; action) &#123; Objects.requireNonNull(action); for (T t : this) &#123; action.accept(t); &#125;&#125; 接受了一个Consumer参数，这个接口是JDK8新增的一个函数式接口。什么是函数式接口？ 一个接口，有且只有一个抽象方法，这个接口就称为函数式接口。 如果我们在某个接口上声明了@FunctionalInterface注解，那么编译器就会按照函数式接口的定义来要求该接口。 如果某个接口只有抽象方法，但我们并没有给该接口声明@FunctionalInterface注解，那么编译器依旧会将该接口看做是函数式接口。 12345678910@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123; void accept(T t); default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) &#123; Objects.requireNonNull(after); return (T t) -&gt; &#123; accept(t); after.accept(t); &#125;; &#125;&#125; 我们来试试自己写一个函数式接口。 1234567891011121314151617181920212223@FunctionalInterfaceinterface MyInterface &#123; void test(); // 这个不算抽象方法，因为MyInterface的实现类必然是Object的子类，他会直接继承Object类的实现，实现类依然只需要实现test()方法。 String toString();&#125;public class Test &#123; public void myTest(MyInterface myInterface) &#123; myInterface.test(); &#125; public static void main(String[] args) &#123; Test test = new Test(); test.myTest(() -&gt; &#123; // 这里就是MyInterface.test()方法的实现 System.out.println("mytest"); &#125;); &#125;&#125; Lambda表达式的作用Lambda表达式为Java添加了缺失的函数式编程特性，使我们能将函数当作一等公民看待。在将函数作为一等公民的语言中，Lambda表达式是类型是函数。但在Java中，Lambda表达式是对象，他们必须依附于一类特别的对象类型—-函数式接口（functional interface）。 例子下面是用lambda表达式和stream来对一个列表的字符串进行大写字母转换。 12List&lt;String&gt; list = Lists.newArrayList("hello", "world", "hello world");list.stream().map(String::toUpperCase).forEach(System.out::println); 上面看到有2个冒号的地方，这个叫做方法引用，方法引用有四种方式，这是其中一种，通过类的方式引用。 1234567891011121314Function&lt;String, String&gt; function = String::toUpperCase;System.out.println(function.apply("hello"));``` 那么对象会被当做lambda表达式的第一个参数传入，上面的代码就相当于"hello".toUpperCase();下面演示一个Comparator的例子```javaList&lt;String&gt; names = Arrays.asList("zhangsan", "lisi", "wangwu", "zhaoliu");Collections.sort(names, (o1, o2) -&gt; o2.compareTo(o1));System.out.println(names); 这就是一个倒序排序，Collections.sort()的第二个参数就是一个Comparator对象，我们用lambda表示来写的，看一下Comparator是声明为函数式接口。所以可以用lambda来写。 12@FunctionalInterfacepublic interface Comparator&lt;T&gt; Java Lambda基本语法 Java中的Lambda表达式基本语法 (arg) -&gt; (body) 比如 (arg1, arg2) -&gt; {bodu} (type1 arg1, type2 arg2…) -&gt; {body} 示例 (int a, int b) -&gt; { return a + b; } () -&gt; System.out.println(“Hello World”); (String s) -&gt; {System.out.println(s);} () -&gt; 42 Java Lambda结构 一个Lambda表达式可以有零个或多个参数 参数的类型既可以明确声明，也可以根据上下文来推断。例如：(int a)与(a)效果相同。 所有参数需包含在圆括号内，参数之间用逗号相隔。例如：(a,b)或(int a,int b)或(String a,int b, float c) 空圆括号代表参数集为空。例如：() -&gt; 42 当只有一个参数，且其类型可推导时，圆括号()可省略。例如：a -&gt; return a * a; Lambda表达式的主体可包含零条或多条语句。 如果Lambda表达式的主体只有一条语句，花括号{}可省略。匿名函数的返回类型与该主体表达式一致。 如果Lambda表达式的主体包含一条以上语句，则表达式必须包含在花括号{}中(形成代码块)。匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空。 主要接口详解Function接口12345678910111213141516171819202122public class FunctionTest &#123; public static void main(String[] args) &#123; FunctionTest test = new FunctionTest(); System.out.println(test.compute(1, value -&gt; 2 * value)); System.out.println(test.compute(2, value -&gt; 5 + value)); System.out.println(test.compute(3, value -&gt; value * value)); Function&lt;Integer, String&gt; function = String::valueOf; System.out.println(test.convert(5, function.compose((Integer i) -&gt; i + 1))); &#125; public int compute(int a, Function&lt;Integer, Integer&gt; function) &#123; int result = function.apply(a); return result; &#125; public String convert(int a, Function&lt;Integer, String&gt; function) &#123; return function.apply(a); &#125;&#125; compose和andThencompose()方法，它接受一个Function，也返回一个Function，结果就是执行参数里的apply，再执行本对象的apply。andThen()方法则相反，是先执行本对象的apply，再执行参数Function的apply。 12345678910111213141516171819202122232425262728293031323334353637383940public class FunctionTest2 &#123; public static void main(String[] args) &#123; FunctionTest2 test2 = new FunctionTest2(); // 输出12 System.out.println(test2.compute(2, value -&gt; value * 3, value -&gt; value * value)); // 输出36 System.out.println(test2.compute2(2, value -&gt; value * 3, value -&gt; value * value)); // 动态+-操作 System.out.println(test2.compute3(1, 2, (value1, value2) -&gt; value1 + value2)); System.out.println(test2.compute3(1, 2, (value1, value2) -&gt; value1 - value2)); // BIFunction实例 System.out.println(test2.compute4(2, 3, (value1, value2) -&gt; value1 + value2, value -&gt; value * value)); &#125; public int compute(int a, Function&lt;Integer, Integer&gt; function1, Function&lt;Integer, Integer&gt; function2) &#123; return function1.compose(function2).apply(a); &#125; public int compute2(int a, Function&lt;Integer, Integer&gt; function1, Function&lt;Integer, Integer&gt; function2) &#123; return function1.andThen(function2).apply(a); &#125; public int compute3(int a, int b, BiFunction&lt;Integer, Integer, Integer&gt; biFunction) &#123; return biFunction.apply(a, b); &#125; public int compute4(int a, int b, BiFunction&lt;Integer, Integer, Integer&gt; biFunction, Function&lt;Integer, Integer&gt; function) &#123; return biFunction.andThen(function).apply(a, b); &#125;&#125; BiFunction接受2个参数，返回一个值的函数式接口。 123456789101112131415161718192021222324252627282930313233343536373839public class PersonTest &#123; public static void main(String[] args) &#123; Person person1 = new Person("zhangsan", 20); Person person2 = new Person("lisi", 30); Person person3 = new Person("wangwu", 40); List&lt;Person&gt; people = Arrays.asList(person1, person2, person3); PersonTest test = new PersonTest();// List&lt;Person&gt; personResult = test.getPeopleByUsername("zhangsan", people);// personResult.forEach(person -&gt; System.out.println(person.getUsername()));// List&lt;Person&gt; personResult = test.getPeopleByAge(20, people);// personResult.forEach(person -&gt; System.out.println(person.getAge())); List&lt;Person&gt; personResult = test.getPeopleByAge2(20, people, (ageOfPerson, personList) -&gt; personList.stream().filter(person -&gt; person.getAge() &gt; ageOfPerson).collect(Collectors.toList())); personResult.forEach(person -&gt; System.out.println(person.getAge())); &#125; public List&lt;Person&gt; getPeopleByUsername(String username, List&lt;Person&gt; people) &#123; return people.stream().filter(person -&gt; person.getUsername().equals(username)).collect(Collectors.toList()); &#125; public List&lt;Person&gt; getPeopleByAge(int age, List&lt;Person&gt; people) &#123; BiFunction&lt;Integer, List&lt;Person&gt;, List&lt;Person&gt;&gt; biFunction = (ageOfPerson, personList) -&gt; personList.stream().filter(person -&gt; person.getAge() &gt; ageOfPerson).collect(Collectors.toList()); return biFunction.apply(age, people); &#125; public List&lt;Person&gt; getPeopleByAge2(int age, List&lt;Person&gt; people, BiFunction&lt;Integer, List&lt;Person&gt;, List&lt;Person&gt;&gt; biFunction) &#123; return biFunction.apply(age, people); &#125;&#125; Predicate判断用的函数式接口 123456public class PredicateTest &#123; public static void main(String[] args) &#123; Predicate&lt;String&gt; predicate = p -&gt; p.length() &gt; 5; System.out.println(predicate.test("hello")); &#125;&#125; 代码测试1234567891011121314151617181920212223242526272829public class PredicateTest2 &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); PredicateTest2 predicateTest2 = new PredicateTest2(); predicateTest2.conditionFilter(list, i -&gt; i % 2 == 0); predicateTest2.conditionFilter2(list, item -&gt; item &gt; 5, item -&gt; item % 2 == 0); &#125; // 以前我们在对数据进行筛选或者处理的时候，一般是单独定义一个方法来进行处理，现在我们只需要把筛选条件当作参数传入 public void conditionFilter(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate) &#123; for (Integer integer : list) &#123; if (predicate.test(integer)) &#123; System.out.println(integer); &#125; &#125; &#125; // Predicate的其他方法测试 public void conditionFilter2(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate, Predicate&lt;Integer&gt; predicate2) &#123; for (Integer integer : list) &#123; if (predicate.or(predicate2).test(integer)) &#123; System.out.println(integer); &#125; &#125; &#125;&#125; Supplier简单测试 1234567public class SupplierTest &#123; public static void main(String[] args) &#123; Supplier&lt;String&gt; supplier = () -&gt; "hello world"; System.out.println(supplier.get()); &#125;&#125; java.util.function包下面还有很多函数式接口，无非就是0参数，1个参数，2个参数的接口，用法都是一样的。12345678910111213141516171819202122public class BinaryOperatorTest &#123; public static void main(String[] args) &#123; BinaryOperatorTest binaryOperatorTest = new BinaryOperatorTest(); System.out.println(binaryOperatorTest.compute(1, 2, (a, b) -&gt; a + b)); System.out.println(binaryOperatorTest.compute(1, 2, (a, b) -&gt; a - b)); System.out.println("----------------"); System.out.println(binaryOperatorTest.getShort("hello123", "world", (a, b) -&gt; a.length() - b.length())); &#125; public int compute(int a, int b, BinaryOperator&lt;Integer&gt; binaryOperator) &#123; return binaryOperator.apply(a, b); &#125; public String getShort(String a, String b, Comparator&lt;String&gt; comparator) &#123; return BinaryOperator.minBy(comparator).apply(a, b); &#125;&#125;]]></content>
      <categories>
        <category>jdk8</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程7-取消与关闭]]></title>
    <url>%2F2016%2F12%2F14%2Fconcurrency7%2F</url>
    <content type="text"><![CDATA[取消与关闭任务和线程的启动很容易。在大多数时候，我们都会让它们运行直到结束，或者让它们自行停止。然而，有时候我们希望提前结束任务或线程，或许是因为用户取消了操作，或者应用程序需要被快速关闭。 任务取消在Java中没有一种安全的抢占式方法来停止线程，因此也就没有安全的抢占式方法来停止任务。只有一些协作式的机制，使请求取消的任务和代码都遵循一种协商好的协议。 1234567private volatile boolean cancelled;public void run() &#123; while(!cancelled)&#123; // do something &#125;&#125; 中断一些特殊的阻塞库的方法支持中断。线程中断是一种协作机制，线程可以通过这种机制来通知另一个线程，告诉它在合适的或者可能的情况下轻质当前工作，并转而执行其他的工作。 在Java的API或语言规范中，并没有将中断与任何取消语义关联起来，但实际上，如果在取消之外的其他操作中使用中断，那么都是不合适的，并且很难职称起更大的应用。 每个线程都有一个boolean类型的中断状态。当中断线程时，这个线程的中断状态将设置为true。在Thread中包含了中断线程以及查询中断状态的方法。interrupt方法能中断目标线程，isInterrupted方法能返回目标线程的中断状态。静态方法interrupted将清除当前线程的中断状态，并返回它之前的值，这也是清除中断状态的唯一方法。 12345public class Thread()&#123; public void interrupt() &#123;...&#125; public boolean isInterrupted() &#123;...&#125; public static boolean interrupted() &#123;...&#125;&#125; 调用interrupt并不意味着立即停止目标线程正在进行的工作，而只是传递了请求中断的消息。 中断策略正如任务中应该包含取消策略一样，线程同样应该包含中断策略。中断策略规定线程如何解释某个中断请求-当发现中断请求时，应该做哪些工作。由于每个线程拥有各自的中断策略，因此除非你知道中断对该线程的含义，否则就不应该中断这个线程。 响应中断当调用可中断的阻塞函数时，例如Thread.sleep或BlockingQueue.put等，有两种实用策略可用于处理InterruptedException: 传递异常，从而使你的方法也成为可中断的阻塞方法 恢复中断方法，从而使调用栈中的上层代码能够对进行处理。 只有实现了线程中断策略的代码才可以屏蔽中断请求。在常规的任务和库代码中都不应该屏蔽中断请求。 处理不可中断的阻塞并非所有的可阻塞方法或者阻塞机制都能相应中断；如果一个线程由于执行同步的Socket I/O或者等待获得内置锁而阻塞，那么中断请求只能设置线程的中断状态，除此之外没有其他任何作用。对于那些由于执行补课中断操作而被阻塞的线程，可以使用类似于中断的手段来停止这些线程，但这要求我们必须知道线程阻塞的原因。 停止基于线程的服务应用程序通常会创建拥有多个线程的服务，例如线程池，并且这些服务的生命周期通常比创建它们的方法的生命周期更长。如果应用程序准备退出，那么这些服务所拥有的线程也需要结束。由于无法通过抢占式的方法来停止线程，因此它们需要自行结束。 除非拥有某个线程，否则不能对该线程进行操控。对于持有线程的服务，只要服务的存在时间大于创建线程的方法的存在时间，那么就应该提供生命周期方法。 例如日志服务，为了不给程序带来性能开销，记录日志的操作有一种方法是通过调用log方法将日志消息放入某个队列中，并由其他线程来处理。然后我们要合理的处理这个日志队列，避免因为JVM无法正常关闭时，停止日志线程导致消息丢失。 关闭ExecutorServiceExecutorService提供两种关闭方法：使用shutdown正常关闭，以及使用shutdownNow强行关闭。在进行强行关闭时，shutdownNow首先关闭当前正在执行的任务，然后返回所有尚未启动的任务清单。 这两种关闭方式的差别在于各自的安全性和响应性：强行关闭的速度更快，但风险也更大，因为任务很可能在执行到一半时被结束；而正常关闭虽然速度慢，但却更安全，因为ExecutorService会一直等到队列中的所有任务都执行完成后才关闭。在其他拥有线程的服务中也应该考虑提供累死的关闭方式以供选择。 shutdownNow的局限性当通过shutdownNow来强行关闭ExecutorService时，它会尝试取消正在执行的任务，并返回所有已提交但尚未开始的任务，从而将这些任务写入日志或者保存起来以便之后进行处理。 然而，我们无法通过常规方法来找出哪些任务已经开始但尚未结束。这意味着我们无法在关闭过程中知道正在执行的任务的状态，除非任务本身会执行某种检查。要知道哪些任务还没有完成，你不仅需要知道哪些任务还没有开始，而且还需要知道当Executor关闭时哪些任务正在执行。 未捕获的异常当线程内代码抛出RuntimeException时，Thread API提供了uncaughtExceptionHanlder，它能检测出某个线程由于未捕获的异常而终结的情况。 12345678910111213141516171819202122232425262728293031323334353637public class CaptureUncaughtException &#123; public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(new HandlerThreadFactory()); executorService.execute(new ExceptionThread2()); &#125;&#125;class ExceptionThread2 implements Runnable &#123; @Override public void run() &#123; Thread t = Thread.currentThread(); System.out.println("run() by " + t); System.out.println("eh = " + t.getUncaughtExceptionHandler()); throw new RuntimeException(); &#125;&#125;class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler &#123; @Override public void uncaughtException(Thread t, Throwable e) &#123; System.out.println("caught " + e); &#125;&#125;class HandlerThreadFactory implements ThreadFactory &#123; @Override public Thread newThread(Runnable r) &#123; System.out.println(this + " creating new Thread"); Thread t = new Thread(r); System.out.println("created " + t); t.setUncaughtExceptionHandler(new MyUncaughtExceptionHandler()); System.out.println("eh = " + t.getUncaughtExceptionHandler()); return t; &#125;&#125; JVM关闭JVM既可以正常关闭，也可以强行关闭。 关闭钩子在正常关闭中，JVM首先调用所有已注册的关闭钩子。关闭钩子是指通过Runtime.addShutdownHook注册的但尚未开始的线程。JVM并不能保证关闭钩子的调用顺序。在关闭应用程序线程时，如果有（守护或非守护）线程仍然在运行，那么这些线程接下来将与关闭进程并发执行。当所有的关闭钩子都执行结束时，如果runFinalizersOnExit为true，那么JVM将运行终结器，然后再停止。JVM并不会停止或中断任何在关闭时仍然运行的应用程序线程。当JVM最终结束时，这些线程将被强行结束。如果关闭钩子或终结器没有执行完成，那么正常关闭进行“挂起”并且JVM必须被强行关闭。当被强行关闭时，只是关闭JVM，而不会运行关闭钩子。 守护线程线程可分为两种：普通线程和守护线程。在JVM启动时创建的所有线程中，除了主线程以外，其他的线程都是守护线程（例如垃圾回收器以及其他执行辅助工作的线程）。当创建一个新线程时，新线程将继承创建它的线程的守护状态，因此在默认情况下，主线程创建的所有线程都是普通线程。 普通线程与守护线程之间的差异仅在于当线程退出时发生的操作。当一个线程退出时，JVM会检查其他正在运行的线程，如果这些线程都是守护线程，那么JVM会正常退出操作。当JVM停止时，所有仍然存在的守护线程都将被抛弃—-既不会执行finally代码块，也不会执行回卷栈，而JVM只是退出。我们应尽可能少地使用守护线程。 终结器finalize方法就是终结器，JVM并不保证何时运行甚至是否运行，应该避免使用终结器。 小结在任务、线程、服务以及应用程序等模块中的生命周期结束问题，可能会增加它们在设计和实现时的复杂性。Java并没有提供某种抢占式的机制来取消操作或者终结线程。相反，它提供了一种协作式的中断机制来实现取消操作，但这要依赖于如何构建取消操作的协议，以及能否始终遵循这些协议。通过FutureTask和Executor框架，可以帮助我们构建可取消的任务和服务。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016-12-13-life]]></title>
    <url>%2F2016%2F12%2F13%2F2016-12-13-life%2F</url>
    <content type="text"><![CDATA[I am BlankCat，welcome to my blog； ##生活感悟 无论遇见什么事，切记别发火，地铁上一个人和一个老人抢座，那个男的非逼自己的老婆坐在自己旁边，挤那个老人，没有风度，切记不要那样。 ####从刘老师身上学到的 学会慢，说话慢慢说，学会安静，就学学刘老师是怎么处理生活和工作。 ####对技术的感悟 对于技术层面，要高度模仿别人的思维，和别人的工作方式 把复杂的工作简单化 做一件事，要清楚自己的目标，我要啥，我有啥，我该怎么做 ####今日总结（2016-12-13） zookeeper命令的操作（上午） 看电子书《angular》基础知识 （下午） 写了一篇博客，画一个界面 ####明日memo 坚持吃早餐 梳理业务需求，完成近期的开发工作 坚持画一个界面 坚持学博客]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程6-任务执行]]></title>
    <url>%2F2016%2F12%2F13%2Fconcurrency6%2F</url>
    <content type="text"><![CDATA[任务执行任务通常是一些抽象的且离散的工作单元。通过把应用程序的工作分解到多个任务中，可以简化程序的组织结构 在线程中执行任务在理想情况下，各个任务之间是相互独立的：任务并不依赖其他任务的状态、结果或边界效应。独立性有助于实现并发，例如向web服务器提交一个请求，不会影响正在处理的其他请求。 为任务创建线程如果为每一个任务都创建一个线程，那么资源开销是极大的，无限制的创建线程存在一些缺陷： 线程生命周期的开销非常高 资源消耗 稳定性 Executor框架 123public interface Executor &#123; void execute(Runnable command);&#125; Executor基于生产者-消费者模式，提交任务的操作相当于生产者（生成待完成的工作单元），执行任务的线程则相当于消费者（执行完这些工作单元）。 每当看到下面这种形式的代码时： new Thread(runnable).start(); 并且你希望获得一种更灵活的执行策略时，请考虑使用Executor来代替Thread。 线程池线程池从字面意思来看，是指管理一组同构工作线程的资源池。 在线程池中执行任务比「为每一个任务分配一个线程」优势更多。通过重用现有的线程而不是创建新线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销。另外一个额外的好处死，当请求到达时，工作线程通常已经存在，因此不会由于等待创建线程而延迟任务的执行，从而提高了响应性。 Executors中的静态工厂方法提供了一些线程池： newFixedThreadPool newCachedThreadPool newSingleThreadExecutor newScheduledThreadPool Executor的生命周期ExecutorService提供了一些用于生命周期管理的方法。 1234567891011121314public interface ExecutorService extends Executor &#123; void shutdown(); List&lt;Runnable&gt; shutdownNow(); boolean isShutdown(); boolean isTerminated(); boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException; &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task); &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result); Future&lt;?&gt; submit(Runnable task); &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; ExecutorService的生命周期有3种状态：运行、关闭和已终止。ExecutorService在初始创建时处于运行状态。shotdown方法将执行平缓的关闭过程：不再接受新的任务，同事等待已经提交的任务执行完成–包括那些还未开始执行的任务。shotdownNow方法将执行粗暴的关闭过程：它将尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务。 延迟任务与周期任务Timer类负责管理延迟任务以及周期任务。然而，Timer存在一些缺陷，因此应该考虑使用ScheduledThreadPoolExecutor来代替它。 携带结果的任务Callable与FutureCallable：它人为主入口点将返回一个值，并可能抛出一个异常。Future表示一个任务的生命周期，并提供相应的方法来判断是否已经完成或取消，以及获取任务的结果和取消任务等。 可以通过许多种方法创建一个Future来描述任务。ExecutorService中的所有submit方法都将反悔一个Future，从而将一个Runnable或Callable提交给Executor，并得到一个Future用来获得任务的执行结果或者取消任务。 CompletionService与BlockingQueueCompletionService将Executor和BlockingQueue的功能融合在一起。你可以将Callable任务提交给它来执行，然后使用类似于队列操作的take和poll等方法来获得已完成的结果，而这些结果会在完成时将被封装为Future。ExecutorCompletionService实现了CompletionService，并将计算部分委托给一个Executor。 小结通过围绕任务执行来设计应用程序，可以简化开发过程，并有助于实现并发。Executor框架将任务提交与执行策略解耦开来，同时还支持多重不同类型的执行策略。当需要创建线程来执行任务时，可以考虑使用Executor。要想在将应用程序分解为不同的任务时获得最大的好处，必须定义清晰的任务边界。某些应用程序中存在着比较明显的任务边界，而在其他一些程序中则需要进一步分析才能揭示出粒度更细的并行性。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集成JWT到Spring Boot项目]]></title>
    <url>%2F2016%2F12%2F08%2Fspring-boot-jwt%2F</url>
    <content type="text"><![CDATA[这篇文章我们来讲一下如何集成JWT到Spring Boot项目中来完成接口的权限验证。 JWTJWT是一种用于双方之间传递安全信息的简洁的、URL安全的表述性声明规范。JWT作为一个开放的标准（ RFC 7519 ），定义了一种简洁的，自包含的方法用于通信双方之间以Json对象的形式安全的传递信息。因为数字签名的存在，这些信息是可信的，JWT可以使用HMAC算法或者是RSA的公私秘钥对进行签名。如何使用JWT？ 在身份鉴定的实现中，传统方法是在服务端存储一个session，给客户端返回一个cookie，而使用JWT之后，当用户使用它的认证信息登陆系统之后，会返回给用户一个JWT，用户只需要本地保存该token（通常使用local storage，也可以使用cookie）即可。因为用户的状态在服务端的内存中是不存储的，所以这是一种 无状态 的认证机制。服务端的保护路由将会检查请求头 Authorization 中的JWT信息，如果合法，则允许用户的行为。由于JWT是自包含的，因此减少了需要查询数据库的需要。 JWT的这些特性使得我们可以完全依赖其无状态的特性提供数据API服务，甚至是创建一个下载流服务。因为JWT并不使用Cookie的，所以你可以使用任何域名提供你的API服务而不需要担心跨域资源共享问题（CORS）。大概就是这样： Spring Boot集成我是勤劳的搬运工，这应该是翻译老外的东西，项目地址：https://github.com/thomas-kendall/trivia-microservices。 废话不多说了，我直接上代码,依然是搬运工。我是gradle构建的，就是引入一些依赖的jar包。顺便推荐一下阿里云的中央仓库 http://maven.aliyun.com/nexus/content/groups/public/ 12345678910111213141516dependencies &#123; compile('org.springframework.boot:spring-boot-starter-aop') compile('org.springframework.boot:spring-boot-starter-security') compile('org.mybatis.spring.boot:mybatis-spring-boot-starter:1.1.1') compile('org.springframework.boot:spring-boot-starter-web') compile('com.google.guava:guava:20.0') compile('com.alibaba:druid:0.2.9') compile('org.apache.commons:commons-lang3:3.5') compile('commons-collections:commons-collections:3.2.2') compile('commons-codec:commons-codec:1.10') compile('com.github.pagehelper:pagehelper:4.1.6') compile('io.jsonwebtoken:jjwt:0.6.0') runtime('mysql:mysql-connector-java') compileOnly('org.projectlombok:lombok') testCompile('org.springframework.boot:spring-boot-starter-test')&#125; 下面这个是类是产生token的主要类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * Created by YangFan on 2016/11/28 上午10:01. * &lt;p/&gt; */@Slf4jpublic class JsonWebTokenUtility &#123; private SignatureAlgorithm signatureAlgorithm; private Key secretKey; public JsonWebTokenUtility() &#123; // 这里不是真正安全的实践 // 为了简单，我们存储一个静态key在这里， signatureAlgorithm = SignatureAlgorithm.HS512; String encodedKey = "L7A/6zARSkK1j7Vd5SDD9pSSqZlqF7mAhiOgRbgv9Smce6tf4cJnvKOjtKPxNNnWQj+2lQEScm3XIUjhW+YVZg=="; secretKey = deserializeKey(encodedKey); &#125; public String createJsonWebToken(AuthTokenDetails authTokenDetails) &#123; String token = Jwts.builder().setSubject(authTokenDetails.getId().toString()) .claim("username", authTokenDetails.getUsername()) .claim("roleNames", authTokenDetails.getRoleNames()) .setExpiration(authTokenDetails.getExpirationDate()) .signWith(getSignatureAlgorithm(), getSecretKey()).compact(); return token; &#125; private Key deserializeKey(String encodedKey) &#123; byte[] decodedKey = Base64.getDecoder().decode(encodedKey); Key key = new SecretKeySpec(decodedKey, getSignatureAlgorithm().getJcaName()); return key; &#125; private Key getSecretKey() &#123; return secretKey; &#125; public SignatureAlgorithm getSignatureAlgorithm() &#123; return signatureAlgorithm; &#125; public AuthTokenDetails parseAndValidate(String token) &#123; AuthTokenDetails authTokenDetails = null; try &#123; Claims claims = Jwts.parser().setSigningKey(getSecretKey()).parseClaimsJws(token).getBody(); String userId = claims.getSubject(); String username = (String) claims.get("username"); List&lt;String&gt; roleNames = (List) claims.get("roleNames"); Date expirationDate = claims.getExpiration(); authTokenDetails = new AuthTokenDetails(); authTokenDetails.setId(Long.valueOf(userId)); authTokenDetails.setUsername(username); authTokenDetails.setRoleNames(roleNames); authTokenDetails.setExpirationDate(expirationDate); &#125; catch (JwtException ex) &#123; log.error(ex.getMessage(), ex); &#125; return authTokenDetails; &#125; private String serializeKey(Key key) &#123; String encodedKey = Base64.getEncoder().encodeToString(key.getEncoded()); return encodedKey; &#125;&#125; 现在我们需要一个定制授权过滤器，将能读取请求头部信息，在Spring中已经有一个这样的授权Filter称为：RequestHeaderAuthenticationFilter，我们只要扩展继承即可： 123456789101112131415161718@Componentpublic class JsonWebTokenAuthenticationFilter extends RequestHeaderAuthenticationFilter &#123; public JsonWebTokenAuthenticationFilter() &#123; // Don't throw exceptions if the header is missing this.setExceptionIfHeaderMissing(false); // This is the request header it will look for this.setPrincipalRequestHeader("Authorization"); &#125; @Override @Autowired public void setAuthenticationManager( AuthenticationManager authenticationManager) &#123; super.setAuthenticationManager(authenticationManager); &#125;&#125; 在这里，头部信息将被转换为Spring Authentication对象，名称为PreAuthenticatedAuthenticationToken我们需要一个授权提供者读取这个记号，然后验证它，然后转换为我们自己的定制授权对象，就是把header里的token转化成我们自己的授权对象。然后把解析之后的对象返回给Spring Security，这里就相当于完成了token-&gt;session的转换。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Componentpublic class JsonWebTokenAuthenticationProvider implements AuthenticationProvider &#123; private JsonWebTokenUtility tokenService = new JsonWebTokenUtility(); @Override public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; Authentication authenticatedUser = null; // Only process the PreAuthenticatedAuthenticationToken if (authentication.getClass(). isAssignableFrom(PreAuthenticatedAuthenticationToken.class) &amp;&amp; authentication.getPrincipal() != null) &#123; String tokenHeader = (String) authentication.getPrincipal(); UserDetails userDetails = parseToken(tokenHeader); if (userDetails != null) &#123; authenticatedUser = new JsonWebTokenAuthentication(userDetails, tokenHeader); &#125; &#125; else &#123; // It is already a JsonWebTokenAuthentication authenticatedUser = authentication; &#125; return authenticatedUser; &#125; private UserDetails parseToken(String tokenHeader) &#123; UserDetails principal = null; AuthTokenDetails authTokenDetails = tokenService.parseAndValidate(tokenHeader); if (authTokenDetails != null) &#123; List&lt;GrantedAuthority&gt; authorities = authTokenDetails.getRoleNames().stream() .map(SimpleGrantedAuthority::new).collect(Collectors.toList()); // userId介入Spring Security principal = new User(authTokenDetails.getId().toString(), "", authorities); &#125; return principal; &#125; @Override public boolean supports(Class&lt;?&gt; authentication) &#123; return authentication.isAssignableFrom( PreAuthenticatedAuthenticationToken.class)|| authentication.isAssignableFrom( JsonWebTokenAuthentication.class); &#125;&#125; Spring Security上面完成了JWT和Spring Boot的集成。接下来我们再如何把自己的权限系统也接入Spring Security。刚才已经展示了通过JsonWebTokenAuthenticationProvider的处理，我们已经能通过header的token来识别用户，并拿到他的角色和userId等信息。 配置Spring Security有3个不可缺的类。首先配置拦截器，拦截所有的请求。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * Created by YangFan on 2016/11/28 上午11:32. * &lt;p/&gt; */@Componentpublic class DemoSecurityInterceptor extends AbstractSecurityInterceptor implements Filter &#123; @Autowired private FilterInvocationSecurityMetadataSource securityMetadataSource; @Autowired @Override public void setAccessDecisionManager(AccessDecisionManager accessDecisionManager) &#123; super.setAccessDecisionManager(accessDecisionManager); &#125; @Autowired @Override public void setAuthenticationManager(AuthenticationManager authenticationManager) &#123; super.setAuthenticationManager(authenticationManager); &#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; FilterInvocation fi = new FilterInvocation(request, response, chain); invoke(fi); &#125; public Class&lt;? extends Object&gt; getSecureObjectClass() &#123; return FilterInvocation.class; &#125; public void invoke(FilterInvocation fi) throws IOException, ServletException &#123; InterceptorStatusToken token = super.beforeInvocation(fi); try &#123; fi.getChain().doFilter(fi.getRequest(), fi.getResponse()); &#125; finally &#123; super.afterInvocation(token, null); &#125; &#125; @Override public SecurityMetadataSource obtainSecurityMetadataSource() &#123; return this.securityMetadataSource; &#125; public void destroy() &#123; &#125; public void init(FilterConfig filterconfig) throws ServletException &#123; &#125;&#125; 然后是把我们自己的权限数据加载到Spring Security中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/** * Created by YangFan on 2016/11/28 上午11:33. * &lt;p/&gt; * 最核心的地方，就是提供某个资源对应的权限定义，即getAttributes方法返回的结果。 * 此类在初始化时，应该取到所有资源及其对应角色的定义。 */@Componentpublic class DemoInvocationSecurityMetadataSourceService implements FilterInvocationSecurityMetadataSource &#123; private static Map&lt;String, Collection&lt;ConfigAttribute&gt;&gt; resourceMap = null; public DemoInvocationSecurityMetadataSourceService() &#123; &#125; private void loadResourceDefine() &#123; /* * 应当是资源为key， 权限为value。 资源通常为url， 权限就是那些以ROLE_为前缀的角色。 一个资源可以由多个权限来访问。 * sparta */ Role r = new Role(); r.setId(0L); r.setName("admin"); // 假数据 List&lt;Role&gt; roles = Collections.singletonList(r); // 替换为查询角色列表 resourceMap = new HashMap&lt;&gt;(); for (Role role : roles) &#123; ConfigAttribute ca = new SecurityConfig(role.getName()); Map&lt;String, Object&gt; params = new HashMap&lt;&gt;(); params.put("roleId", role.getId()); // 查询每个角色对于的权限,我这里假设直接查到了url List&lt;String&gt; resources = Collections.singletonList("/user/*"); for (String url : resources) &#123; /* * 判断资源文件和权限的对应关系，如果已经存在相关的资源url，则要通过该url为key提取出权限集合，将权限增加到权限集合中。 * sparta */ if (resourceMap.containsKey(url)) &#123; Collection&lt;ConfigAttribute&gt; value = resourceMap.get(url); value.add(ca); resourceMap.put(url, value); &#125; else &#123; Collection&lt;ConfigAttribute&gt; atts = new ArrayList&lt;&gt;(); atts.add(ca); resourceMap.put(url, atts); &#125; &#125; &#125; &#125; @Override public Collection&lt;ConfigAttribute&gt; getAllConfigAttributes() &#123; loadResourceDefine(); return null; &#125; // 根据URL，找到相关的权限配置。 @Override public Collection&lt;ConfigAttribute&gt; getAttributes(Object object) throws IllegalArgumentException &#123; FilterInvocation filterInvocation = (FilterInvocation) object; for (String url : resourceMap.keySet()) &#123; RequestMatcher requestMatcher = new AntPathRequestMatcher(url); HttpServletRequest httpRequest = filterInvocation.getHttpRequest(); if (requestMatcher.matches(httpRequest)) &#123; return resourceMap.get(url); &#125; &#125; return null; &#125; @Override public boolean supports(Class&lt;?&gt; arg0) &#123; return true; &#125;&#125; 现在我们拿到了用户的角色，也拿到了系统里有的角色和权限，就需要判断他是否有这个权限了，配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * Created by YangFan on 2016/11/28 下午12:19. * &lt;p/&gt; * AccessdecisionManager在Spring security中是很重要的。 * &lt;p&gt; * 在验证部分简略提过了，所有的Authentication实现需要保存在一个GrantedAuthority对象数组中。 * 这就是赋予给主体的权限。 GrantedAuthority对象通过AuthenticationManager * 保存到 Authentication对象里，然后从AccessDecisionManager读出来，进行授权判断。 * &lt;p&gt; * Spring Security提供了一些拦截器，来控制对安全对象的访问权限，例如方法调用或web请求。 * 一个是否允许执行调用的预调用决定，是由AccessDecisionManager实现的。 * 这个 AccessDecisionManager 被AbstractSecurityInterceptor调用， * 它用来作最终访问控制的决定。 这个AccessDecisionManager接口包含三个方法： * &lt;p&gt; * void decide(Authentication authentication, Object secureObject, * List&lt;ConfigAttributeDefinition&gt; config) throws AccessDeniedException; * boolean supports(ConfigAttribute attribute); * boolean supports(Class clazz); * &lt;p&gt; * 从第一个方法可以看出来，AccessDecisionManager使用方法参数传递所有信息，这好像在认证评估时进行决定。 * 特别是，在真实的安全方法期望调用的时候，传递安全Object启用那些参数。 * 比如，让我们假设安全对象是一个MethodInvocation。 * 很容易为任何Customer参数查询MethodInvocation， * 然后在AccessDecisionManager里实现一些有序的安全逻辑，来确认主体是否允许在那个客户上操作。 * 如果访问被拒绝，实现将抛出一个AccessDeniedException异常。 * &lt;p&gt; * 这个 supports(ConfigAttribute) 方法在启动的时候被 * AbstractSecurityInterceptor调用，来决定AccessDecisionManager * 是否可以执行传递ConfigAttribute。 * supports(Class)方法被安全拦截器实现调用， * 包含安全拦截器将显示的AccessDecisionManager支持安全对象的类型。 */@Componentpublic class DemoAccessDecisionManager implements AccessDecisionManager &#123; public void decide(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes) throws AccessDeniedException, InsufficientAuthenticationException &#123; if (configAttributes == null) &#123; return; &#125; for (ConfigAttribute ca : configAttributes) &#123; String needRole = ca.getAttribute(); //ga 为用户所被赋予的权限。 needRole 为访问相应的资源应该具有的权限。 for (GrantedAuthority ga : authentication.getAuthorities()) &#123; if (needRole.trim().equals(ga.getAuthority().trim())) &#123; return; &#125; &#125; &#125; throw new AccessDeniedException("没有权限进行操作！"); &#125; public boolean supports(ConfigAttribute attribute) &#123; return true; &#125; public boolean supports(Class&lt;?&gt; clazz) &#123; return true; &#125;&#125; 我们试试登录的接口： 然后我们用这个token来调用另外一个接口。我们先试试不传Token会返回什么 判断没有登录，现在再来试试带上token的请求。已经成功的请求到了数据。 好了，核心配置就是这些，我把这些代码上传github上，有需要的可以下载下来看看。里面的角色和权限都是虚拟数据，应用还需要自行修改代码。https://github.com/sail-y/spring-boot-jwt]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程5-基础构建模块]]></title>
    <url>%2F2016%2F12%2F08%2Fconcurrency5%2F</url>
    <content type="text"><![CDATA[基础构建模块第4章介绍了构造线程安全类时采用的一些技术，例如将线程安全性委托给现有的线程安全类。委托是创建线程安全类的一个最有效的策略：只需让现有的线程安全类管理所有的状态即可。下面将介绍一些JDK提供的工具类。 同步容器类同步容器类包括Vector和Hashtable。这些类实现线程安全的方式是：将它们的状态封装起来，并对每个共有方法都进行同步，使得每次只有一个线程能访问容器的状态。 同步容器类的问题同步容器类都是线程安全的，但在某些情况下需要加锁来保护复合操作。例如2个线程都在进行「若没有，则添加」的运算，如果没有对这个复合操作加锁，就可能会出问题。 迭代器与ConcurrentModificationException无论是迭代还是foreach循环，当它们发现容器在迭代过程中被修改时，就会抛出ConcurrentModificationException异常。如果不希望在迭代期间对容器加锁，有一种替代方法就是「克隆」容器，并在副本中进行迭代。 隐藏迭代器虽然加锁可以防止迭代器抛出ConcurrentModificationException，但是必须在所有对共享容器进行迭代的地方都需要加锁。还有一个很隐蔽的迭代器，就是没有显式的迭代器，但是实际上也执行了迭代操作，那就是编译器会将字符串的连接操作转化为StringBuilder.append，而这个方法会调用容器的toString方法，标准容器的toString方法会迭代容器。12Set&lt;Integer&gt; set = new HashSet&lt;&gt;();System.out.println(set); 如果在输出期间对容器进行了修改，就会抛出异常。 并发容器JDK5提供了多种并发容器类来改进同步容器的性能。因为同步容器对所有容器状态的访问都串行化，降低了并发性，性能不太好。通过并发容器来代替同步容器，可以极大的提高伸缩性并降低防线。例如ConcurentHashMap和CopyOnWriteArrayList。BlockingQueue提供可阻塞的插入和获取操作。如果队列为空，那么获取元素的操作将一直阻塞，直到队列中出现一个可用的元素。如果队列已满，那么插入元素的操作将一直阻塞，直到队列中出现可用的空间。 ConcurrentHashMap同步容器类在执行每个操作期间都持有一个锁，HashMap的键值对是通过单向链表来实现的，当遍历很长的链表并且在某些或者全部元素上调用equals方法时，会耗费很长时间，而其他线程在这段时间内都不能访问该容器。ConcurrentHashMap与HashMap一样也是一个基于散列的Map，它使用了一种分段锁的机制来实现更大程度的共享，而不是将每个方法都进行同步。这样执行写入操作的线程可以并发地访问Map。它提供的迭代器也不会抛出ConcurrentModificationException，因此不需要在迭代的时候加锁。 ConcurrentHashMap将一些常见的复合操作实现为了原子操作，例如putIfAbsent,remove,replace等。 CopyOnWriteArrayListCopyOnWriteArrayList用于替代同步List，在某些情况下它提供了更好的并发性能，并且在迭代期间不需要对容器进行加锁或复制。CopyOnWriteArrayList底层用基础数组实现，不会被修改，可以随意并发的访问。不过显然每当修改容器的时候会复制底层数组，这会造成一定的开销。仅当迭代操作远远多余修改操作时，才应该使用这个容器。这个容器适用于许多事件通知系统：分发通知时迭代监听器，并调用。而注册或者注销监听器的操作则较少。 阻塞队列和生产者-消费者模式刚才提到BlockingQueue提供可阻塞的put和take操作。阻塞队列支持生产者-消费者这种设计模式。该模式将「找出需要完成的工作」与「执行工作」这两个过程分离开来，并把工作放入一个「待完成」的列表以便在随后处理。在基于阻塞队列构建的生产者-消费者设计中，当数据生成时，生产者把数据放入队列，而当消费者准备处理数据时，将从队列中获取数据。 12345678910111213141516171819202122232425262728293031323334353637public class BlockingQueueTest &#123; public static void main(String[] args) &#123; final BlockingQueue&lt;String&gt; bq = new ArrayBlockingQueue&lt;String&gt;(10); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; &#123; int i = 0; while (true) &#123; System.out.println("produce " + i++); try &#123; bq.put(i + ""); TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); executorService.execute(() -&gt; &#123; while (true) &#123; try &#123; String take = bq.take(); System.out.println("take " + take); TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); executorService.shutdown(); &#125;&#125; 但需要注意的是我们应该用有界队列，因此如果消费者处理速度较慢，队列可能会将耗尽内存。在构建高可靠的应用程序时，有界队列是一种强大的资源管理工具：它们能抑制并防止产生过多的工作项，使应用程序在负荷过载的情况秀爱变得更加健壮。 串行线程封闭对于可变对象，生产者-消费者这种设计与阻塞队列一起，促进了串行线程封闭，从而将对象所有权从生产者缴费给消费者。线程封闭对象只能由单个线程拥有，但可以通过安全地发布该对象来「转移」所有权。 双端队列JDK6还增加了两种容器类型，Deque和BlockingDeque。Deque是一个双端队列，实现了在队列头和队列尾的高效插入和移除。具体实现包括ArrayDeque和LinkedBlockingDeque。 阻塞方法与中断方法线程可能会阻塞或者暂停执行，等待I/O操作，等待锁等。简单举例就是Thread.sleep()。当某方法会抛出InterruptedException时，表示该方法是一个阻塞方法，如果这个方法被中断，那么它将努力提前结束阻塞状态。Thread提供了interrupt方法，用于中断线程或者查询线程是否已经被中断。每个线程都有一个布尔类型的属性，表示线程的中断状态，当中断线程时将设置这个值。我们看源码就知道，interrupt()只是将interrupt的标记设置一下而已，interrupt0()是一个native方法。具体什么时候中断，JDK并不保证。 1234567891011121314public void interrupt() &#123; if (this != Thread.currentThread()) checkAccess(); synchronized (blockerLock) &#123; Interruptible b = blocker; if (b != null) &#123; interrupt0(); // Just to set the interrupt flag b.interrupt(this); return; &#125; &#125; interrupt0(); &#125; 看个例子： 1234567891011121314151617/** * Created by YangFan on 2016/10/26 下午4:17. * &lt;p/&gt; * 中断机制是一种协作机制，也就是说通过中断并不能直接终止另一个线程，而需要被中断的线程自己处理。 */public class InterruptTest &#123; public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; &#123; while (!Thread.currentThread().isInterrupted()) &#123; System.out.println("running"); &#125; &#125;); executorService.shutdownNow(); &#125;&#125; 同步工具类下面介绍一些并发包的同步工具类，它们封装了一些状态，这些状态将决定执行同步工具类的线程是继续执行还是等待，此外还提供了一些方法对状态进行操作，以及另一些方法用于高效地等待同步工具类进入到预期状态，这些类有CountDownLatch、Semaphore和Barrier等。 CountDownLatchLatch可以延迟线程的进度直到其到达终止状态。它的作用相当于一扇门：在条件达到之前，这扇门是关闭着的，并没有任何线程能通过，直到条件到达结束状态时，这扇门打开并允许所有线程通过。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * Created by YangFan on 2016/10/26 下午5:10. * &lt;p/&gt; * CountDownLatch主要提供的机制是当多个（具体数量等于初始化CountDownLatch时count参数的值）线程都达到了预期状态或完成预期工作时触发事件， * 其他线程可以等待这个事件来触发自己的后续工作。值得注意的是，CountDownLatch是可以唤醒多个等待的线程的。 */public class CountDownLatchTest &#123; private static class WorkThread extends Thread &#123; private CountDownLatch countDownLatch; private int sleepSecond; public WorkThread(String name, CountDownLatch countDownLatch, int sleepSecond) &#123; super(name); this.countDownLatch = countDownLatch; this.sleepSecond = sleepSecond; &#125; @Override public void run() &#123; try &#123; System.out.println(this.getName() + " start: " + LocalDateTime.now()); TimeUnit.SECONDS.sleep(sleepSecond); countDownLatch.countDown(); System.out.println(this.getName() + " end: " + LocalDateTime.now()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private static class DoneThread extends Thread &#123; private CountDownLatch countDownLatch; public DoneThread(String name, CountDownLatch countDownLatch) &#123; super(name); this.countDownLatch = countDownLatch; &#125; @Override public void run() &#123; try &#123; System.out.println(this.getName() + " await start:" + LocalDateTime.now()); countDownLatch.await(); System.out.println(this.getName() + " await end:" + LocalDateTime.now()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; // CountDownLatch指定3次调用，无论前面有多少线程await，都需要等待CountDownLatch调用3次countDown()统一唤醒 public static void main(String[] args) &#123; CountDownLatch countDownLatch = new CountDownLatch(3); DoneThread d0 = new DoneThread("DoneThread1", countDownLatch); DoneThread d1 = new DoneThread("DoneThread2", countDownLatch); d0.start(); d1.start(); WorkThread w0 = new WorkThread("WorkThread0", countDownLatch, 2); WorkThread w1 = new WorkThread("WorkThread1", countDownLatch, 3); WorkThread w2 = new WorkThread("WorkThread2", countDownLatch, 4); w0.start(); w1.start(); w2.start(); &#125;&#125; FutureTaskFutureTask可以获得线程返回的结果，get方法取决于线程的状态，如果已经完成会直接返回，否则会一直阻塞直到任务执行完成。 12345678910111213141516171819202122232425/** * Created by YangFan on 2016/10/26 下午5:54. * &lt;p/&gt; */class CallableThread implements Callable &#123; @Override public Object call() throws Exception &#123; System.out.println("call()"); TimeUnit.MILLISECONDS.sleep(1500); return "123"; &#125;&#125;public class CallableTest &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; ExecutorService executorService = Executors.newCachedThreadPool(); Future future = executorService.submit(new CallableThread()); executorService.shutdown(); System.out.println(future.get());// while (!future.isDone()) &#123;// System.out.println(future.get());// &#125; &#125;&#125; SemaphoreSemaphore用来控制同时访问某个特定资源的操作数量，或者同事执行某个指定操作的数量。Semaphore还可以用来实现某种资源池，或者对容器施加边界。Semaphore管理着一组虚拟的许可，许可的初始数量可通过构造函数来指定，在执行操作时可以先获得许可，并在使用后释放许可。如果没有许可，那么acquire()将阻塞直到有许可。 123456789101112131415161718192021222324252627/** * Created by YangFan on 2016/10/26 下午5:23. * &lt;p/&gt; * */public class SemaphoreTest &#123; public static void main(String[] args) &#123; final Semaphore semaphore = new Semaphore(5); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 10; i++) &#123; executorService.execute(() -&gt; &#123; try &#123; semaphore.acquire(); System.out.println(Thread.currentThread().getName() + " acquire: " + LocalDateTime.now()); TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; semaphore.release(); System.out.println(Thread.currentThread().getName() + " release: " + LocalDateTime.now()); &#125; &#125;); &#125; &#125;&#125; CyclicBarrierCountDownLatch是一次性对象，一旦结束进入终止状态，就不能被重置。CyclicBarrier能阻塞一组线程直到某个事件发生。CyclicBarrier和CountDownLatch的关键区别在于，所有线程必须同时达到CyclicBarrier的条件，才能继续执行。CountDownLatch是等待某个条件或者事件，CyclicBarrier是等待其他线程。例如CountDownLatch是指6点一到大家就可以下班了，而CyclicBarrier是要等大家到齐了才能开会。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * Created by YangFan on 2016/10/26 下午5:43. * &lt;p/&gt; * CyclicBarrier从字面理解是指循环屏障，它可以协同多个线程，让多个线程在这个屏障前等待，直到所有线程都达到了这个屏障时，再一起继续执行后面的动作。 * */class CyclicBarrierThread implements Runnable &#123; private CyclicBarrier cyclicBarrier; private int sleepSecond; public CyclicBarrierThread(CyclicBarrier cyclicBarrier, int sleepSecond) &#123; this.cyclicBarrier = cyclicBarrier; this.sleepSecond = sleepSecond; &#125; @Override public void run() &#123; try &#123; System.out.println(Thread.currentThread().getName() + " running"); TimeUnit.SECONDS.sleep(sleepSecond); System.out.println(Thread.currentThread().getName() + " waiting " + LocalDateTime.now()); cyclicBarrier.await(); System.out.println(Thread.currentThread().getName() + " end wait " + LocalDateTime.now()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125;&#125;/*CountDownLatch和CyclicBarrier都是用于多个线程间的协调的，它们二者的几个差别是：1、CountDownLatch是在多个线程都进行了latch.countDown()后才会触发事件，唤醒await()在latch上的线程，而执行countDown()的线程，执行完countDown()后会继续自己线程的工作；CyclicBarrier是一个栅栏，用于同步所有调用await()方法的线程，并且等所有线程都到了await()方法时，这些线程才一起返回继续各自的工作2、另外CountDownLatch和CyclicBarrier的一个差别是，CountDownLatch不能循环使用，计数器减为0就减为0了，不能被重置，CyclicBarrier可以循环使用3、CountDownLatch可以唤起多条线程的任务，CyclicBarrier只能唤起一条线程的任务注意，因为使用CyclicBarrier的线程都会阻塞在await方法上，所以在线程池中使用CyclicBarrier时要特别小心，如果线程池的线程过少，那么就会发生死锁了 */public class CyclicBarrierTest &#123; public static void main(String[] args) &#123; Runnable command = () -&gt; System.out.println("I'm coming"); CyclicBarrier cyclicBarrier = new CyclicBarrier(3, command); CyclicBarrierThread t1 = new CyclicBarrierThread(cyclicBarrier, 2); CyclicBarrierThread t0 = new CyclicBarrierThread(cyclicBarrier, 2); CyclicBarrierThread t2 = new CyclicBarrierThread(cyclicBarrier, 1); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(t1); executorService.execute(t0); executorService.execute(t2); executorService.shutdown(); &#125;&#125; 总结 可变状态是至关重要的 所有的并发问题都可以归结为如何协调对并发状态的访问。可变状态越少，就越容易保证线程安全性 尽量将域声明为final类型，除非需要它们是可变的。 不可变对象一定是线程安全的 不可变对象能极大地降低并发编程的复杂性。它们更简单而且安全，可以任意共享而无须使用加锁或保护性复制等机制。 封装有助于管理复杂性。 在编写线程安全的程序时，虽然可以将所有数据都保存在全局变量中，但为什么要这样做？将数据封装在对象中，更易于维持不变性条件：将同步机制封装在对象中，更易于遵循同步策略。 用锁来保护每个可变变量。 当保护同一个不变性中的所有变量时，要使用同一个锁。 在执行复合操作期间，要持有锁。 如果从多个线程中访问同一个可变变量时没有同步机制，那么程序就会出现问题。 不要故作聪明地推断出不需要使用同步。 在设计过程中考虑线程安全，或者在文档中明确地指出它不是线程安全的。 将同步策略文档化。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程4-对象的组合]]></title>
    <url>%2F2016%2F12%2F06%2Fconcurrency4%2F</url>
    <content type="text"><![CDATA[对象的组合本章将介绍一些组合模式，这些模式能够使一个类更容易成为线程安全的，并且在维护这些类时不会无意中破坏类的安全性保证。 设计线程安全的类在设计线程安全类的过程中，需要包含以下三个基本要素： 找出构成对象状态的所以变量 找出约束状态变量的不变性条件 建立对象状态的并发访问管理策略 收集同步需求要确保的类的线程安全性，就需要确保它的不变性条件不会在并发访问的情况下被破坏，这就需要对其状态进行推断。不变性条件是指变量的取值范围约束，后验条件是指状态改变的时候值是否合法。如果不了解对象的不变性条件与后验条件，那么就不能确保线程安全性。要满足在状态变量的有效值或状态转换上的各种约束条件，就需要借助于原子性与封装性。 依赖状态的操作先验条件是基于前一个状态的操作，例如不能从空队列中移除一个元素，这个被称为依赖状态的操作。在单线程程序中，如果某个操作无法满足先验条件，那么就只能失败。但在并发程序中先验条件可能会由于其他线程执行的操作而变成真。在并发程序中要一只等到先验条件威震，然后再执行操作。后面将会介绍JDK提供的BlockingQueue和Semaphore等同步工具类来实现依赖状态的行为。 状态的所有权许多情况下，所有权与封装性总是相互关联的：对象封装它拥有的状态，反之也城里，即对它封装的状态拥有所有权。 实例封闭如果某对象不是线程安全的，那么可以通过多种技术使其在多线程程序中安全地使用。你可以确保该对象只能由单个线程访问（线程封闭），或者通过一个锁来保护该对象的所有访问。将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。封闭机制更易于构造线程安全的类，因为当封闭类的状态时，在分析类的线程安全性时就无须检查整个程序。 Java监视器模式从线程封闭原则及其逻辑推论可以得出Java监视器模式。遵循Java监视器模式的对象会把对象的所有可变状态都封装起来，并由对象自己的内置锁来保护。意思就是对象的属性全部通过同步的方法来访问或者修改。 12345678910public class PrivateLock &#123; private final Object myLock = new Object(); Widget widget; void someMethod() &#123; synchronized(myLock) &#123; // 访问或修改Widget的状态 &#125; &#125;&#125; 使用私有的锁对象而不是对象的内置锁，有许多优点。私有锁对象可以将锁封装起来，使客户代码无法得到锁，但客户代码可以通过共有方法来访问锁，以便参与到它的同步策略中。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程3-对象的共享]]></title>
    <url>%2F2016%2F12%2F05%2Fconcurrency3%2F</url>
    <content type="text"><![CDATA[对象的共享要编写正确的并发程序，管关键问题在于：在访问共享的可变状态时需要进行正确的管理。本章介绍如何共享和发布对象，从而使它们能够安全地由多个线程同时访问。 可见性「可见性」是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量做不到这一点，普通变量的值在线程间传递均需要通过主内存来完成，例如线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再从主内存进行读取操作，新变量值才会对线程B可见。Java内存模型的有序性可以总结为一句话，如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指「线程内表现为串行的语义」，后半句是指「指令重排序」现象和「工作内存与主内存同步延迟」现象。Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由”一个变量在同一时刻只允许一条线程对其进行lock操作”这条规则获得的，这条规则规定了持有同一个锁的两个同步块只能串行地进入。 123456789101112131415161718public class NoVisibility &#123; private static boolean ready; private static int number; private static class ReaderThread extends Thread &#123; public void run() &#123; while (!ready) Thread.yield(); System.out.println(number); &#125; &#125; public static void main(String[] args) &#123; new ReaderThread().start(); number = 42; ready = true; &#125;&#125; 上面这个例子可能是一个死循环，因为ReaderThread线程可能永远看不到ready的值变化（可见性问题）。还有另外一种情况就是输出了0，因为指令重排序优化的原因，ready = true可能会先于number=42执行。 指令重排序优化是指为了使得处理内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行优化，处理器会再计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，因此如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。 失效数据NoVisibility展示了在缺乏同步的程序中可能产生错误结果中的一种情况：失效数据。除非在每次访问变量的时候使用同步。 非原子的64位操作因为double和long是64位数据，内存模型允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32为的操作来进行。如果有多个线程共享一个并未声明为volatile的long或double类型的变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读取到一个既非原值，也不是其他线程修改的值代表了「半个变量」的数值。不过这很罕见，因为目前的商用虚拟机几乎都还是选择把64位数据的读写作为原子操作来对待，所以我们写代码一般也不需要对long和double变量专门声明为volatile。 加锁与可见性synchronized和final关键字能实现可见性，synchronized的可见性是由「对一个变量执行unlock操作之前，必须先把此变量同步回主内存中」这条规则获得的。另外，final关键字也可以实现可见性，因为被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把this传递出去，那在其他线程中就能看见final字段的值。 加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。 Volatile变量Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介来实现可见性的，无论是普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是，volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此，可以说volatile保证了多线程时操作变量的可见性，而普通变量则不能保证这一点。volatile变量通常用做某个操作完成、发生中断或者状态的标志。 注意：加锁机制即可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。 当且仅当满足以下所有条件时，才应该使用volatile变量： 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。 该变量不会与其他状态变量一起纳入不变性条件中 这种访问变量时不需要加锁 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Created by YangFan on 2016/10/25 上午10:37. * &lt;p/&gt; */class VThread_0 implements Runnable &#123; @Override public void run() &#123; while (VolatileTest.isRunning) &#123; &#125; &#125;&#125;class VThread_1 implements Runnable &#123; @Override public void run() &#123; VolatileTest.isRunning = false; System.out.println("stop running"); &#125;&#125;public class VolatileTest &#123; public static boolean isRunning = true; /* 这个不是必现，得多试几次 stop running 后死循环 在第二个线程更改后，第一个线程并没有马上停止，原因从Java内存模型（JMM）说起。 根据JMM，Java中有一块主内存，不同的线程有自己的工作内存，同一个变量值在主内存中有一份，如果线程用到了这个变量的话，自己的工作内存中有一份一模一样的拷贝。 每次进入线程从主内存中拿到变量值，每次执行完线程将变量从工作内存同步回主内存中。 出现打印结果现象的原因就是主内存和工作内存中数据的不同步造成的。 */ // 线程安全围绕的是可见性和原子性这两个特性展开的，volatile解决的是变量在多个线程之间的可见性，但是无法保证原子性。 public static void main(String[] args) throws InterruptedException &#123; VThread_0 vThread_0 = new VThread_0(); VThread_1 vThread_1 = new VThread_1(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(vThread_0); executorService.execute(vThread_1); executorService.shutdown(); &#125;&#125; 发布与逸出「发布」的意思是使对象能够在当前作用于之外的代码中使用，当某个不应该发布的对象被发布时，这种情况就被称为「逸出」。 123456789private Set&lt;Secret&gt; knownSecrets;public void initialize() &#123; knownSecrets = new HashSet&lt;&gt;();&#125;public Set&lt;Secret&gt; getKnownSecrets() &#123; return knownSecrets;&#125; 上面的代码发布了HashSet对象，但是却导致knownSecrets里的Secret逸出了，因为任何调用者都能修改knownSecrets里的值。 线程封闭当访问共享的可变数据时，通常需要使用同步，一种避免使用同步的方式就是不共享数据，如果仅在单线程内访问数据时，就不需要同步，这种技术被称为线程封闭。Java提供了ThreadLocal类来帮助维持线程封闭性。 不变性不可变对象一定是线程安全的，当满足以下条件时，对象才是不可变的： 对象创建以后其状态就不能修改。 对象的所有域都是final类型。 对象是正确创建的（在对象的创建期间，this对象没有逸出） 安全发布的常用模式要安全的地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过一下方式来安全地发布： 在静态初始化函数中初始化一个对象引用。 将对象的引用保存到volatile类型的域或者AtomicReferance对象中。 将对象的引用保存到某个正确构造对象的final类型域中。 将对象的引用保存到一个由锁保护的域中。 如果对象从技术上来看是可变的，但其状态在发布后不会在再改变，那么把这种对象称为「事实不可变对象」，在没有额外的同步情况下，任何线程都可以安全地使用被安全发布的事实不可变对象。 对象的发布需求取决于它的可变性： 不可变对象可以通过任意机制来发布。 事实不可变对象必须通过安全方式来发布。 可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来。 在并发程序中使用和共享对象时，可以使用一些实用的策略，包括： 线程封闭：线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。 只读共享：在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。 线程安全共享：线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。 保护对象：被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程2-线程安全性]]></title>
    <url>%2F2016%2F12%2F02%2Fconcurrency2%2F</url>
    <content type="text"><![CDATA[线程安全性在构建文件的并发程序时，必须正确地使用线程和锁，但这些终归只是一些机制。要编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是对共享的和可变的状态的访问。一个对象是否是线程安全的，取决于它是否被多个线程同事访问。当多个线程访问某个状态变量并且其中有一个线程执行写入操作时，必须采用同步机制来协同这些线程对变量的访问。Java中的主要同步机制是关键字synchronized，它提供了一种独占的枷锁方式，但「同步」这个术语还包括volatile类型的变量，显式锁以及原子变量。如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会初夏你错误。有三种方式可以修复这个问题： 不在线程之间共享该状态变量 将状态变量改为不可变的变量 在访问状态变量时使用同步 什么是线程安全性当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。在线程安全类中封装了必要的同步机制，因此客户端无须进一步采取同步措施。无状态对象一定是线程安全的。（没有共享数据） 原子性像count++这种是属于非原子操作，它包含了三个独立的操作：读取count的值，将值+1，然后将计算结果写入count。所以不同线程在自增的时候，这个值在第一步拿到的可能是过期的数据。在并发编程中，这种由于不恰当的执行时序出现不正确的结果是一种非常重要的情况，它有一个正式的名字：竞态条件。 竞态条件当某个计算的正确性取决于多个线程的交替执行时序时，那么就会发生竞态条件。最常见的竞态条件就是「先检查后执行」，通过一个可能失效的观测结果来决定下一步的动作。 复合操作要避免竞态条件问题，就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或之后读取和修改状态，而不是在修改状态的过程中。 我们将先检查后执行和读取-修改-写入等操作统称为「复合操作」。我们要以原子方式执行确保线程安全性，Java通过加锁机制来确保原子性。原子操作是指，对于访问同一个状态的所有操作（包括该操作本身）来说，这个操作是一个以原子方式执行的操作（不可分割的操作）。 加锁机制要保持状态的一致性，就需要在某个原子性操作中更新所有相关状态变量。 内置锁Java提供了一种内置的锁机制来支持原子性：同步代码快。以关键字synchronized来修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的所就是方法调用的所在对象。静态的synchronized方法以Class对象作为锁。 123synchronized (lock) &#123; //访问或修改由锁保护的共享状态&#125; 每个Java对象都可以用做一个实现同步的锁，这些锁被称为内置锁或监视器锁。线程在进入同步代码之前会自动获得锁，并且在退出同步代码块时自动释放锁，而无论是通过正常的控制路径退出，还是通过代码块中抛出异常退出。获得内置锁的唯一途径就是进入由这个锁保护的同步代码块或方法。Java的内置锁是互斥锁，意思是最多只有一个线程能持有这种锁，当线程A尝试获取一个由线程B持有的锁时，线程A必须等待或阻塞，直到线程B释放这个锁。如果B永远不释放这个锁，那么A也将永远地等下去。由于每次只能又一个线程执行内置锁保护的代码块，因此，由这个锁保护的同步代码块会以原子方式执行，多个线程在执行该代码块时也不会相互干扰。并发环境中的原子性与事务应用程序的原子性有着相同的含义–一组语句作为一个不可分割的单元被执行。任何一个执行同步代码块的线程，都不可能看到有其他线程正在执行由同一个锁保护的同步代码块。 重入当某线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞。然而，由于内置锁是可重入的，因此如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。synchronized同步块对同一条线程来说是可重入的，不会出现把自己锁死的问题。 synchronized关键字在经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令。根据虚拟机规范的要求，在执行monitorenter指令时，首先要尝试获取对象的锁，如果这个对象没有被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。 用锁来保护状态由于锁能使其保护的代码路径以串行形式来访问，因此可以通过锁来构造一些协议以实现对共享状态的独占访问。对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的。并非所有数据都需要锁的保护，只有被多个线程同时访问的可变数据才需要通过锁来保护。虽然synchronized方法可以确保单个操作的原子性，但如果把多个操作合并为一个复合操作，还是需要额外的加锁机制。 活跃性与性能一般来讲，对整个方法进行同步，每次只有一个线程可以执行，可能会导致性能糟糕。因此我们通常在只需要同步的地方用同步代码块，只对代码块中的共享状态变量进行加锁保护。我们要找到简单性（对整个方法进行同步）与并发性（对尽可能短的代码进行同步）之间的平衡。 通常，在简单行与性能之间存在着相互制约因素。当实现某个同步策略时，已定不要盲目地为了性能而牺牲简单行（这可能会破坏安全性）。 当执行时间较长的计算或者可能无法快速完成的操作时（例如：网络I/O或控制台I/O），一定不要持有锁。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程1-介绍]]></title>
    <url>%2F2016%2F12%2F01%2Fconcurrency1%2F</url>
    <content type="text"><![CDATA[在看完了《深入理解Java虚拟机》之后，继续看《Java并发编程实战一书》。相信在了解虚拟机之后，再来看并发相关知识，能理解得更透彻，书中也讲到，对Java内存模型理解得越深入，就对并发编程掌握得越好。顺道说一下，关于JDK里线程和并发相关类的使用，我主要是通过《Think in Java》学习的，这里就不再介绍基本使用方法了。 简介线程也被称为轻量级进程（这一部分在《深入理解Java虚拟机》中提到过，点击查看）。在大多数现代操作系统中， 都是以线程为基本的调度单位，而不是进程。 线程的优势要想充分发挥多处理器系统的强大计算能力，线程可以有效的降低程序的开发和维护成本，同时提升复杂应用程序的性能。 发挥多处理器的强大能力现在，多处理系统日益普及，个人PC基本上也都是多个处理器了。由于基本的调度单位是线程，因此如果程序中只有一个线程，那么最多只能在一个处理器上运行。在双处理器系统上，单线程的程序只能使用一半的CPU资源，而在拥有100个处理器的系统上将有99%的资源无法使用。多线程程序可以同时在多个处理器上执行，如果设计正确，多线程程序可以通过提高处理器资源的利用率来提升系统吞吐率。 建模的简单性通过使用线程，可以将复杂并且异步的工作流进一步分解为一组简单并且同步的工作流，每个工作流在一个单独的线程中运行，并在特定的同步位置进行交互。例如Servlet，框架负责解决请求管理、线程创建、负载平衡等细节，在正确的时刻将请求分发给正确的应用组建。我们开发的时候的就像在开发单线程程序一样，可以简化组件的开发。 异步事件的简化处理服务器应用程序在接受来自多个远程客户端的请求时，如果为每个连接都分配其各自的线程并且使用同步I/O，那么就会降低这类程序的开发难度。如果某个应用程序请求数据花费时间较长或者阻塞了，在单线程应用程序在阻塞期间所有的请求都会停顿，为了避免这个问题，单线程服务器应用程序必须使用非阻塞I/O，这种I/O的复杂性太远远高于同步I/O，并且很容易出错。然而，如果每个请求都拥有自己的处理线程，那么在处理某个请求时发生的阻塞将不会影响其他请求的处理。 响应更灵敏的用户界面将GUI应用的各种事件放入单独的线程中运行，时间线程能及时地处理界面事件，从而使用户界面具有更高的灵敏度。 线程带来的风险Java对线程的支持其实是一把双刃剑。虽然Java提供了相应的语言和库，以及一种明确的跨平台内存模型，这些工具简化了并发应用程序的开发，但同时也提高了对开发人员的技术要求。 安全性问题线程的安全性是非常复杂的，在没有充足同步的情况下，多个线程的操作执行顺序是不可预测的。由于多个线程要共享相同的内存地址空间，并且是并发运行，因此它们可能会访问或修改其他线程正在使用的变量，要使多线程程序的行为可以预测，必须对共享变量的访问操作进行协同，在Java中提供了各种同步机制来协同这种访问。 活跃性问题当某个操作无法继续执行下去时，就会发生活跃性问题。在串行程序中，活跃性问题的形式之一就是无意中造成的无限循环，从而使循环之后的代码无法得到执行。线程也会带来一些其他活跃性问题，例如死锁，饥饿，以及活锁。 性能问题活跃性意味着某件正确的事情始终会发生，但却不够好。线程带来性能问题就是线程调度带来的开销，还有线程使用共享数据必须使用同步机制，同步机制往往也会抑制编译器做某些优化等问题。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM12-线程安全与锁优化]]></title>
    <url>%2F2016%2F11%2F25%2FJVM12%2F</url>
    <content type="text"><![CDATA[线程安全当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。 Java语言中的线程安全讨论线程安全，就限定于多个线程之间存在共享数据访问这个前提，因为如果一段代码根本不会与其他线程共享数据，那么从线程安全的角度来看，程序是串行执行还是多线程执行对它来说是完全没有区别的。我们将Java语言中各种操作共享的数据分为以下5类：不可变、绝对线程安全、相对线程安全、线程兼容和线程独立。 不可变 在Java语言中，不可变的对象一定是线程安全的。基本数据类型采用final关键字修饰，如果是对象则需要保证自己的行为不会影响状态，例如String的replace()等方法都是产生新的对象。 绝对线程安全 绝对的线程安全就是前面的提到的定义，这个定义很严格，一个类要达到「不管运行时环境如何，调用者都不需要任何额外的同步措施」通常需要付出很大的，甚至有时候是不切实际的代价。在Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全。 相对线程安全 相对的线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外保障措施。在Java语言中，大部分的线程安全类都属于这种类型，例如Vector、HashTable等。 线程兼容 线程兼容是指对象本身并不是线程安全的，但是可以通过调用端正确地使用同步手段来保证对象在并发环境中可以安全的使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。 线程对立 线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。一个线程对立的例子是Thread类的suspend()和resume()方法，如果并发进行的话，无论调用时是否进行了同步，目标线程都是存在死锁风险的，如果suspend()中断的线程就是即将要执行resume()的那个线程，那肯定就要产生死锁了。 线程安全的实现方法 互斥同步 互斥同步（Mutual Exclusion &amp; Synchronization）是常见的一种并发正确性保证手段。同步是指在多个线程并发访问共享数据时，保证共享数据在同一时刻只能被一个（或者是一些，使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区（Critial Section）、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方式。因此，在这四个字里面，互斥是因，同步是果；互斥是方法，同步是目的。 在Java中，最基本的互斥同步手段就是synchronized关键字，synchronized关键字在经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令。 根据虚拟机规范的要求，在执行monitorenter指令时，首先要尝试获取对象的锁，如果这个对象没有被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。 关于monitorenter和monitorexit，有两点是要特别注意的： synchronized同步块对同一条线程来说是可重入的，不会出现把自己锁死的问题 同步块在已进入的线程执行完之前，会阻塞后面其它线程的进入 因为Java的线程是映射到操作系统的原生线程之上的，如果要阻塞或者唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间，对于代码简单的同步块，状态转换消耗的时间有可能比用户代码执行的时间还长，所以synchronized是Java语言中一个重量级（Heavyweight）锁，有经验的程序员都会在确实必要的情况下才使用这种操作。除了synchronized，还有java.util.concurrent包中的ReentrantLock来实现同步。 非阻塞同步 互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。互斥同步属于一种悲观的并发策略。随着硬件指令集（CAS指令）的发展，我们还可以采用基于冲突检测的乐观并发策略：先操作，没有其他线程竞争，就成功了；如果有其他线程争用，产生了冲突，就再采取补偿措施。 AtomicInteger的incrementAndGet方法就是无限循环自增直到成功。 锁优化自旋锁与自适应自旋互斥同步，对性能影响最大的是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核状态完成，这些操作给系统的并发性能带来了很大的压力。同时，虚拟机开发团队也注意到很多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。如果物理机上有一个以上的处理器，能让两个或两个以上的线程同时并行执行，我们就可以让后面请求锁的那个线程”稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。 JDK1.4.2就已经引入了自旋锁，只不过默认是关闭的，在JDK1.6中就已经改为默认开启了。自旋不能代替阻塞，且先不说处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但是它是要占据处理器时间的，因此如果锁被占用的时间很短，自旋等待的效果就非常好；反之，如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性能上的浪费。因此自旋等待必须有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了，自旋次数的默认值是10，可以使用参数-XX:PreBlockSpin来更改。 在JDK1.6之后引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上自旋的时间以及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。另外如果对于某一个锁，自旋很少成功获得过，那么在以后要获得这个锁时将可能忽略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越准确。 锁消除锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的支持，如果判断在一段代码中，堆上所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然无需进行。 锁粗化原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小—-只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。 大部分情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。 轻量级锁偏向锁]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM11-Java内存模型与线程]]></title>
    <url>%2F2016%2F11%2F25%2FJVM11%2F</url>
    <content type="text"><![CDATA[「内存模型」可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。 Java内存模型Java虚拟机规范中试图定义一种Java内存模型来屏蔽掉各种硬件和操作系统内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。在此之前，主流程序语言（如C/C++等）直接使用物理硬件和操作系统的内存模型，因此，会由于不同平台上内存模型的差异，有可能导致程序在一套平台上并发完全正常，而在另外一台平台上并发访问却经常出错，因此在某些场景就必须针对不同的平台来编写程序。 主内存与工作内存Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量与Java变成中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然不存在竞争问题。 Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的私有工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。（这很好的诠释了volatile关键字的作用和原理） 内存间交互操作Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的 lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态 unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。 load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。 assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store（存储）：作用于工作内存的变量，它把工作内存中的一个变量的值传送到主内存中，以便随后的write操作使用。 write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。 如果要把变量从主内存复制到工作内存，那就要顺序执行read和load操作，如果要把变量从工作内存同步回主内存，就要顺序地执行store和write操作。Java内存模型规定了在执行上述8种基本操作时必须满足如下规则： 不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起了回写但主内存不接受的情况出现。 不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。 不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。 一个新的变量只能在主内存中“诞生”，不允许在工作内存中字节使用一个未被初始化（load或assign的变量），换句话说就是对一个变量实施use、store操作之前，必须先执行过了assign和load操作。 一个变量在同一时刻只允许一条线程对其进行lock，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。 如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。 这8种内存访问操作以及上述规则的限定，再加上下面讲的对volatile的一些特殊规定，就已经完全确定了Java程序中哪些内存访问操作在并发下是安全的。 对于volatile型变量的特殊规则关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制，我们需要正确的理解并使用它。 当一个变量定义为volatile之后，它将具备两种特性： 1.保证此变量对所有线程的可见性，这里的「可见性」是指当一条线程修改了这个变量的值，，新值对于其他线程来说是可以立即得知的。而普通变量做不到这一点，普通变量的值在线程间传递均需要通过主内存来完成，例如线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再从主内存进行读取操作，新变量值才会对线程B可见。Java里面的运算并非原子操作，导致volatile变量在并发下一样是不安全的，看一段例子： 123456789101112131415161718192021222324252627282930313233343536373839/** * Created by YangFan on 2016/11/25 上午11:05. * &lt;p/&gt; * volatile变量自增预算测试 */public class VolatileTest &#123; public static volatile int race = 0; public static void increase() &#123; race++; &#125; private static final int THREADS_COUNT = 20; public static void main(String[] args) &#123; Thread[] threads = new Thread[THREADS_COUNT]; for (int i = 0; i &lt; THREADS_COUNT; i++) &#123; threads[i] = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int j = 0; j &lt; 10000; j++) &#123; increase(); &#125; &#125; &#125;); threads[i].start(); &#125; // 等待所有累加线程都结束 while (Thread.activeCount() &gt; 1) &#123; Thread.yield(); &#125; System.out.println(race); &#125;&#125; 这个结果每次可能都不一样，因为“race++”在虚拟机内部被分解成了很多指令，不同线程在自增的时候，这个值拿到的可能是过期的数据。 由于volatile变量值能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁来保证原子性。 运算结果并不依赖变量的当前值，或者能确保只有单一的线程修改变量的值 变量不需要与其他的状态变量共同参与不变约束 下面的场景就很适用： 1234567891011volatile boolean shutdownRequested;public void shutdown() &#123; shutdownRequested = true;&#125;public void doWork() &#123; while(!shutdownRequested) &#123; // do stuff &#125;&#125; 2.使用volatile变量的第二个语义是禁止指令重排序优化，普通变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。我们通过一个例子来看看为何指令重排序会干扰程序的并发执行。 指令重排序优化是指为了使得处理内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行优化，处理器会再计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，因此如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。 12345678910111213141516171819Map condigOptions;char[] configText;// 此变量必须定义为volatilevolatile boolean initialized = false;// 假设以下代码在线程A中执行// 模拟读取信息配置，当读取完成后将initialized设置为true以通知其他线程配置可用configOptions = new HashMap();configText = readConfigFile(fileName);processConfigOptions(configText, configOptions);initialized = true;// 假设以下代码在线程B中执行// 等待initialized为true，代表线程A已经把配置信息初始化完成while (!initialized) &#123; sleep();&#125;// 使用线程A中初始化好的配置信息doSomethingWihtConfig(); 上面的代码如果有定义initialized变量时没有使用volatile修饰，就可能会由于指令重排序的优化，导致位于线程A中最后一句的代码“initialized = true;”被提前执行(重排序优化是机器级的优化操作，提前执行是说这句话对应的汇编代码被提前)，这样在线程B中的代码可能就会出错。 对于long和double型变量的特殊规则因为double和long是64位数据，内存模型允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32为的操作来进行，即允许虚拟机实现选择选择可以不保证64位数据类型的load、store、read和write这4个操作的原子性。 如果有多个线程共享一个并未声明为volatile的long或double类型的变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读取到一个既非原值，也不是其他线程修改的值代表了「半个变量」的数值。不过这很罕见，因为目前的商用虚拟机几乎都还是选择把64位数据的读写作为原子操作来对待，所以我们写代码一般也不需要对long和double变量专门声明为volatile。 原子性、可见性与有序性Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的。 原子性 由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write，我们大致可以认为基本数据类型的访问读写是具备原子性的（例外就是long和double的非原子性协定，不过也无须太在意这几乎不会发生的例外情况。） 如果还需要更大范围的原子性保证，Java内存模型还提供了lock和unlock操作，也就是synchronized关键字。 可见性 可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介来实现可见性的，无论是普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是，volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此，可以说volatile保证了多线程时操作变量的可见性，而普通变量则不能保证这一点。 synchronized和final关键字也能实现可见性，synchronized的可见性是由「对一个变量执行unlock操作之前，必须先把此变量同步回主内存中」这条规则获得的。另外，final关键字也可以实现可见性，因为被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把this传递出去，那在其他线程中就能看见final字段的值。 有序性 Java内存模型的有序性可以总结为一句话，如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指「线程内表现为串行的语义」，后半句是指「指令重排序」现象和「工作内存与主内存同步延迟」现象。 Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由”一个变量在同一时刻只允许一条线程对其进行lock操作”这条规则获得的，这条规则规定了持有同一个锁的两个同步块只能串行地进入。 先行发生原则如果Java内存模型中所有的有序性都仅仅靠volatile和synchronized来完成，那么好像有一些操作将会变得很繁琐，但是我们在编写Java并发代码的时候并没有感觉到这一点，这是因为Java语言中有一个「先行发生」的原则。这个原则非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则一揽子地解决并发环境下两个操作之间是否可能存在冲突的所有问题。 先行发生是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于B，其实就是说发生在操作B之前，操作A产生的影响能被B观察到，「影响」包括修改了内存中共享变量的值、发送了消息、调用了方法等。 Java内存模型有有些天然的先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序行保障，虚拟机可以对它们随意地进行重排序。 程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。 管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，这里「后面」是指时间上的先后顺序。 volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里「后面」同样是指时间上的先后顺序。 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。 线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手短检测到线程已经终止执行。 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。 对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。 传递性：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。 Java语言无须任何同步手段保障就能成立的先行发生规则就只有上面这些。下面演示如何用这些规则来判定操作间是否具备顺序性 1234567891011private int value = 0;public void setValue(int value)&#123; this.value = value;&#125;public int getValue()&#123; return value;&#125; 这是很普通的getter/setter方法，假设存在线程A和B，线程A先(时间上的先后)调用了“setValue(1)”，然后线程B调用了同一个对象的“getValue()”，那么线程B的返回值是什么？我们根据规则来分析一下：由于两个方法分别由线程A和线程B调用，不在一个线程中，所以程序次序规则不适用；由于没有同步块，就没有lock和unlock操作，所以管程锁定规则不适用；由于value变量没有被volatile关键字修饰，所以volatile变量规则不适用；后面的线程启动、终止、中断规则和对象终结规则也和这里完全没有关系。因为没有一个使用的先行发生规则，所以最后一条传递性也无从谈起。因此可以判定尽管线程A在操作时间上先于线程B，但是无法确定线程B中的“getValue()”方法的返回结果，换句话说，这里面的操作不是线程安全的 那如何修复这个问题？至少有两种比较简单的方案： setter/getter都定义成synchronized的，这样可以套用管程锁定规则 value定义为volatile变量，由于setter方法对value的修改不依赖于value的原值，满足volatile关键字的使用场景，这样可以套用volatile变量规则 我们也得出一个结论：时间先后顺序与先行发生原则之间基本没有太大的关系，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准。 Java与线程线程的实现Java的线程API基本都是Native方法，意味着这个方法没有使用或无法使用平台无关的手段来实现。实现线程有3种方式：使用内核线程实现、使用用户线程实现和使用用户线程加轻量级进程混合实现。 使用内核线程实现 内核线程就是直接由操作系统支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。不过程序一般不会直接去使用内核线程，而是使用内核线程的一种高级接口–轻量级进程。这种方式系统调用代价较高，并且因为消耗内核资源，所以轻量级进程数量有限。轻量级进程与内核线程之间是1：1的关系。 使用用户线程实现 从广义上来讲，一个线程只要不是内核线程，就可以认为是用户线程。而狭义上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。这种方式的操作可以是非常快速且低消耗的，劣势在于没有系统内核支持，实现起来非常的复杂。Java和Ruby都曾经使用过用户线程，最终又都放弃使用它。进程与用户线程之间是1：N的关系。 使用用户线程加轻量级进程混合实现 线程除了依赖内核线程实现和完全由用户程序自己实现之外，还有一种将内核线程与用户线程一起使用的实现方式。在这种混合实现下，既存在用户线程，也存在轻量级进程。因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级进程来完成，大大降低了整个进城被完全阻塞的风险。用户线程与轻量级进程之间是N：M的关系。 Java线程的实现 1.2之前是用户线程实现的，1.2开始替换为基于操作系统原生线程模型来实现。因此在目前的JDK版本中，操作系统支持怎样的线程模型，很大程度上决定了Java虚拟机的线程是怎样映射的。对Sun JDK来说，它的Windows版和linux版都是使用一对一的线程模型实现的，一条Java线程就映射到一条轻量级进程之中，因为windows和Linux系统提供的线程模型就是一对一的。 Java线程调度线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度和抢占式线程调度。 协同式调度，线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知切换到另外一个线程上。好处是实现简单，干完自己的事情后进行线程切换，没有什么同步问题，坏处是一旦程序出问题，将会阻塞下去。 抢占式调度的多线程系统，每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定。这种实现线程调度的方式下，线程的执行时间是系统可控的，不会出现什么阻塞问题。 线程状态线程有5种状态 新建：创建后尚未启动的线程处于这种状态 运行：Runable包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着CPU为他分配执行时间。 无限期等待：处于这种状态的线程不宜被分配CPU执行时间，她们要等待被其他线程显式的唤醒。以下方法会让线程陷入无限期的等待状态： 没有设置Timeout参数的Object.wait()方法 没有设置Timeout参数的Thread.join()方法 LockSupport.park()方法 限期等待：处于这种状态的线程也不会被分配CPU执行时间，不过无须等待被其他线程显式地唤醒，在已定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态： Thread.sleep()方法。 设置了Timeout参数的Object.wait()方法。 设置了Timeout参数的Thread.join()方法。 LockSupport.parkNanos()方法。 LockSupport.parkUntil()方法 阻塞：线程被阻塞了，「阻塞状态」与「等待状态」的区别是：「阻塞状态」在等待着获取一个到一个排他锁，这个时间将在另外一个线程放弃这个锁的时候发生；而「等待状态」则是等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。 结束：已终止线程的线程状态，线程已经结束执行。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Editor-tool]]></title>
    <url>%2F2016%2F11%2F20%2FEditor-tool%2F</url>
    <content type="text"><![CDATA[##文章链接 编辑器介绍 ##好用的Markdown编辑器一览 dillinger MaHua 简书 小书匠编辑器 Cmd Markdown 简书 ##Chrome插件 Marxico 马克飞象 FarBox Cmd Markdown 小书匠编辑器 Sublime Text Atom Smark MdCharm Miu Mou Typora MacDown Byword iA Writer Ulysses Typed]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Native-打包apk]]></title>
    <url>%2F2016%2F11%2F20%2FReact-Native-%E6%89%93%E5%8C%85apk%2F</url>
    <content type="text"><![CDATA[##生成一个签名 数字身份 keytool百科 使用keytool命令生成一个私有密钥 12keytool -genkey -v -keystore my-release-key.keystore -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000 这条命令会要求你输入密钥库（keystore）和对应密钥的密码，然后设置一些发行相关的信息。最后它会生成一个叫做my-release-key.keystore的密钥库文件。在运行上面这条语句之后，密钥库里应该已经生成了一个单独的密钥，有效期为10000天。–alias参数后面的别名是你将来为应用签名时所需要用到的，所以记得记录这个别名。参数详解：-dname “CN=xx,OU=xx,O=xx,L=xx,ST=xx,C=xx” dn名为”CN=…”-alias scent 别名为scent的一个证书-keyalgDSA RSA DSA或RSA算法(当使用-genkeypair参数)DES DESede AES DES或DESede或AES算法(当使用-genseckey参数)-keysize512 ~ 1024 密钥的长度为512至1024之间(64的倍数)(当使用-genkeypair和-keyalg DSA参数) 12&gt; 512 密钥的长度大于512 (当使用-genkeypair和-keyalg RSA参数) 56 密钥的长度为56 (当使用-genseckey和-keyalg DES 参数) 112 168 密钥长度为112或168(当使用-genseckey和-keyalg DESede 参数) 128 192 256 密钥长度为128或192或256 (当使用-genseckey和-keyalg AES 参数) -keypass 123456 这个证书的私钥密码为123456 -keystore prospectlib 证书库的名称为prospectlib -storepass 123456 证书库的访问密码为123456 -validity 900 证书有效期为900天 -file scent.cer 从scent.cer文件导入证书，或者导出证书到 scent.cer文件 -v 显示详细信息 -rfc 以Base64的编码格式打印证书 -storetype JCEKS 密钥库的类型为JCEKS。常用的有JKS(默认),JCEKS(推荐),PKCS12,BKS,UBER。每个密钥库只可以是其中一种类型。 在桌面上会生成my-release-key.keystore文件 把my-release-key.keystore文件放到你工程中的android/app文件夹下。 编辑~/.gradle/gradle.properties，添加如下的代码（注意把其中的**替换为相应密码） 12345678MYAPP_RELEASE_STORE_FILE=my-release-key.keystoreMYAPP_RELEASE_KEY_ALIAS=my-key-aliasMYAPP_RELEASE_STORE_PASSWORD=*****MYAPP_RELEASE_KEY_PASSWORD=***** ##添加签名到应用的gradle配置文件 编辑你工程目录下的android/app/build.gradle，添加如下的内容： 12345678910111213141516171819202122232425262728293031323334353637383940...android &#123; ... defaultConfig &#123; ... &#125; signingConfigs &#123; release &#123; storeFile file(MYAPP_RELEASE_STORE_FILE) storePassword MYAPP_RELEASE_STORE_PASSWORD keyAlias MYAPP_RELEASE_KEY_ALIAS keyPassword MYAPP_RELEASE_KEY_PASSWORD &#125; &#125; buildTypes &#123; release &#123; ... signingConfig signingConfigs.release &#125; &#125;&#125;... ##生成发行APK包 切换到android目录 123cd androidgradlew assembleRelease 好像这个文件夹下要先有一个未签名的app-release-unaligned.apk 不懂 我执行了两次好了 ##测试应用的发行版本 12gradlew installRelease 安装到模拟器中，不会自动打开app，自己手动打开，不用再开启js 服务了，因为你的代码全部打包到apk中了。 ##启用Proguard代码混淆来缩小APK文件的大小（可选） Proguard是一个Java字节码混淆压缩工具，它可以移除掉React Native Java（和它的依赖库中）中没有被使用到的部分，最终有效的减少APK的大小。 重要：启用Proguard之后，你必须再次全面地测试你的应用。Proguard有时候需要为你引入的每个原生库做一些额外的配置。参见app/proguard-rules.pro文件。 要启用Proguard，编辑android/app/build.gradle文件 前后比较]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[code_sign]]></title>
    <url>%2F2016%2F11%2F19%2Fcode-sign%2F</url>
    <content type="text"><![CDATA[《刘瑜写给女儿的信：愿你慢慢长大 》小布谷，愿你慢慢长大。愿你有好运气，如果没有，愿你在不幸中学会慈悲。愿你被很多人爱，如果没有，愿你在寂寞中学会宽容。愿你一生一世每天都可以睡到自然醒。 I am BlankCat，welcome to my blog； 技术要点123456代码动画ffmpeg（谷歌一下）http://www.asciiworld.com/http://www.bilibili.com/topic/70.html代码设计自己的个性签名]]></content>
      <categories>
        <category>代码签名</category>
      </categories>
      <tags>
        <tag>代码签名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[发布hexo博文命令]]></title>
    <url>%2F2016%2F11%2F19%2Fhexo-command%2F</url>
    <content type="text"><![CDATA[I am BlankCat，welcome to my blog； 技术要点1234567891011121314dubug命令hexo s --debug创建新文章(文章名字小写)hexo new post 文章名字发布文章hexo ghexo dhexo cleandubug命令hexo s --debug]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[net 网络知识]]></title>
    <url>%2F2016%2F11%2F19%2Fnet%2F</url>
    <content type="text"><![CDATA[I am BlankCat，welcome to my blog； 技术要点123456789101112131415161718192021222324252627282930ipv4私网地址 百度一下IPV4 地址分类 A B C D Ehttp://blog.csdn.net/ylqmf/article/details/4970213c类网段一般容纳254个主机；网络：设置WAN广域网LAN局域网WLAN无线局域网WAN口是对外的接口，和运营商、上级网络打交道。LAN和WLAN是对内的接口，内部的电脑、手机、PAD，都是接入到LAN或者WLAN。一般的无线路由器，包含了完整的LAN、WAN、WLAN功能ip地址讲解http://blog.csdn.net/yangluoning/article/details/8667067如何浏览器下载局域网电脑的东西输入wifi密码，手机是如何和路由器交换数据的python监听端口下载东西python -m SimpleHTTPServer 80]]></content>
      <categories>
        <category>net</category>
      </categories>
      <tags>
        <tag>net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cmd 命令]]></title>
    <url>%2F2016%2F11%2F19%2Fcmd%2F</url>
    <content type="text"><![CDATA[I am BlankCat ，welcome to my blog； 技术要点12345678910111213141516171819202122232425The nexus service is already running with status: RUNNING端口号被占用1查看所有端口netstat -ano2查看固定端口C:\&gt;netstat -aon|findstr "8081" 协议 本地地址 外部地址 状态 PID TCP 127.0.0.1:9050 0.0.0.0:0 LISTENING 20163.查看PID对应的进程C:\&gt;tasklist|findstr "2016" 映像名称 PID 会话名 会话# 内存使用 ========================= ======== ================ tor.exe 2016 Console 0 16,064 K 查看taskkill这个用法C:\Windows\System32\taskkill /?杀死进程C:\Windows\System32\taskkill /PID 11052强制杀死进程C:\Windows\System32\taskkill /F /PID 11052]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Big data]]></title>
    <url>%2F2016%2F11%2F19%2FBigdata%2F</url>
    <content type="text"><![CDATA[《刘瑜写给女儿的信：愿你慢慢长大 》小布谷，愿你慢慢长大。愿你有好运气，如果没有，愿你在不幸中学会慈悲。愿你被很多人爱，如果没有，愿你在寂寞中学会宽容。愿你一生一世每天都可以睡到自然醒。 I am BlankCat ，welcome to my blog； 技术要点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748集群分3种负载均衡：分发机制，也会用到主从概念，咱们访问wwww.baidu.com时候，百度会对应着一个服务器 这个服务ip不是对应真正的请求服务，而是做了一层分发，这样用户请求多了，可以保证减轻服务的压力 负载均衡机制都是通过算法计算，然后完成；高可用：针对服务概念，访问一个比较重要的服务，把服务做成高可用模式 把服务写成分解成多个，主服务和从服务（服务的总数必须是奇数个，方便投票机制）， 服务与服务之间通过心跳机制去沟通，发消息，每秒钟发一次； 服务与服务之间通过投票机制产生主服务。把服务拓展成性能比较高的服务 这叫高可用服务。并行计算，针对任务，一个大任务分成几个小任务，最后做汇总，hadoop并行计算（百度一下） 业务场景，统计（天气预报）全国的天气预报，需要每天每分钟做定时统计，这里设计业务很复杂的计算 为了完成一个任务，会把大的任务分解成一个小的任务，把小任务的结果进行汇总，完成任务的并行计算。================================5个九，保一年内证宕机几分钟？5个 9的是可用性，服务的可用性，高可用性 (服务器的高可用性)什么是“5个9”(99.999%)的可靠性？（GG一下,你就知道）================================clusterLB: load balancing : 负载均衡，提高并发处理能力 health check: 健康检测HA:hight availability: 高可用集群，检测心跳，提升服务在线能力（服务可用性） 在线时间/（在线时间+故障处理时间）HP:hight performance : 高性能集群，并行计算集群，处理复杂计算，科学计算集群 分布式文件系统 将大任务切割成小任务，分别进行处理的机制================================数据库主从（读写分离）http://www.cnblogs.com/panxuejun/p/5887118.html主数据库master（在往log日志里面写的时候会先锁住），插入数据库的记录会进入等待，从数据库slave，会开启两个线程（单进程多线程模式），一个io线程，一个sql线程，io读取主数据的binlog日志，sql线程执行sql，同步数据，完成数据库的同步；================================cURL是一个利用URL语法在命令行下工作的文件传输工具，1997年首次发行。它支持文件上传和下载，所以是综合传输工具，但按传统，习惯称cURL为下载工具。cURL还包含了用于程序开发的libcurl官网 https://curl.haxx.se/curl 命令行下载工具使用方法小结 http://www.jb51.net/softjc/26483.html]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo技术总结]]></title>
    <url>%2F2016%2F11%2F19%2Fhexo%2F</url>
    <content type="text"><![CDATA[《愿你慢慢长大 》小布谷，愿你慢慢长大。愿你有好运气，如果没有，愿你在不幸中学会慈悲。愿你被很多人爱，如果没有，愿你在寂寞中学会宽容。愿你一生一世每天都可以睡到自然醒。 I am BlankCat，welcome to my blog； 技术要点12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364半个小时搭建一个个人博客hexo个人博客http://blog.csdn.net/v123411739/article/details/44964065搭建个人博客http://www.cnblogs.com/zhcncn/p/4097881.html搭建个人博客（重点）http://blog.csdn.net/jzooo/article/details/46781805个人博客搭建（知乎）https://www.zhihu.com/question/20962496hexo+github+多说http://blog.netpi.me/%E5%AE%9E%E7%94%A8/hexo/如何搭建一个个人博客（附文注册域名，维护站点）http://cnfeat.com/blog/2014/05/10/how-to-build-a-blog/mycat分库分表http://blog.csdn.net/leipeng321123/article/details/50401376搭建个人博客（****）http://blog.csdn.net/jzooo/article/details/46781805hexo上传失败解决http://www.cnblogs.com/xsilence/p/6001938.html博客主题http://blog.xinspace.space/2016/04/11/%E8%87%AA%E5%AE%9A%E4%B9%89Hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%96%87%E7%AB%A0%E3%80%81%E8%8D%89%E7%A8%BF%E5%92%8C%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%A8%A1%E6%9D%BF/炫酷主题https://github.com/iissnan/hexo-theme-next使用文档http://theme-next.iissnan.com/hexo+next主题http://www.jianshu.com/p/f66103553c45hexo+github 总结https://zhuanlan.zhihu.com/p/22632478搭建博客（******）http://www.jianshu.com/p/f66103553c45$ hexo s --debug优化http://www.jeyzhang.com/hexo-next-add-post-views.html#http://michaelxiang.me/2015/11/30/hexo-next-optimize/发布博客git config --global user.name ""git config --global user.email ""hexo d -g发布文章hexo上传失败解决http://www.cnblogs.com/xsilence/p/6001938.html$ hexo g$ hexo d]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[adb]]></title>
    <url>%2F2016%2F11%2F19%2Fadb%2F</url>
    <content type="text"><![CDATA[《刘瑜写给女儿的信：愿你慢慢长大 》小布谷，愿你慢慢长大。愿你有好运气，如果没有，愿你在不幸中学会慈悲。愿你被很多人爱，如果没有，愿你在寂寞中学会宽容。愿你一生一世每天都可以睡到自然醒。 I am BlankCat ，welcome to my blog； 技术要点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134原文地址：http://blog.csdn.net/gaojinshan/article/details/9382953有时候ADB不能用，并且会报以下的错误：C:\Users\gaojs&gt;adb devicesadb server is out of date. killing...ADB server didn't ACK* failed to start daemon *error: unknown host service用如下的命令，发现5037的端口被占用：C:\Users\gaojs&gt;adb nodaemon servercannot bind 'tcp:5037'用如下的命令，能查到什么进程占用了这个端口：C:\Users\gaojs&gt;netstat -ano | findstr "5037" TCP 127.0.0.1:5037 0.0.0.0:0 LISTENING 21152 TCP 127.0.0.1:5037 127.0.0.1:62629 ESTABLISHED 21152 TCP 127.0.0.1:5037 127.0.0.1:63942 TIME_WAIT 0 TCP 127.0.0.1:5037 127.0.0.1:63943 TIME_WAIT 0 TCP 127.0.0.1:5037 127.0.0.1:63944 TIME_WAIT 0 TCP 127.0.0.1:62629 127.0.0.1:5037 ESTABLISHED 2980用如下命令，可以看到上述PID的进程，到底是什么了：C:\Users\gaojs&gt;tasklist | findstr "2980"QQ.exe 2980 Console 4 60,712 KC:\Users\gaojs&gt;tasklist | findstr "21152"tadb.exe 21152 Console 4 2,136 K原来是腾讯这个无耻的家伙（tadb就是Tencent Adb）！用如下的命令，将tadb.exe（PID:21152）杀掉：C:\Users\gaojs&gt;taskkill /f /pid 21152然后，再试，就可以了：C:\Users\gaojs&gt;adb devices* daemon not running. starting it now on port 5037 ** daemon started successfully *List of devices attached4dfadcb86b00cf05 device=============================查询进程号命令=========================3.输入：tasklist | findstr 端口(获取步骤2里面的端口，实际就是拿到了pid)=============================杀死进程号命令=========================4.taskkill /pid 端口（步骤3里面的端口） /F杀死进程http://blog.csdn.net/diaoruiqing/article/details/7851001假如这个进程占用了你的端口号，那么用这个方法干掉它。用Ctrl+Alt+Delete调出windows任务管理器窗口，可以直接通过名称找到这个占用的进程，然后选择结束进程。也可以通过PID号找到这个进程。点击&lt;查看&gt;-&gt;&lt;选择列&gt;，勾选&lt;PID(进程标识符号)&gt;，找到并结束进程。另外一个方法就是继续使用命令：C:\&gt;taskkill /f /t /javaw.exe========================================================执行命令http://blog.csdn.net/u012842688/article/details/50916802adb链接不到设备adb devicesadb kill-serveradb start-serveradb device固定命令（神模拟器）adb connect 127.0.0.1:62001adb device原文地址http://bbs.pediy.com/showthread.php?t=206396=====================================================根据应用进程id查看端口任务管理器里面查找进程 pid执行命令，找到对应的端口号netstat -ano======================================================]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM10-运行期优化]]></title>
    <url>%2F2016%2F11%2F17%2FJVM10%2F</url>
    <content type="text"><![CDATA[Java程序最初是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为『热点代码』。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器。 HotSpot虚拟机内的即时编译器解释器与编译器HotSpot虚拟机是采用解释器与编译器并存的架构。解释器和编译器各有优势：当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间的推移，编译器初见发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率。 编译对象与触发条件在运行过程中被即时编译器编译的『热点代码』有两类： 被多次调用的方法 被多次执行的循环体 前者很好理解，一个方法被调用得多了，方法体内代码执行的次数自然就多，他成为”热点代码”也是理所当然。而后者则是为了解决一个方法只被调用过一次或者少量的几次，但是方法体内部存在循环次数较多的循环体问题，这样循环体的代码也被重复执行多次，因此这些代码也应该认为是”热点代码”。 判断一段代码是不是热点代码，是不是需要触发即时编译，这样的行为称为热点探测，目前主要有两种方式： 基于采样的热点探测 基于计数器的热点探测 HotSpot是使用的第二种，基于计数器的热点探测方法，因此它为每个方法准备了两类计数器：方法调用计数器和回边计数器。在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阀值，超过这个阀值，就会触发JIT编译。 方法调用计数器这个计数器就是统计方法被调用的次数，默认阀值在Client模式下是1500次，在Server模式下是10000次，这个阀值可以通过虚拟机参数-XX:CompileThreshold来设置。当一个方法被调用时，会检查方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器和回边计数器值之和是否超过方法调用计数器的阈值。如果已经超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。 如果不做任何设置，执行引擎并不会同步等待编译请求完成，而是直接进入解释器按照解释方法执行字节码，直到提交的请求被编译器编译完成。当编译工作完成之后，这个方法的调用入口地址就会被系统自动改写成新的，下一次调用该方法时就会使用已编译的版本。 如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会少一半，这个过程称为方法的调用计数器热度的衰减，而这段时间就称为此方法统计的半衰周期。进行热度衰减的动作是在虚拟机进行垃圾回收时顺便进行的，可以使用虚拟机参数-XX:-UseCounterDecay来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。另外，可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。 回边计数器它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为”回边”。显然，建立回边计数器统计的目的就是为了触发OSR编译。 关于回边计数器的阈值，虽然HotSpot也提供了一个类似于方法调用计数器阈值-XX:CompileThreshold的参数-XX:BackEdgeThreshold供用户设置，但是当前虚拟机实际上并未使用此参数，因此我们需要设置另外一个参数-XX:OnStackReplacePercentage来间接调整回边计数器的阈值，其计算公式如下： Client模式 方法调用计数器阈值 × OSR比率 / 1000，其中OSR比率默认值933，如果都取默认值，Client模式下回边计数器的阈值应该是13995 Server模式 方法调用计数器阈值 × (OSR比率 - 解释器监控比率) / 100，其中OSR比率默认140，解释器监控比率默认33，如果都取默认值，Server模式下回边计数器阈值应该是10700 当解释器遇到一条回边指令时，会先查找将要执行的代码片段中是否有已经编译好的版本，如果有，它将会优先执行已编译好的代码，否则就把回边计时器的值加1，然后判断方法调用计数器与回边计数器值之和是否已经超过回边计数器的阈值。当超过阈值之后，将会提交一个OSR编译请求，并且把回边计数器的值降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果。 与方法计数器不同，回边计数器没有热度衰减的过程，因此这个计数器统计的就是该方法循环执行的绝对次数。当计数器溢出的时候，它还会把方法计数器的值也调整到溢出状态，这样下次再进入该方法的时候就会执行标准编译过程。 编译过程在默认设置下，无论是方法调用产生的即时编译请求，还是OSR编译请求，虚拟机在代码编译器还未完成的时候，都仍然按照解释方式继续执行，而编译动作则在后台的编译线程中进行。用户可以通过-XX:-BackgroundCompilation来禁止后台编译，在禁止后台编译后，一旦达到JIT的编译条件，执行线程向虚拟机提交编译请求后将会一直等待，直到编译过程完成后再开始执行编译器输出的本地代码。 对于Client Compiler（C1编译器）来说，它是一个简单快速的三段式编译，主要关注点在于局部性的优化，而放弃了许多耗时间长的全局优化手段。 对于Sever Compiler（C2编译器）来说，它则是专门面向服务端的典型应用并为服务端的性能配置特别调整过的编译器，也是一个充分优化过的高级编译器，几乎能达到GNU C++编译器使用-O2参数时的优化强度，它会执行所有经典的优化动作，如无用代码消除、循环展开、常量传播、基本块重排序等，还会实施一些与Java语言特性密切相关的优化技术，如范围检查消除、空值检查消除等，另外，还有可能根据解释器或Client Compiler提供的性能监控信息，进行一些不稳定的激进优化，如守护内联、分支频率预测等，下一部分将讲解上述的一部分优化手段。 Server Compiler从即时编译的标准来看，无疑是比较缓慢的，但它的编译速度依然远远超过传统的静态优化编译器，而且它相对于Client Compiler编译输出的代码质量有所提高，可以减少本地代码的执行时间，从而抵消了额外的编译时间开销，所以也有很多非服务端的应用选择使用Server模式的虚拟机运行。 优化技术概览在Sun官方的Wiki上，HotSpot虚拟机设计团队列出了一个相对比较全面、在即时编译器中采用的优化技术列表，其中有不少经典编译器的优化手段，也有许多针对Java语言（准确地说是运行在Java虚拟机上得所有语言）本身进行的优化技术，下面主要看几项最有代表性的优化技术： 语言无关的经典优化技术之一：公共子表达式消除 语言无关的经典优化技术之一：数组范围检查消除 最重要的优化技术之一：方法内联 最前沿的优化技术之一：逃逸分析 公共子表达式消除公共子表达式消除的含义是：如果一个个表达式E已经计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就成了公共子表达式。对于这种表达式，没有必要花时间再对它进行计算，只需要直接用前面的计算结果代替E就可以了。如果这种优化仅限于程序的基本块内，便称为局部公共子表达式消除，如果这种优化的范围涵盖了多个基本块，那就称为全局公共子表达式消除。下面举例说明： int d = (c * b) * 12 + a + (a + b * c); 如果这段代码交给javac编译器则不会进行任何优化，但进入虚拟机即时编译器后，它将会进行如下优化：编译器检测到“c*b”与“b*c”是一样的表达式，而且在计算期间b与c的值是不会变的。因此这条表达式就可能被视为： int d = E * 12 + a + (a + E) 还有可能进行代数简化： int d = E * 13 + a * 2 表达式进行交换之后，再计算起来就可以节省一些时间了。 数组边界检查消除我们知道Java语言是一门动态安全的语言，对数组的读写访问也不像C、C++那样在本质上是裸指针操作。如果有一个数组foo[]，在Java语言中访问数组元素foo[i]的时候系统将会自动进行上下界的范围检查，即检查i必须满足i&gt;=0&amp;&amp;i&lt;foo.length这个条件，否则将抛出一个运行时异常：java.lang.ArrayIndexOutOfBoundsException。这对软件开发者来说是一件很好的事情，即时程序员没有专门编写防御代码，也可以避免大部分的溢出攻击。但是对于虚拟机的执行子系统来说，每次数组元素的读写都带有一次隐含的判定条件，对于拥有大量数组访问的程序代码，这无疑也是一种性能负担。 无论如何，为了安全，数组边界检查肯定是必须做的，但数组边界检查则不一定。例如：数组下标是一个常量，如foo[3]，只要在编译期根据数据流分析来确定foo.length的值，并判断下表“3”没有越界，执行的时候就无须判断了。更加常见的情况是数组访问发生在循环之中，如果编译器只要通过数据流分析就可以判定循环变量的取值范围永远在区间[0,foo.length])内，那在整个循环中就可以把数组的上下界检查消除，这可以节省很多次的条件判断操作。 方法内联它是编译器最重要的优化手段之一，除了消除方法调用的成本之外，它更重要的意义是为其他优化手段建立良好的基础。 12345678910public static void foo(Object obj)&#123; if(obj!=null) &#123; System.out.println("do something"); &#125;&#125;public static void testInline(String[] args) &#123; Object = null; foo(obj);&#125; 采用方法内联后大致成这样 123456public static void testInline(String[] args) &#123; Object = null; if(obj!=null) &#123; System.out.println("do something"); &#125;&#125; 因为有了方法内联的基础，这段代码还能被继续优化，删除不可能被执行的dead code。只有非虚方法才能直接内联，虚方法需要运行时确定调用目标，所以虚拟机还有一套“类型继承关系分析”的技术来确定目前已加载的类中，某个接口是否有多余一种的实现，某个类是否存在子类、子类是否为抽象类等信息。 逃逸分析逃逸分析是目前Java虚拟机中比较前沿的优化技术，他与类型继承关系分析一样，并不是直接优化代码的手段，而是为其他优化手段提供依据的分析技术。逃逸分析的基本行为就是分析对象动态作用域。 当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，称为方法逃逸。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。 如果能证明一个对象不会逃逸到方法或线程之外，也就是别的方法或线程无法通过任何途径访问到这个对象，则可能为这个变量进行一些高校的优化。如下： 栈上分配：Java虚拟机中，对象在堆上分配，Java堆中的对象对于各个线程都是共享可见的。虚拟机的垃圾收集系统可以回收堆中不再使用的对象，但回收动作无论是筛选可回收对象还是回收和整理内存都要耗费时间。如果确定一个对象不会逃逸出方法之外，那么让这个对象在栈上分配将会是一个不错的主意，对象所占用的内存空间就可以随着栈帧出栈而销毁，这样垃圾收集系统的压力将会小很多。 同步消除：线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那这个变量的读写肯定就不会有竞争，对这个变量实施的同步措施也就可以消除掉。 标量替换：标量是指一个数据已经无法再分解成更小的数据来表示了，Java虚拟机中的原始数据类型(int、long等)都不能进一步分解，它们就可以称为标量。相对的，如果一个数据可以继续分解那它就称作聚合量，Java中的对象就是最典型的聚合量。如果把一个Java对象拆散，根据程序访问的情况，将其使用到的成员变量恢复原始类型来访问就叫做标量替换。如果逃逸分析证明一个对象不会被外部访问，并且这个对象可以被拆散的话，那程序真正执行的时候将可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替。将对象拆分后除了可以让对象的成员变量在栈上分配和读写之外，还可以为后续进一步的优化手段创建条件。 关于逃逸分析的论文在1999年就已经发表，但直到Sun SDK1.6才实现了逃逸分析，而且直到现在这项优化尚未足够成熟，仍有很大的改进余地。不成熟的原因主要是不能保证逃逸分析的性能收益必定高于它的消耗。虽然在实际测试结果中，实施逃逸分析后的程序往往能运行出不错的成绩，但是在实际的应用程序，尤其是大型程序中反而发现实施逃逸分析可能出现效果不稳定的情况，或因分析过程耗时但却无法有效判别出非逃逸对象而导致性能有所下降。 如果有需要，并且确认对程序运行有益，可以使用参数-XX:+DoEscapeAnalysis来手动开启逃逸分析，开启之后可以通过参数-XX:+PrintEscapeAnalysis来查看分析结果。有了逃逸分析支持之后，就可以使用参数-XX:+EliminateAllocations来开启标量替换，使用参数-XX:+EliminatLocks来开启同步消除，使用参数-XX:+PrintEliminateAllocations查看标量的替换情况。 尽管目前逃逸分析技术仍不是十分成熟，但是在今后的虚拟机中，逃逸分析技术肯定会支撑起一系列实用有效的优化技术。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM9-虚拟机字节码执行引擎]]></title>
    <url>%2F2016%2F11%2F15%2FJVM9%2F</url>
    <content type="text"><![CDATA[执行引擎是Java虚拟机最核心的组成部分之一，本章将主要从概念模型的角度来讲解虚拟机的方法调用和字节码执行。 运行时栈帧结构栈帧（Stack Frame）是用于支持虚拟机进行方法代用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机里面从入栈到出栈的过程。对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法，执行引擎运行的所有字节码指令都只针对当前栈帧进行操作，在概念模型上，典型的栈帧结构图如下： 局部变量表局部变量表是一组变量值存储空间，用于存放参数和方法内部定义的局部变量。局部变量表的容量以变量槽（Slot）为最小单位。虚拟机规范中没有明确指明一个Slot应占用的内存空间大小，只是向导性的说到每个Slot都应该能存放一个boolean、byte、char、short、int、float、reference和returnAddress。reference表示对一个对象实例的引用，returnAddress目前很少见了。一个Slot可以存放一个32位以内的数据，那么64位的long和double会被分配两个连续的Slot空间。实例方法第0位索引的Slot默认是用于传递方法所属对象实例的引用（this），然后从1开始是方法参数，参数表分配完后再是方法体内部的变量。前面提到过，类变量在准备阶段会赋予系统初始值，初始化阶段赋予程序员定义的初始值，所以就算没有设值也会有一个默认值，但局部变量则不一样，没有设值变进行使用的话，编译无法通过。 1234public static void main(String[] args) &#123; int a; System.out.println(a);&#125; 操作数栈操作数栈也常称为操作栈，它是一个后入先出栈。操作数栈的每一个元素可以是任意的Java数据类型，包括long和double。32位的数据类型所占的栈容量为1，64为数据类型所占的栈容量为2。当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作。举个例子，整数加法的字节码指令iadd在运行的时候操作数栈中最接近栈顶的两个元素已经存入了两个int类型的数值，当执行这个指令时，会将这两个int值出栈并相加，然后将加的结果入栈。 动态连接每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。我们知道Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。另外一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。 方法返回地址当一个方法开始执行后，只有两种方式退出方法，要么遇到方法返回的字节码指令，要么是在方法执行过程中遇到了异常。无论哪种退出方式，在方法退出后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。 方法调用方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。 解析所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载解析阶段，会将其中一部分符号引用转化为直接引用，这个前提是调用目标在程序代码写好、编译器进行编译时必须确定下来。这类方法的调用称为解析（Resolution）。 在Java语言符合“编译期可知，运行期不可变”的方法主要包括静态方法和私有方法。 调用方法的虚拟机字节码指令： invokestatic：调用静态方法 invokespecial：调用实例构造器方法、私有方法和父类方法 invokevirtual：调用所有的虚方法 invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象 invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，在此之前的4条调用指令，分派逻辑是固化在Java虚拟机内部的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。 能被invokestatic和invokespecial指令调用的方法，能在解析阶段把符号引用转化为直接引用，这些方法称为非虚方法，其他方法称为虚方法（final除外）。被final修饰的虽然是用invokevirtual调用的，但是它是一个非虚方法。 分派分派调用可能是静态的也可能是动态的，又可分为单分派和多分派。 静态分派先上一段代码 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Created by YangFan on 2016/11/16 上午11:14. * &lt;p/&gt; * 静态分派演示 */public class StaticDispatch &#123; static abstract class Human &#123; &#125; static class Man extends Human &#123; &#125; static class Woman extends Human &#123; &#125; public void sayHello(Human guy) &#123; System.out.println("hello, guy"); &#125; public void sayHello(Woman guy) &#123; System.out.println("hello, lady"); &#125; public void sayHello(Man guy) &#123; System.out.println("hello, gentleman"); &#125; public static void main(String[] args) &#123; Human man = new Man(); Human woman = new Woman(); StaticDispatch sd = new StaticDispatch(); sd.sayHello(man); sd.sayHello(woman); &#125;&#125; 运行结果： 12hello, guyhello, guy 很简单，下面从虚拟机的角度来讲解一下。 Human man = new Man(); 上面的“Human”称为变量的静态类型（Static Type），后面的“Man”称为变量的实际类型（Actual Type）。静态类型在编译期是可知的，实际类型变化的结果在运行期才可确定。虚拟机（编译器）在重载时是通过参数的静态类型而不是实际类型作为判定依据的，所以选了sayHello(Human)作为调用目标，并把这个方法的符号引用写到main()方法里的两条invokevirtual指令的参数中。 所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。 动态分派动态分派和多态的重写有着密切的关联。 12345678910111213141516171819202122232425262728293031323334/** * Created by YangFan on 2016/11/16 下午3:25. * &lt;p/&gt; * 方法动态分派演示 */public class DynamicDispatch &#123; static abstract class Human &#123; protected abstract void sayHello(); &#125; static class Man extends Human &#123; @Override protected void sayHello() &#123; System.out.println("man say hello"); &#125; &#125; static class Woman extends Human &#123; @Override protected void sayHello() &#123; System.out.println("woman say hello"); &#125; &#125; public static void main(String[] args) &#123; Human man = new Man(); Human woman = new Woman(); man.sayHello(); woman.sayHello(); man = new Woman(); man.sayHello(); &#125;&#125; 运行结果： 123man say hellowoman say hellowoman say hello 我们用javap -c 命令看看输出结果 123456789101112131415161718192021public static void main(java.lang.String[]); Code: 0: new #2 // class polymorphic/DynamicDispatch$Man 3: dup 4: invokespecial #3 // Method polymorphic/DynamicDispatch$Man.&quot;&lt;init&gt;&quot;:()V 7: astore_1 8: new #4 // class polymorphic/DynamicDispatch$Woman 11: dup 12: invokespecial #5 // Method polymorphic/DynamicDispatch$Woman.&quot;&lt;init&gt;&quot;:()V 15: astore_2 16: aload_1 17: invokevirtual #6 // Method polymorphic/DynamicDispatch$Human.sayHello:()V 20: aload_2 21: invokevirtual #6 // Method polymorphic/DynamicDispatch$Human.sayHello:()V 24: new #4 // class polymorphic/DynamicDispatch$Woman 27: dup 28: invokespecial #5 // Method polymorphic/DynamicDispatch$Woman.&quot;&lt;init&gt;&quot;:()V 31: astore_1 32: aload_1 33: invokevirtual #6 // Method polymorphic/DynamicDispatch$Human.sayHello:()V 36: return 0~15行的字节码是准备动作，作用是建立man和woman的内存空间、调用Man和Woman类型的实例构造器，将这两个实例的引用存放在第1、2个局部变量Slot之中，这个动作对应了这两句代码。 12Human man = new Man();Human woman = new Woman(); 然后16~21行是关键。16: aload_1和20: aload_2两句分别将两个对象压入栈顶，17和21的invokevirtual就是调用方法指令，后面的是参数（方法的符号引用）。那么多态如何确定执行的目标方法，下面说一下invokevirtual指令的运行时解析过程： 找到操作数栈的第一个元素所指向的对象的实际类型，记作C。 如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError异常。 否则，按照继承关系从下往上一次对C的各个父类进行第2步的搜索和验证过程。 如果始终没有找到合适的方法，则抛出java.lang.AbstracMethodError异常。 由于invokevirtual指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的invokevirtual指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是Java语言中方法重写的本质。我们把这种在运行期根据实际类型确定方法执行版本的过程称为动态分派。 单分派与多分派方法的接收者与方法的参数统称为方法的宗量。根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种。单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。看代码1234567891011121314151617181920212223242526272829303132333435363738394041/** * Created by YangFan on 2016/11/16 下午5:07. * &lt;p/&gt; * 单分派、多分派演示 */public class Dispatch &#123; static class QQ &#123;&#125; static class _360 &#123;&#125; public static class Father &#123; public void hardChoice(QQ arg) &#123; System.out.println("father choose qq"); &#125; public void hardChoice(_360 arg) &#123; System.out.println("father choose 360"); &#125; &#125; public static class Son extends Father &#123; public void hardChoice(QQ arg) &#123; System.out.println("son choose qq"); &#125; public void hardChoice(_360 arg) &#123; System.out.println("son choose 360"); &#125; &#125; public static void main(String[] args) &#123; Father father = new Father(); Father son = new Son(); father.hardChoice(new _360()); son.hardChoice(new QQ()); &#125;&#125; 运行结果： 12father choose 360son choose qq 编译阶段，也就是静态分派的过程，先确定静态类型是Father还是Son，再确定参数是QQ还是360，因为是根据两个宗量进行选择，所以Java语言的静态分派是多分派类型。 运行阶段，也就是动态分派的过程，在执行“son.hardChoice(new QQ());”对应的invokevirtual指令时，由于编译期已决定目标方法的签名必须为hardChoice(QQ),所以只需要确定方法接收者的实际类型是Father还是Son。因为只有一个宗量作为选择依据，所以Java语言的动态分派属于单分派类型。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM8-类加载机制]]></title>
    <url>%2F2016%2F11%2F07%2FJVM8%2F</url>
    <content type="text"><![CDATA[类加载机制虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。 类加载的时机类被夹在到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用、卸载7个阶段。其中验证、准备、解析3个部分统称为连接，这个阶段的发生顺序如下图所示： 图中加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。 虚拟机规定了5种主动引用必然会触发初始化（加载、验证、准备在此之前开始） 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时。这4条指令的Java代码场景是：使用new关键字实例化对象，读取或设置一个类的静态字段（被final修饰，已在编译期放入常量池的除外），调用一个类的静态方法。 使用java.lang.reflect反射调用的时候，如果类还没有初始化，则需要先初始化 父类未初始化，则先初始化一个类的父类 虚拟机启动的时候会先初始化执行的主类（包含main的类） 当使用JDK1.7的动态语言支持时，如果一个java.lang.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。 除了这些主动引用，其他引用类都不会触发初始化，称为被动引用。例如通过子类引用父类的静态字段，不会触发子类初始化。 类加载的过程下面分别介绍一下加载、验证、准备、解析和初始化这5个阶段所执行的具体动作。 加载“加载”是“类加载”过程的一个阶段，在加载阶段，虚拟机需要完成3件事情： 通过一个类的全限定名来获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 验证验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 文件格式验证 第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，验证通过后，才会存入方法区。例如 是否以魔数0xCAFEBABE开头 主、次版本号是否在当前虚拟机处理范围之内 常量池的常量中是否有不被支持的常量类型 元数据验证 第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范，例如 是否有父类 是否继承了不允许继承的类(被final修饰的类) 如果这个类不是抽象类，是否实现了父类或接口中要求实现的方法 字节码验证 第三阶段目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。例如：在操作栈上放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中。 符号引用验证 最后一个阶段的校验发生再虚拟机将符号引用转换为直接引用的时候，这个转化动作将在连接的第三个阶段-解析阶段发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，例如符号引用中通过字符串描述的全限定名是否能找到对应的类，在指定类中是否存在符合方法的字段描述以及简单名称所描述的方法和字段等等。 准备准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中分配。这个时候进行内存分配仅包括类变量（static），而不包括实例变量。注意初始值是指分配零值 public static int value = 123; 变量value在准备阶段过后的初始值是0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器()方法之中，所以把value赋值为123的动作将在初始化阶段才会执行。加了final的常量除外，这个放在方法区常量池中的数据将会在准备阶段被赋值 解析解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。符号引用就是那些我们用javap命令看到的Methodref，Fieldref一类的。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。 初始化类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源。初始化阶段就是执行类构造器()方法的过程。()方法就是由编译器收集类中所有的类变量的赋值动作和静态语句（static{}块）。 类加载器虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其再Java虚拟机中的唯一性。意思就是比较两个类相等的前提是这两个类由同一个类加载器加载。 123456789101112131415161718192021222324252627282930313233343536/** * Created by YangFan on 2016/11/15 下午3:37. * &lt;p/&gt; * 相等是指类的.class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括使用instanceof关键字做对象所属关系判定等情况。 */public class ClassLoaderTest &#123; public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123; ClassLoader myLoader = new ClassLoader() &#123; @Override public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; try &#123; String fileName = name.substring(name.lastIndexOf(".") + 1) + ".class"; InputStream is = getClass().getResourceAsStream(fileName); if (is == null) &#123; return super.loadClass(name); &#125; byte[] b = new byte[is.available()]; is.read(b); return defineClass(name, b, 0, b.length); &#125; catch (IOException e) &#123; throw new ClassNotFoundException(); &#125; &#125; &#125;; Object obj = myLoader.loadClass("clazzloader.ClassLoaderTest").newInstance(); System.out.println(obj.getClass()); System.out.println(obj instanceof ClassLoader); &#125;&#125; 运行结果： 12class clazzloader.ClassLoaderTestfalse 双亲委派模型（重要）从Java虚拟机的角度来将，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分；另一种就是其他的类加载器，这些类加载器由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。从开发人员角度来看，还可以划分得更细致一些： 启动类加载器前面介绍过，它负责加载的是JAVA_HOME/lib下的类库，系统类加载器无法被Java程序直接应用。 扩展类加载器这个类加载器由sun.misc.Launcher$ExtClassLoader实现，它负责用于加载JAVA_HOME/lib/ext目录中的，或者被java.ext.dirs系统变量指定所指定的路径中所有类库，开发者可以直接使用扩展类加载器。 应用程序类加载器这个类加载器由sun.misc.Launcher$AppClassLoader实现。这个类加载器是ClassLoader.getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 这个图展示的类加载器之间的这种层次关系，称为双亲委派模型。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载都应当有自己的父类加载器。这里的类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合关系来复用父加载器代码。 双亲委派模型的工作过程是:如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。这样做能保证一个类始终是被同一个类加载器加载。 1234567891011121314151617/** * Created by YangFan on 2016/11/15 下午4:17. * &lt;p/&gt; * 我们可以打印一下各种加载器看看是否复合图上描述 */public class Loader &#123; public static void main(String[] args) &#123; // 应用程序类加载器 System.out.println(ClassLoader.getSystemClassLoader()); // 扩展类加载器 System.out.println(ClassLoader.getSystemClassLoader().getParent()); // 启动类加载器 System.out.println(ClassLoader.getSystemClassLoader().getParent().getParent()); // 应用程序类加载器加载的路径 System.out.println(System.getProperty("java.class.path")); &#125;&#125; 运行结果： 1234sun.misc.Launcher$AppClassLoader@330bedb4sun.misc.Launcher$ExtClassLoader@5cad8086null/Users/xiaomai/code/IdeaProjects/jvm/out/production/jvm:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar 这里说到一个实践，就是有时候我们想覆盖第三方jar包中的某个类，除了替换jar包中的class文件的方式，还可以直接在项目中编写一个一样包名的类。上面打印在前面的/Users/xiaomai/code/IdeaProjects/jvm/out/production/jvm（相当于web项目里WEB-INF下的class文件夹）目录下的class会优先于第三方jar包中的class加载。但是却没有办法写一个同样包名的类来覆盖lib和ext下面的库的类。上面的null，表示ClassLoader就是Bootstrap ClassLoader。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM7-类文件结构]]></title>
    <url>%2F2016%2F11%2F04%2FJVM7%2F</url>
    <content type="text"><![CDATA[Class类文件结构本章说一下Java编译后的class文件结构。 魔数与Class文件的版本我这里用sublime打开一个class文件，看到前面4个字节是十六进制0xCAFEBABE,这个是Class文件的魔数. 很多文件存储标准中都使用魔数进行身份识别，因为扩展名可以更改，魔数就是确定这个文件是否为一个能被虚拟机接受的Class文件。 然后看0000 0034，转换成十进制是52，这个表示Java编译的版本号，相信大家在工作中也遇见过Unsupported major.minor version 52.0之类的错误，指的就是这个版本号，52对应的是JDK8。 常量池再后面的就是常量池，常量池可以理解为Class文件之中的资源仓库，我们前面提到过，Java运行时内存区域里有一块方法区，方法区里面有一个运行时常量池，Class文件的这部分数据，会在运行时被加载到方法区的运行时常量池中。常量池中主要存放两大类常量：字面量和符号引用。『字面量』比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。而『符号引用』则属于编译原理方面的概念，包括了下面三类常量： 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符 先放一段代码 1234567public class TestClass &#123; private int m; public int inc() &#123; return m + 1; &#125;&#125; 我们用javap命令来看一下编译后的class文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960~ javap -verbose TestClassCompiled from &quot;TestClass.java&quot;public class clazz.TestClass minor version: 0 major version: 52 flags: ACC\_PUBLIC, ACC\_SUPERConstant pool: #1 = Methodref #4.#18 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Fieldref #3.#19 // clazz/TestClass.m:I #3 = Class #20 // clazz/TestClass #4 = Class #21 // java/lang/Object #5 = Utf8 m #6 = Utf8 I #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 LocalVariableTable #12 = Utf8 this #13 = Utf8 Lclazz/TestClass; #14 = Utf8 inc #15 = Utf8 ()I #16 = Utf8 SourceFile #17 = Utf8 TestClass.java #18 = NameAndType #7:#8 // &quot;&lt;init&gt;&quot;:()V #19 = NameAndType #5:#6 // m:I #20 = Utf8 clazz/TestClass #21 = Utf8 java/lang/Object&#123; public clazz.TestClass(); descriptor: ()V flags: ACC\_PUBLIC Code: stack=1, locals=1, args\_size=1 0: aload\_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 11: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lclazz/TestClass; public int inc(); descriptor: ()I flags: ACC\_PUBLIC Code: stack=2, locals=1, args\_size=1 0: aload\_0 1: getfield #2 // Field m:I 4: iconst\_1 5: iadd 6: ireturn LineNumberTable: line 15: 0 LocalVariableTable: Start Length Slot Name Signature 0 7 0 this Lclazz/TestClass;&#125;SourceFile: &quot;TestClass.java&quot; 看看常量池里的内容： Utf8就是UTF-8编码的字符串，Class、Methodref和Fieldref则是符号引用。符号引用后面的编号最终也指向了字符串表示他们的值。 访问标志常量池结束后，紧接着2个字节代表访问标志(access_flag)。包括这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final。上面的flags中的值是flags: ACC_PUBLIC, ACC_SUPER表示这个类是public的。 描述符这里说一下方法和字段的描述符。基本类型是取首字母的大写基本上。例如byte就是B,有3个特殊的，long是J，boolean是Z，V是void。L表示对象（例如Ljava/lang/String）。对数组而言，每一维度将使用一个前置的“[”字符来描述。 如定义一个为“java.lang.String[][]”类型的二维数组，将被记录为“[[Ljava/lang/String”。 描述方法的时候，是先参数列表，后返回值。参数列表在小括号“()”内。例如()V表示0个参数，返回值为void，int test(int[] i, char c)的描述符为([IC)I。 字节码指令集aload_0、iconst_1之类的都是字节码指令，下面将字节码操作按用途分为9类，按照分类介绍一下。 加载和存储指令加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输： 将一个局部变量加载到操作栈：iload、iload_、lload、lload_、fload、fload_、dload、dload_、aload、aload_ 将一个数字从操作数栈存储到局部变量表：istore、istore_、lstore、lstore_、fstore、fstore_、dstore、dstore_、astore、astore_ 将一个常量加载到操作栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_、lconst_、fconst_、dconst_ 扩充局部变量表的访问索引的指令：wide。 存储数据的操作数栈和局部变量表主要就是由加载和存储指令进行操作，除此之外，还有少量指令，如访问对象的字段或数组元素的指令也会向操作数栈传输数据。上面有尖括号的表示一组指令（例如iload_，就代表了iload_0、iload_1、iload_2、iload_3），iload_0也等价于iload 0。 运算指令运算或算术指令用于堆两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。大体上算术指令可以分为两种：对整型数据进行运算的指令与堆浮点型数据进行运算的指令，无论是哪种算术指令，都使用Java虚拟机的数据类型，由于没有直接支持byte、short、char和boolean类型的算术指令，对于这类数据的运算，应使用操作int类型的指令代替。 加法指令：iadd、ladd、fadd、dadd 减法指令：isub、lsub、fsub、dsub 乘法指令：imul、lmul、fmul、dmul 除法指令：idiv、ldiv、fdiv、ddiv 求余指令：irem、lrem、frem、drem 取反指令：inge、lneg、fneg、dneg 位移指令：ishl、ishr、iushr、lshl、lshr、lushr 按位或指令：ior、lor 按位与指令：iand、land 按位异或指令：ixor、lxor 局部变量自增指令：iinc 比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp 类型转换指令类型转换指令可以将两种不同的数值类型进行相互转换，这些转换操作一般用于实现用户代码中的显式类型转换操作，或者用于处理字节指令集中数据类型相关指令无法与数据类型一一对应的问题。以下是宽化类型转换，Java虚拟机直接支持，无需指令： int类型到long、float或者double类型 long类型到float、double类型 float类型到double类型 窄化类型指令包括：i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l、和d2f。窄化类型转换可能导致不同的正负号、不同的数量级以及精度丢失的情况。 对象创建与访问指令 创建类实例的指令：new 创建数组的指令：newarray、anewarray、multianewarray 访问类字段和实例字段的指令：getfield、putfield、getstatic、putstatic 把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload 将一个操作数栈的值存储到数组元素中的指令：bastore、castore、sastore、iastore、fastore、dastore、aastore 取数组长度的指令：arraylength 检查类实例类型的指令：instanceof、checkcast 操作数栈管理指令 将操作数的组合暂定一个或两个元素出栈：pop、pop2 复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup_x2、dup_x2、dup2_x2 将栈最顶端的两个数值互换：swap 控制转移指令 条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq、和if_acmpne 复合条件分支：tableswitch、lookupswitch 无条件分支：goto、goto_w、jsr、jsr_w、ret 方法调用和返回指令 invokevirtual调用对象的实例方法 invokeinterface调用接口方法 invokespecial调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法 invokestatic调用类方法 invokedynamic指令用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法 异常处理指令throw语句由athrow指令实现，而catch语句不是由字节码来实现的，采用异常表来实现。 同步指令同步一段指令集序列在Java语言中是由synchronized语句块来表示的，在Java虚拟机的指令集中由monitorenter和monitorexit两条指令来支持。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM6-虚拟机性能监控与故障处理工具]]></title>
    <url>%2F2016%2F11%2F02%2FJVM6%2F</url>
    <content type="text"><![CDATA[给一个系统定位问题的时候，知识、经验是关键基础，数据是依据，工具是运用知识处理数据的手段。这里说的数据包括：运行日志、异常堆栈、GC日志、线程快照(threaddump/javacore文件)、堆转储快照(heapdump/hprof文件)等。经常使用适当的虚拟机监控和分析的工具可以加快我们分析数据、定位问题的速度。 JDK的命令行工具JDK的安装目录bin下提供了很多工具，这些工具其实是jdk/lib/tools.jar的包装而已。 jps：虚拟机进城状况工具jps(JVM Process Status Tool):可以列出正在运行的虚拟机进城，并显示虚拟机执行主类以及这些进城的本地虚拟机唯一ID(Local Virtual Machine IIdentifier, LVMID)，这个LVMID跟系统里的PID是一致的。jps命令格式： jsp [ options ] [ hostid ] jps执行样例： 1234~ jps -l772 15944 sun.tools.jps.Jps15547 org.jetbrains.jps.cmdline.Launcher 选项 作用 -q 只输出LVMID，省略主类的名称 -m 输出虚拟机进程启动时传递给主类main()函数的参数 -l 输出主类的全名，如果进城执行的是Jar包，输出Jar包路径 -v 输出虚拟机进城启动时JVM参数 jstat：虚拟机统计信息监视工具jstat(JVM Statistics Monitoring Tool)是用于监视虚拟机各种运行状态的命令行工具。它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾手机、JIT编译等运行数据。 jstat命令格式为： jstat [ option vmid [ interval [ s | ms ] [ count ] ] ] 对本机来说vmid就是LVMID。interval和count表示间隔和次数，省略表示只查询1次。 选项 作用 -class 监视类装载、卸载数量、总空间以及类装载所耗费的时间 -gc 监视Java堆状况，包括Eden区、两个Survivor区、、老年代、永久带等的容量、已用空间、GC时间合计等信息 -gccapacity 监视内容基本与-gc相同，但输出主要关注Java堆各个区域使用到的最大、最小空间 -gccause 与-gcutil功能一样，但是会额外输出导致上一次GC产生的原因 -gcnew 监视新生代GC状况 -gcnewcapacity 监视内容基本与-gcnew相同，但输出主要关注使用到的最大、最小空间 -gcold 监视老年代GC状况 -gcoldcapacity 监视内容基本与-gcold相同，但输出主要关注使用到的最大、最小空间 -gcpermcapacity 输出永久代使用到的最大、最小空间 -compiler 输出JIT编译器编译过的方法、耗时等信息 -printcompilation 输出已经被JIT编译的方法 jstat执行样例： 12345~ jstat -gcutil 15547 1000 3 S0 S1 E O M CCS YGC YGCT FGC FGCT GCT 74.83 0.00 2.40 0.09 98.65 95.48 2 0.013 0 0.000 0.013 74.83 0.00 2.40 0.09 98.65 95.48 2 0.013 0 0.000 0.013 74.83 0.00 2.40 0.09 98.65 95.48 2 0.013 0 0.000 0.013 这里就是每隔1000毫秒，一共执行3次，查询LVMID为15547的gcutil信息。显示空间占用总空间的百分比，S0和S1就是2个Survivor区，E是Eden，O是Old老年代，M表示MetaSpace(JDK8中的元数据区)。YGC(Young GC)和FGC(Full GC)显示的是GC的次数。FGCT和GCT是时间， jinfo：Java配置信息工具jinfo(Configuration Info for Java)的作用是实时地查看和调整虚拟机各项参数。使用jps命令的-v可以查看虚拟机启动时显式指定的参数列表，但如果想知道未被显式指定的参数的系统默认值，可以使用jinfo的-flag选项进行查询，jinfo还可以使用-sysprops选项把虚拟机进程的System.getProperties()的内容打印出来，它还有在运行期修改虚拟机参数的能力。jinfo命令格式： jinfo [ option ] pid 执行样例： 12~ jinfo -flag CMSInitiatingOccupancyFraction 15547 -XX:CMSInitiatingOccupancyFraction=-1 注意jinfo对windows只提供了-flag选项 jmap：Java内存映射工具jmap(Memory Map for Java)命令用于声称堆转储快照（一般称为heapdump或dump文件）。不用命令要想获取Java堆转储快照，可以使用“-XX:+HeapDumpOnOutOfMemoryError”参数，可以让虚拟机在OOM异常出现之后自动生成dump文件，Linux命令下可以通过kill -3发送进程退出信号也能拿到dump文件。 jmap的作用并不仅仅是为了获取dump文件，它还可以查询finalize执行队列、Java堆和永久代的详细信息，如空间使用率、当前使用的是哪种收集器等。和jinfo一样，jmap有不少功能在Windows平台下也是受限制的，除了生成dump文件的-dump选项和用于查看每个类的实例、空间占用统计的-histo选项在所有操作系统都提供之外，其余选项都只能在Linux和Solaris系统下使用。 jmap命令格式： jmap [ option ] vmid 选项 作用 -dump 生成Java堆转储快照。格式为-dump:[live, ]format=b,file=，其中live自参数说明是否只dump出存活的对象 -finalizerinfo 显示在F-Queue中等待Finalizer线程执行finalize方法的对象。只在Linux和Solaris系统下有效 -heap 显示Java堆详细信息，如使用哪种收集器、参数配置、分代状况等。只在Linux和Solaris系统下有效 -histo 显示堆中对象统计信息，包括类、实例数量、合计容量 -permstat 以ClassLoader为统计口径显示永久代内存状态。只在Linux和Solaris系统下有效 -F 当虚拟机进行对-dump选项没有响应时，可使用这个选项强制生成dump快照。只在Linux和Solaris系统下有效 jmap生成dump文件： 123~ jmap -dump:format=b,file=idea.bin 15547Dumping heap to /Users/xiaomai/idea.bin ...Heap dump file created jhat：虚拟机堆转储快照分析工具jhat(JVM Heap Analysis Tool)是与jmap搭配使用的。实际工作中很少用到，比较简陋。分析一下刚才生成的dump文件： 12345678910~ jhat idea.binReading from idea.bin...Dump file created Wed Nov 02 16:55:47 CST 2016Snapshot read, resolving...Resolving 63292 objects...Chasing references, expect 12 dots............Eliminating duplicate references............Snapshot resolved.Started HTTP server on port 7000Server is ready. jstack：Java堆栈跟踪工具jstack(Sstack Trace for Java)命令用于生成虚拟机当前时刻的线程快照(一般称为threaddump或者javacore文件)。『线程快照』就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程死锁、死循环、请求外部资源导致的长时间等待。 jstack [ option ] vmid 选项 作用 -F 当正常输出的请求不被响应时，强制输出线程堆栈 -l 除堆栈外，显示关于锁的附加信息 -m 如果调用到本地方法的时候，可以显示C/C++的堆栈 下面展示部分输出： 12345678910111213141516171819~ jstack -l 155472016-11-02 17:36:52Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.31-b07 mixed mode):"Attach Listener" #13 daemon prio=9 os_prio=31 tid=0x00007f9492316000 nid=0x3f0b waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE Locked ownable synchronizers: - None"NettythreadDeathWatcher-2-1" #12 daemon prio=1 os_prio=31 tid=0x00007f9491346800 nid=0x5103 waiting on condition [0x00007000061e2000] java.lang.Thread.State: TIMED_WAITING (sleeping) at java.lang.Thread.sleep(Native Method) at io.netty.util.ThreadDeathWatcher$Watcher.run(ThreadDeathWatcher.java:147) at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:145) at java.lang.Thread.run(Thread.java:745) Locked ownable synchronizers: - None JDK可视化工具jdk/bin下还有两个可视化工具。 JConsole：Java监视与管理平台VisualVM：多合一故障处理工具是到目前为止随JDK发布的功能最为强大的运行监视和故障处理工具，除了最基本的运行监视、 故障处理外，还有性能分析的功能，且十分强大。Visual VM还有一个很大的优点，它对应用程序的实际性能影响很小，使得它可以直接应用在生产环境中。VisualVM需要安装一些插件，才能强大的使用，否则就跟没有安装软件的操作系统一样。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM5-内存分配与回收策略]]></title>
    <url>%2F2016%2F11%2F01%2FJVM5%2F</url>
    <content type="text"><![CDATA[内存分配之前讲了垃圾回收器体系以及运作原理，现在来看看对象内存分配那点事儿。对象的内存分配，往大方向讲就是在堆上分配，对象主要分配在新生代的Eden区上，也可能直接分配在老年代中，并不固定，取决于使用的哪一种垃圾收集器以及虚拟机参数设置。 对象优先在Eden分配大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机会发一起一次Minor GC。不同的垃圾收集器组合对于对象的分配是有影响的，我们这里都是测试在Serial+SerialOld的收集器组合下测试的代码。下面的代码，-Xms20M -Xmx20M -Xmn10M三个参数限制了Java堆大小为20M，不可扩展，分给新生代10M，剩下10M分给老年代，-XX:SurvivorRatio=8定义了Eden区与一个Survivor区的空间比例是8:1,-XX:+UseSerialGC参数指定Serial垃圾收集器 12345678910111213141516/** * Created by YangFan on 2016/11/1 下午3:34. * &lt;p/&gt; * VM 参数: -verbose:gc -XX:+PrintGCDetails -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:UseSerialGC */public class EdenGC &#123; private static final int _1MB = 1024 * 1024; public static void main(String[] args) &#123; byte[] allocation1 = new byte[2 * _1MB]; byte[] allocation2 = new byte[2 * _1MB]; byte[] allocation3 = new byte[2 * _1MB]; // 发生一次MinorGC byte[] allocation4 = new byte[4 * _1MB]; &#125;&#125; GC输出： 12345678910[GC (Allocation Failure) [DefNew: 7643K-&gt;517K(9216K), 0.0078067 secs] 7643K-&gt;6661K(19456K), 0.0078482 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] Heap def new generation total 9216K, used 4750K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000) eden space 8192K, 51% used [0x00000007bec00000, 0x00000007bf0223b8, 0x00000007bf400000) from space 1024K, 50% used [0x00000007bf500000, 0x00000007bf581668, 0x00000007bf600000) to space 1024K, 0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000) tenured generation total 10240K, used 6144K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000) the space 10240K, 60% used [0x00000007bf600000, 0x00000007bfc00030, 0x00000007bfc00200, 0x00000007c0000000) Metaspace used 3062K, capacity 4494K, committed 4864K, reserved 1056768K class space used 333K, capacity 386K, committed 512K, reserved 1048576K 我们可以看到eden space是8M，前面3个对象都分配到了eden区，在分配allocation4的时候，eden区已经不够了，于是发生了一次Minor GC，但是3个对象都是存活的，并且无法放进Survivor(from space)区，所以通过分配担保机制转移到了老年代去。然后4M的allocation4分配进了Eden区。 大对象直接进入老年代虚拟机提供了一个-XX:PretenureSizeThreshold参数，大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区以及两个Survivor区之间发生大量的复制（新生代采用复制算法）。 -XX:PretenureSizeThreshold只在Serial和ParNew两款收集器有效。 12345678910111213141516/** * Created by YangFan on 2016/11/1 下午3:34. * &lt;p/&gt; * VM 参数: -verbose:gc -XX:+PrintGCDetails -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 */public class EdenGC &#123; private static final int _1MB = 1024 * 1024; public static void main(String[] args) &#123; byte[] allocation1 = new byte[2 * _1MB]; byte[] allocation2 = new byte[2 * _1MB]; byte[] allocation3 = new byte[2 * _1MB]; // 发生一次MinorGC byte[] allocation4 = new byte[4 * _1MB]; &#125;&#125; 运行结果： 123456789Heap def new generation total 9216K, used 1655K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000) eden space 8192K, 20% used [0x00000007bec00000, 0x00000007bed9de40, 0x00000007bf400000) from space 1024K, 0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000) to space 1024K, 0% used [0x00000007bf500000, 0x00000007bf500000, 0x00000007bf600000) tenured generation total 10240K, used 4096K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000) the space 10240K, 40% used [0x00000007bf600000, 0x00000007bfa00010, 0x00000007bfa00200, 0x00000007c0000000) Metaspace used 2994K, capacity 4494K, committed 4864K, reserved 1056768K class space used 324K, capacity 386K, committed 512K, reserved 1048576K 看到对象超过了3M，直接进入了tenured generation(老年代)。 长期存活的对象将进入老年代对象在Eden区每gc留下来一次(大小可复制到Survivor区中)，年龄+1，默认是15岁后移到老年代。这个阀值可以通过-XX:MaxTenuringThreshold设置。 123456789101112131415161718192021/** * Created by YangFan on 2016/11/2 下午13:58. * &lt;p/&gt; * 1岁后直接进入老年代 * * VM参数：-verbose:gc -XX:+PrintGCDetails -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+UseSerialGC -XX:MaxTenuringThreshold=1 */public class TenuringThresholdTest &#123; private static final int _1MB = 1024 * 1024; public static void main(String[] args) &#123; byte[] allocation1 = new byte[_1MB / 4]; byte[] allocation2 = new byte[4 * _1MB]; // Eden区放不下了，发起第一次GC，allocation1年龄+1，allocation2因为无法放入Survivor区通过分配担保机制提前进入老年代，allocation3进入新生代Eden区 byte[] allocation3 = new byte[4 * _1MB]; allocation3 = null; // 发起第二次GC，allocation3被回收，allocation1年龄过大进入老年代，allocation4进入Eden区 byte[] allocation4 = new byte[4 * _1MB]; &#125;&#125; 运行结果： 1234567891011[GC (Allocation Failure) [DefNew: 5843K-&gt;783K(9216K), 0.0062294 secs] 5843K-&gt;4879K(19456K), 0.0062786 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] [GC (Allocation Failure) [DefNew: 4961K-&gt;0K(9216K), 0.0018562 secs] 9057K-&gt;4867K(19456K), 0.0018840 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap def new generation total 9216K, used 4178K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000) eden space 8192K, 51% used [0x00000007bec00000, 0x00000007bf014930, 0x00000007bf400000) from space 1024K, 0% used [0x00000007bf400000, 0x00000007bf400228, 0x00000007bf500000) to space 1024K, 0% used [0x00000007bf500000, 0x00000007bf500000, 0x00000007bf600000) tenured generation total 10240K, used 4866K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000) the space 10240K, 47% used [0x00000007bf600000, 0x00000007bfac0ae8, 0x00000007bfac0c00, 0x00000007c0000000) Metaspace used 3103K, capacity 4494K, committed 4864K, reserved 1056768K class space used 338K, capacity 386K, committed 512K, reserved 1048576K 为了适应不同程序的内存状况，Survivor空间中相同年龄的所有对象大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到“-XX:MaxTenuringThreshold”设置要求的年龄。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM4-垃圾收集器]]></title>
    <url>%2F2016%2F10%2F31%2FJVM4%2F</url>
    <content type="text"><![CDATA[哪些内存需要回收？程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭，方法或者线程结束的时候内存自然就跟着回收了，所以不需要考虑过多回收的问题。而Java堆和方法区就不一样了，这部分内存的分配和回收都是动态的。 Java堆内存回收因为堆就是放对象的地方，要回收内存，首先要知道哪些对象是不可能再被任何途径使用的 引用计数法这个算法的实现是：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器+1，当引用失效时，计数器-1。Object-C就是使用的这种方式，Java没有选用引用计数算法来管理内存，因为它很难解决对象之间相互循环引用的问题。例子如下 123456789101112131415161718192021222324252627/** * Created by YangFan on 2016/10/31 下午3:48. * &lt;p/&gt; * 虚拟机参数：-verbose:gc */public class ReferenceCountingGC &#123; public Object instance = null; private static final int _1MB = 1024 * 1024; /** * 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否被回收过 */ private byte[] bigSize = new byte[2 * _1MB]; public static void main(String[] args) &#123; ReferenceCountingGC objA = new ReferenceCountingGC(); ReferenceCountingGC objB = new ReferenceCountingGC(); objA.instance = objB; objB.instance = objA; objA = null; objB = null; System.gc(); &#125;&#125; 运行结果 12[GC (System.gc()) 7440K-&gt;632K(125952K), 0.0012069 secs][Full GC (System.gc()) 632K-&gt;520K(125952K), 0.0058047 secs] 看到632K-&gt;520K，意味着两个对象相互引用也被回收了，侧面说明虚拟机不是通过引用计数法来判断对象是否存活的。 可达性分析法这个算法的基本思路是通过一系列的称为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连(从GC Roots到这个对象不可达)时，则证明此对象是不可用的。下图中object5、object6、object7虽然相互关联，但是到GC Roots是不可达的，所以他们会被回收。 在Java语言中，可用作为GC Roots的对象包括下面几种： 虚拟机栈(栈帧中的本地变量)中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI（即一般说的本地方法）引用的对象 引用JDK1.2之前，Java中引用的定义很传统：如果引用类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹，但是太过于狭隘，一个对象只有被引用或者没被引用两种状态。我们希望描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用4种，这4种引用强度依次减弱。 强引用在代码中普遍存在，类似Object obj = new Object()这类的引用，只要引用还在，垃圾收集器就不会回收 软引用是用来描述一些还有用但并非必需的对象。在系统将要发生内存溢出异常之前，将会把这些列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK1.2之后，提供了SoftReference来实现软引用。 弱引用也是用来描述非必需对象，被弱引用关联的对象只能生存到下一次GC之前。无论当前内存是够足够，都会回收掉被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用。 虚引用的存在不会对一个对象的生存时间构成影响，它的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供了PhantomReference类来实现。 对象自我拯救用可达性分析算法，对象也需要标记2次后才会被回收，第一次是发现没有与GC Roots相连的引用链接会标记一次，然后看他覆盖finalize()方法或者finalize()被调用过没有，如果finalize()不需要执行，就直接被回收了，如果需要执行，稍后GC会进行第二轮标记，对象有可能被移出回收队列(例如在finalize()中重新给自己赋值)。上代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Created by YangFan on 2016/10/31 下午4:54. * &lt;p/&gt; * 此代码演示两点： * 1. 对象可以在GC时自我拯救 * 2. 这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次。 */public class FinalizeEscapeGC &#123; public static FinalizeEscapeGC SAVE_HOOK = null; public void isAlive() &#123; System.out.println("yes, i am still alive :)"); &#125; @Override protected void finalize() throws Throwable &#123; super.finalize(); System.out.println("finalize method executed!"); FinalizeEscapeGC.SAVE_HOOK = this; &#125; public static void main(String[] args) throws InterruptedException &#123; SAVE_HOOK = new FinalizeEscapeGC(); // 对象第一次成功拯救自己 SAVE_HOOK = null; System.gc(); // 因为finalize方法的优先级很低，所以暂停了0.5秒等待它执行 TimeUnit.MILLISECONDS.sleep(500); if (SAVE_HOOK != null) &#123; SAVE_HOOK.isAlive(); &#125;else &#123; System.out.println("no, i am dead :( "); &#125; // 下面代码一样，但是这次失败了，因为finalize只执行一次 SAVE_HOOK = null; System.gc(); // 因为finalize方法的优先级很低，所以暂停了0.5秒等待它执行 TimeUnit.MILLISECONDS.sleep(500); if (SAVE_HOOK != null) &#123; SAVE_HOOK.isAlive(); &#125;else &#123; System.out.println("no, i am dead :( "); &#125; &#125;&#125; 运行结果 123finalize method executed!yes, i am still alive :)no, i am dead :( 方法区回收Java虚拟机规范中说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集性价比一般比较低。HotSpot VM永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。判断一个倡廉是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是“无用的类”： 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。 加载该类的ClassLoader已经被回收。 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载功能，以保证方法区不会溢出。 垃圾回收算法下面介绍几种垃圾回收算法的思想及发展过程。 标记-清除算法最基础的收集算法是标记-清除(Mark-Sweep)算法，，如同它的名字一样，算法分为标记和清除两个阶段：首先标记处所有需要回收的对象，在标记完成后统一回收所有被标记的对象。（标记过程已经介绍过了）。这种算法主要有两个不足： 一个是效率问题，标记和清除两个过程的效率都不高 另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行中需要分配较大对象时对象的创建，无法找到足够的连续内存而不得不提前出发另一次垃圾收集动作。标记-清除算法的执行过程如图：。 复制算法复制算法是为了解决效率问题而出现的，它将可用的内存分为两块，每次只用其中一块，当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已经使用过的内存空间一次性清理掉。这样每次只需要对整个半区进行内存回收，内存分配时也不需要考虑内存碎片等复杂情况，只需要移动指针，按照顺序分配即可。复制算法的执行过程如图： 只是这个算法代价太高，内存缩小为原来的一半，现在商用虚拟机都采用这种算法来回收“新生代”，IBM研究表明新生代98%的对象“朝生夕死”，所以不需要按1:1来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代可用内存空间为整个新生代容量的90%，只有10%的内存会被“浪费”。我们没有办法保证每次回收都只有不多余10%的对象存活，所以如果Survivor空间不够用的时候，这些对象将直接通过分配担保机制进入老年代。 标记-整理算法复制手机算法在对象存活率较高时就要进行较多的复制操作，效率会变低，如果对象存活率太高，还需要额外的空间进行分配担保，所以老年代一般不能直接用这种算法。标记-整理算法是先标记对象，让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。如图： 分代收集算法概括一下Java内存的布局：当前的商业虚拟机垃圾收集都采用“分代收集”算法，把Java堆分为新生代和老年代。在新生代中，垃圾收集时都有大批对象死去，只有少量存活，只需复制少量存活的对象成本低。老年代对象存活率高、没有额外的空间进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。 垃圾收集器垃圾收集器是内存回收的具体实现，JDK1.7之后的HotSpot虚拟机包含的收集器如下图所示： 上图展示了7种不作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。 Serial收集器Serial收集器是一个单线程的收集器，在进行垃圾收集的时候，会暂停其他所有的工作线程，直到它收集结束。新生代采用复制算法，老年代采取标记-整理算法。虽然它会暂停用户的工作线程似乎显得很不能接受，不过它仍然是Client模式下虚拟机的默认新生代收集器，因为它简单而高效，收集几十兆内存停顿时间可以控制在几十毫秒，这是可以接受的。 ParNew收集器ParNew收集器是Serial收集器的多线程版本，它是运行在Server模式下虚拟机中首选的新生代收集器。有个重要的原因是，除了Serial收集器，目前只有它能与CMS收集器配合工作。(CMS是HotSpot在JDK1.5推出的第一款真正意义上的老年代并发收集器，第一次实现了垃圾收集线程基本上与用户线程同时工作–意思就是几乎不会暂停用户的工作线程)。ParNew收集器默认开启的收集线程数与CPU数量相同，与Serial相比，CPU数量越多，它的效果才越好。在CPU数量非常多的情况下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。 Parallel Scavenge收集器Parallel Scavenge收集器是一个使用复制算法的新生代收集器。它的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量。吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)，假如虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。高吞吐量可以高效率的运用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数。Parallel Scavenge收集器还有个参数-XX:+UseAdaptiveSizePolicy值得关注，这个参数打开后虚拟机会根据当前系统的运行情况动态调整新生代大小、Eden与Survivor区的比例、晋升老年代对象年龄，以提供最合适的停顿时间或者最大的吞吐量，这种调节方式成为GC自适应调节策略。如果我们不太了解手工优化，交给虚拟机区去优化是个不错的选择。 Serial Old收集器Serial Old是Serial收集器的老年代版本，它是单线程收集器，使用标记-整理算法。这个收集器主要也是在Client模式下的虚拟机使用。 Parallel Old收集器Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法。由于Parallel Scavenge无法与CMS配合工作，Serial Old在服务端应用上又不给力，JDK1.6后Parallel Old的发布才有了Parallel Scavenge+Parallel Old的应用组合，适合注重吞吐量以及CPU资源敏感的场合。 CMS收集器CMS收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器是基于标记-清除算法实现的。CMS非常优秀但是有3个缺点： 占用CPU资源 并发收集会产生浮动垃圾(收集的同时产生的新垃圾) 内存空间碎片问题 G1收集器G1是一款面向服务端应用的垃圾收集器，是当今收集器技术发展的最前沿成果之一，随JDK1.7 HotSpot发布。G1的目标是替换掉CMS收集器，特点如下： 并行(多线程)+并发(与用户线程同时工作) 分代收集 空间整合(不会产生空间碎片) 可预测的停顿 在G1收集器之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1收集器不再是这样，使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region的集合。 G1收集器跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也是Garbage-First名称的由来）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM3-内存溢出异常实战]]></title>
    <url>%2F2016%2F10%2F31%2FJVM3%2F</url>
    <content type="text"><![CDATA[在Java虚拟机规范的描述中，除了程序计数器，其他几个运行时区域都有发生OutOfMemoryError异常的可能。本文有两个目的： 通过代码验证Java虚拟机规范中描述的各个运行时区域存储的内容。 希望我们在工作中遇到问题的时候能迅速判断是哪个区域的内存溢出，知道什么样的代码会导致这些区域溢出，以及出现这些异常后该如何处理。 这个图展示了如何在Idea中设置VM参数。 Java堆异常Java堆用于储存对象实例，只要不断地创建对象且对象不被回收，那么在对象数量到达最大堆的容量限制后就会产生OOM。 1234567891011121314151617181920/** * Created by YangFan on 2016/10/31 下午1:34. * &lt;p/&gt; * 设置堆大小为20m，不可扩展(堆的最小值-Xms参数和最大值-Xmx参数设置为一样可避免堆自动扩展) * VM参数：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError */public class HeapOOM &#123; static class OOMObject &#123; &#125; public static void main(String[] args) &#123; List&lt;OOMObject&gt; list = new ArrayList&lt;&gt;(); while (true) &#123; list.add(new OOMObject()); &#125; &#125;&#125; 结果如下 1234java.lang.OutOfMemoryError: Java heap spaceDumping heap to java_pid56046.hprof ...Heap dump file created [27956110 bytes in 0.186 secs]Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space 这个问题很常见，根据错误提示可以定位到代码，分清楚是内存泄露还是内存溢出。如果是内存泄露，找出GC无法回收的对象代码位置。如果不存在泄露，就是说内存中的对象确实都还必须存活着，应当检查一下虚拟机的堆参数(-Xms和-Xmx)，代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。 虚拟机栈和本地方法栈溢出由于HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说-Xoss(设置本地方法栈大小)是无效的，栈容量只由-Xss参数设置。关于虚拟机栈和本地方法栈，在虚拟机规范中描述了两种异常： 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。 123456789101112131415161718192021222324252627/** * Created by YangFan on 2016/10/31 下午2:06. * &lt;p/&gt; * 不断地递归调用导致栈深度增加 * VM参数：-Xss128k * */public class JavaVMStackSOF &#123; private int stackLength = 1; public void stackLength() &#123; stackLength++; stackLength(); &#125; public static void main(String[] args) &#123; JavaVMStackSOF javaVMStackSOF = new JavaVMStackSOF(); try &#123; javaVMStackSOF.stackLength(); &#125; catch (Throwable e) &#123; System.out.println("stack length:" + javaVMStackSOF.stackLength); throw e; &#125; &#125;&#125; 运行结果 123stack length:29460Exception in thread &quot;main&quot; java.lang.StackOverflowError at oom.JavaVMStackSOF.stackLength(JavaVMStackSOF.java:19) 在单线程下，无论是栈帧太大，还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverFlow异常。可以通过不断创建线程的方式产生内存溢出异常，不过这个异常与栈容量大小没有什么关系，因为不断创建线程，每个线程分配的容量越大，那么总共可产生线程数量就越小，就越容易出现OOM。这个只能通过减少最大堆内存(留给栈分配的内存变大)和减少栈容量来换取更多的线程。 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Created by YangFan on 2016/10/31 下午2:18. * &lt;p/&gt; * 不断创建线程导致内存溢出 * VM参数：-Xss2M */public class JavaVMStackOOM &#123; private int count = 0; public void stackLeakByThread() &#123; while (true) &#123; Thread thread = new Thread() &#123; @Override public void run() &#123; try &#123; count++; TimeUnit.SECONDS.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; thread.start(); &#125; &#125; // 不要在Windows下运行这段代码，可能会假死 public static void main(String[] args) &#123; JavaVMStackOOM javaVMStackOOM = new JavaVMStackOOM(); try &#123; javaVMStackOOM.stackLeakByThread(); &#125; catch (Throwable e) &#123; System.out.println("thread count: " + javaVMStackOOM.count); throw e; &#125; &#125;&#125; 运行结果 123thread count: 2028Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create new native thread at java.lang.Thread.start0(Native Method) 方法区和运行时常量池溢出前面提到过，运行时常量池也是方法区的一部分，并且在JDK8 HotSpot中去掉了永久代。String.intern()是一个Native方法，它的作用是：如果常量池中有一个String对象的字符串就返回池中的这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中去，并且返回此String对象的引用。 12345678910111213141516171819202122/** * Created by YangFan on 2016/10/31 下午3:01. * &lt;p/&gt; * * VM参数-XX:PermSize=10M -XX:MaxPermSize=10M * * 对于JDK 1.6 HotSpot而言，方法区=永久代，这里看到OutOfMemoryError的区域是“PermGen space”，即永久代，那其实也就是方法区溢出了 * * JDK7这个例子会一直循环，因为JDK 7里String.intern生成的String不再是在perm gen分配,而是在Java Heap中分配 * JDK8移除了永久代（Permanent Generation ），替换成了元空间（Metaspace）内存分配模型 * 设置虚拟机参数-XX:MaxMetaspaceSize=1m，可出现OutOfMemoryError: Metaspace 溢出 */public class RuntimeConstantPoolOOM &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); int i = 0; while (true) list.add(String.valueOf(i++).intern()); &#125;&#125; 本机直接内存溢出这个地方的溢出，特征是发现OOM后Dump文件很小，而程序中间接或直接使用了NIO，那就考虑检查一下是不是这个原因。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM2-Java内存区域]]></title>
    <url>%2F2016%2F10%2F28%2FJVM2%2F</url>
    <content type="text"><![CDATA[#Java内存区域 下面从概念上介绍Java虚拟机内存的各个区域，讲解这些区域的作用、服务对象以及其中可能产生的问题，这是翻越虚拟机内存管理这堵围墙的第一步。 运行时数据区域Java虚拟机在执行Java程序的过程中会把她所管理的内存划分为若干个不同的数据区域，包含以下几个运行时数据区域。 注意看图上分为线程共享数据区域和线程私有数据区域。 线程私有数据区程序计数器程序计数器(Program Counter Register)是比较小的一块内存空间,在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 一个处理器一时间只会执行一条线程的指令，因此线程切换后为了能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为线程私有的内存。 Java虚拟机栈与程序计数器一样，Java虚拟机栈(Java Virtual Machine Stacks)也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈入栈到出栈的过程。在这个区域中，如果我们写一个回调的死循环可能会抛出StackOverFlow异常，或者是在区域大小动态扩展的时候申请不到足够的内存，也会抛出OutOfMemoryError异常。 本地方法栈与虚拟机栈类似，不过是为Native方法服务的。虚拟机规范中没有强制的规定，HotSpot VM直接把本地方法栈和虚拟机栈合二为一了。 线程共享数据区Java堆对于大多数应用来说，Java堆(Java Heap)是Java虚拟机所管理的内存中最大的一块，此内存区域的唯一目的就是存放对象实例。由于现代GC基本都采用分代收集算法，所以Java堆还可以细分为：新生代和老年代；再细致一点还有Eden空间、From Survivor空间、To Survivor空间等。这个区域如果满了，会抛出OutOfMemoryError异常。 方法区方法区(Method Area)用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。在Hotspot VM中，这个区域被称为“永久代”(Permanent Generation)，其他虚拟机则不存在永久代。并且使用永久代来实现方法区，容易遇到内存溢出问题(-XX:MaxPermSize)，所以JDK8的HotSpot VM去掉“永久代”，以“元数据区”（Metaspace）替代之。在JDK7的HotSpot中，原本放在永久代的字符串常量池也被移除。这个区域如果满了，会抛出OutOfMemoryError异常。 运行时常量池运行时常量池（Runtime Constant Pool）是方法区的一部分，图上面没有。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。那么运行时常量池相对Class文件常量池另外一个重要特征是动态性，并非Class文件中常量池的内容才能进入方法区运行时常量池，例如String的intern()方法就能将新的常量放入池中。常量池如果满了，会抛出OutOfMemoryError异常。 直接内存直接内存(Direct Memory)并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。JDK1.4加入的NIO，引入了基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这个堆外内存虽不会受堆大小的限制，但是受本机总内存（RAM+SWAP）大小以及处理器寻址空间的限制，所以可能会出现OutOfMemoryError异常。 对象探秘对象创建在语言层面上，创建对象只是一个new关键字而已，而在虚拟机中创建一个对象的过程呢？ 当虚拟机遇到一条new指令，先检查指令参数能否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过，如果没有，就先执行相应的类加载过程。 在类加载检查通过后，虚拟机为新生类分配内存(对象所需内存大小在类加载完成后已经确定)，为对象分配空间就是把一块确定大小的内存从Java堆中划分出来。 如果Java堆内存是规整的，使用指针碰撞方式。意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。 如果Java堆内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。如果垃圾收集器选择的是CMS这种基于标记-清除算法的，虚拟机采用这种分配方式。 除了可用空间外，还有个问题是在虚拟机中创建并发创建对象也不是线程安全的，有两个方案解决这个问题： 对分配内存空间的动作进行同步处理 使用本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)，即每个线程在Java堆中预先分配一小块内存。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。虚拟机是否使用TLAB,可以通过-XX:+/-UseTLAB参数来设定。 内存分配完成，虚拟机需要将分配到的内存空间都初始化为零值。这一步保证了对象的实例字段不被赋值就可以使用对应字段的零值。 虚拟机进行必要设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的GC分代年龄信息。这些信息放在对象的对象头中。 从虚拟机角度来看一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚开始—-&lt;init&gt;方法没有执行，所有的字段都还为零。接下来执行&lt;init&gt;方法，按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。 对象的内存布局在Hotspot虚拟机中，对象在内存中存储的布局可用分为3块区域：对象头，实例数据，和对齐填充。 对象头包含2部分数据，第一部分用于存储对象自身的运行时数据(如哈希吗、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等)。第二部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，不过这跟对象访问定位的实现方式有关系，下面介绍。 实例数据就是对象真正存储的有效信息，包括从父类继承下来的。 对齐填充起占位符的作用，因为HotSpot VM的自动内存管理系统要求对象的起始地址必须的8字节的整倍数。 对象的访问定位建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象，目前主流的访问方式有使用句柄和直接指针两种。 如果使用句柄访问，Java堆中会划分一块内存来做句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。如图所示 如果使用直接指针访问，那么Java堆的对象布局中就包含了类型指针，而reference中存储的直接就是对象地址。(这种方式类型指针就在对象数据中)。HotSpot就是使用的这种方式，如图所示]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM1-Java介绍]]></title>
    <url>%2F2016%2F10%2F28%2FJVM1%2F</url>
    <content type="text"><![CDATA[今天开写JVM系列的学习笔记，书籍为周志明的《深入理解Java虚拟机》 走进JavaJava技术体系Sun官方所定义的技术体系包括以下几个组成部分。 Java程序设计语言 各种硬件平台上的Java虚拟机 Class文件格式 Java API类库 来自商业机构和开源社区的第三方Java类库 我们把Java程序设计语言、Java虚拟机、Java API类库这三部分统称为JDK，JDK是用于支持Java程序开发的最小环境。Java API类库中的Java SE API子集和Java虚拟机这两部分统称为JRE，JRE是支持Java程序运行的标准环境。下图展示了Java技术体系所包含的内容，以及JDK和JRE所覆盖的范围。 Java发展史1999年HotSpot虚拟机作为JDK1.2附加程序发布，成为JDK1.3及之后版本的Sun JDK默认虚拟机。2002年5月8日，JDK1.4发布，新特性包括，正则表达式、异常链、NIO、日志类、XML解析器和XSLT转换器等。2004年2月13日，JDK1.5发布，JDK1.5在Java语法易用性上做出了非常大的改进。例如，自动装箱、泛型、动态注解、枚举、可变长参数、循环遍历(foreach循环)等语法特性，在虚拟机和API层面上，这个版本改进了Java的内存模型(Java Memory Model, JMM)，提供了java.util.concurent并发包等。2006年12月11日，JDk1.6发布，JDK1.6的改进包括：提供动态语言支持，提供编译API和微型HTTP服务器API等。这个版本对Java虚拟机内部做了大量改进，包括锁与同步、垃圾收集、类加载等方面的算法。2011年7月，JDK7发布，由于Sun公司被Oracle收购等各种原因，原计划在JDK7发布的Lambda，Jigsaw和Coin延迟，JDK7的主要改进包括：提供新的G1收集器，加强对非Jaa语言的调用支持，升级类加载架构等。2014年3月19日，JDK8发布，JDK8改进比较多，最大的改进是Lambda表达式（以及因之带来的函数式接口，很多原有类都做了变更，但能够与以往版本兼容，堪称奇功！），还有Stream API流式处理，joda-time等等一些新特性。但有一些本来计划发布的大变更，比如模块化等推迟到了JDK9中。 Java虚拟机在JDK1.3之后，HotSpot VM成了Sun JDK和OpenJDK中所带的默认虚拟机。HotSpot VM的热点代码探测能力可以通过执行计数器找出最具有编译价值的代码，然后通知JIT编译器以方法单位进行编译。如果一个方法被频繁调用，或方法中有效循环次数很多，将会分别触发标准编译和OSR(栈上替换)编译动作。通过编译器与解释器恰当地协同工作，可以在最优化的程序响应时间与最佳执行性能中取得平衡，而且无须等待本地代码输出才能执行程序，即时编译的时间压力也相对减小，这样有助于引入更多的代码优化技术没输出质量更高的本地代码。我们可以在命令行里执行java -version看看本机上的虚拟机。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java获取URL上的参数]]></title>
    <url>%2F2016%2F07%2F21%2FJava%E8%8E%B7%E5%8F%96URL%E4%B8%8A%E7%9A%84%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[最近遇到一个需求需要在获取URL字符串上的kv键值对，我们都知道Java Web在请求是直接用request来获取值的。如果是字符串呢，就需要正则表达式来自己截取了。自己写代码是比较麻烦的，下面推荐用Guava工具包，2行代码就可以解决这个需求了。 12345private String getPara(String url, String name) &#123; String params = url.substring(url.indexOf(&quot;?&quot;) + 1, url.length()); Map&lt;String, String&gt; split = Splitter.on(&quot;&amp;&quot;).withKeyValueSeparator(&quot;=&quot;).split(params); return split.get(name);&#125; 先截取到?后面的字符串，然后再用Splitter.on(&quot;&amp;&quot;).withKeyValueSeparator(&quot;=&quot;).split(params);就轻松的解决了~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Guava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring cloud @EnableOAuth2Client]]></title>
    <url>%2F2016%2F07%2F15%2FSpring-cloudt-EnableOAuth2Client%2F</url>
    <content type="text"><![CDATA[Spring Cloud oauth2 开启客户端功能，并启用LoadBalanced 如果不添加以下配置，只添加@EnableOAuth2Client注解，spring cloud默认是在web环境下使用的AuthorizationCodeResourceDetails。 具体代码在OAuth2RestOperationsConfiguration类中。 123456789101112131415161718192021222324252627282930313233343536373839@Configuration@ConditionalOnBean(OAuth2ClientConfiguration.class)@ConditionalOnWebApplicationprotected static class SessionScopedConfiguration &#123; @Bean @ConfigurationProperties(&quot;security.oauth2.client&quot;) @Primary public AuthorizationCodeResourceDetails oauth2RemoteResource() &#123; AuthorizationCodeResourceDetails details = new AuthorizationCodeResourceDetails(); return details; &#125; @Bean public FilterRegistrationBean oauth2ClientFilterRegistration( OAuth2ClientContextFilter filter, SecurityProperties security) &#123; FilterRegistrationBean registration = new FilterRegistrationBean(); registration.setFilter(filter); registration.setOrder(security.getFilterOrder() - 10); return registration; &#125; @Configuration protected static class ClientContextConfiguration &#123; @Resource @Qualifier(&quot;accessTokenRequest&quot;) protected AccessTokenRequest accessTokenRequest; @Bean @Scope(value = &quot;session&quot;, proxyMode = ScopedProxyMode.INTERFACES) public DefaultOAuth2ClientContext oauth2ClientContext() &#123; return new DefaultOAuth2ClientContext(this.accessTokenRequest); &#125; &#125;&#125; 这个东西我也没找到在哪里可以配置，就自己在Application手动加入以下配置来使用吧。 123456789101112@Bean@Primary@LoadBalancedpublic OAuth2RestTemplate xmRestTemplate(ClientCredentialsResourceDetails xmOauth2RemoteResource) &#123; return new OAuth2RestTemplate(xmOauth2RemoteResource);&#125;@Bean@ConfigurationProperties(&quot;security.oauth2.client&quot;)public ClientCredentialsResourceDetails xmOauth2RemoteResource() &#123; return new ClientCredentialsResourceDetails();&#125;]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring cloud OAuth2RestTemplate loadBalanced]]></title>
    <url>%2F2016%2F04%2F21%2Fspring-cloud-OAuth2RestTemplate-loadBalanced%2F</url>
    <content type="text"><![CDATA[在项目中访问另一个微服务的时候我们可以这样用RestTemplate来调用其他服务: 123@Autowiredprivate RestTemplate restTemplate;RestResponse response = restTemplate.postForObject(&quot;http://user-service/user/getUser&quot;, para, User.class); 在spring cloud环境下，这个注入的restTemplate是具备了客户端负载均衡功能的，也会用到eureka服务发现功能，user-service就是服务的名称。我的项目启用了oauth2认证。spring cloud也提供了一个OAuth2RestTemplate来很方便的调用其他服务。但是在我测试的时候一直报错UnknownHost，我猜测他肯定是没有用到loadBalanced和eureka的服务发现功能。我翻遍了官方文档也没有找到相关的说明。 Google搜了大半天后，看了作者在git也讨论过这个类loadBalanced功能之类的，还翻到一个没有什么用 @LoadBalanced注解，翻了半天源码后终于在OAuth2LoadBalancerClientAutoConfiguration这样一个类中发现了一点蛛丝马迹。 1234567891011121314151617181920212223242526@Configuration@ConditionalOnClass(&#123; LoadBalancerInterceptor.class, OAuth2RestTemplate.class &#125;)@ConditionalOnBean(LoadBalancerInterceptor.class)@AutoConfigureAfter(OAuth2AutoConfiguration.class)public class OAuth2LoadBalancerClientAutoConfiguration &#123; @Configuration @ConditionalOnProperty(value = &quot;security.oauth2.resource.loadBalanced&quot;, matchIfMissing = false) protected static class UserInfoLoadBalancerConfig &#123; @Bean public UserInfoRestTemplateCustomizer loadBalancedUserInfoRestTemplateCustomizer( final LoadBalancerInterceptor loadBalancerInterceptor) &#123; return new UserInfoRestTemplateCustomizer() &#123; @Override public void customize(OAuth2RestTemplate restTemplate) &#123; List&lt;ClientHttpRequestInterceptor&gt; interceptors = new ArrayList&lt;&gt;( restTemplate.getInterceptors()); interceptors.add(loadBalancerInterceptor); restTemplate.setInterceptors(interceptors); &#125; &#125;; &#125; &#125;&#125; 可以看到，只要配置了security.oauth2.resource.loadBalanced为true，我们的OAuth2RestTemplate就具有LoadBalancer功能了。我们先在application.yml中加上这样的配置。 1234security: oauth2: resource: loadBalanced: true 然后注入这个类： 12@Autowiredprivate OAuth2RestTemplate restTemplate; 结果还是不行，一样的错误，难道这个类没有用吗，于是我在我的代码和customize方法初始化执行的时候打了2个断点，发现注入对象的根本就不是这个地方初始化使用的那个对象。又倒腾了好一会才找到，必须得注入一个bean名字为userInfoRestTemplate的对象。 123@Autowired@Qualifier(&quot;userInfoRestTemplate&quot;)private OAuth2RestTemplate restTemplate; 终于可以正常使用了，不知道为什么这个配置并没有在文档中提到，估计以后会补上这个文档的。现在spring cloud的文档有些地方跟最新的代码也表现得不太一致，特别是spring security这一块，做的时候一定要多多注意。]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-cloud OAuth2.0配置]]></title>
    <url>%2F2016%2F03%2F31%2FSpring-cloud-OAuth2-0%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[在spring cloud项目环境中配置oauth2.0认证。 http://callistaenterprise.se/blogg/teknik/2015/04/27/building-microservices-part-3-secure-APIs-with-OAuth/可以先看看这篇文章。 我花了不少时间才把这个调通，spring cloud的版本和文档也存在不一致的地方。以下所有的操作都基于Brixton.RC1搭建，须保持所有相关项目都引用此parent。否则会出现各种莫名其妙的错误。 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-parent&lt;/artifactId&gt; &lt;version&gt;Brixton.RC1&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt; https://spring.io/blog/2015/11/30/migrating-oauth2-apps-from-spring-boot-1-2-to-1-3 这篇文章显示了不同版本之间的区别。目前官网最新提供的Angel SR6和Brixton RC1，它们引用的Spring Boot版本不一样。这2个版本在Spring Security这一块改动比较大。Spring Boot1.3 移除了官方文档中提到的@EnableOAuth2Resource注解。http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_token_relay反正感觉官网提供这个文档写得不太对。 下面展示我最终正常运行的一个配置。Zuul Proxy和AuthServer，我把它们放在了同一个应用里。在pom中加入oauth2的依赖。 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;&lt;/dependency&gt; 然后是Application 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081@SpringBootApplication@EnableZuulProxy//必须添加@EnableResourceServer，Zuul才会进行Token Relay。//(查看各种源码后才发现。文档描述的@EnableOAuth2Sso根本没有什么卵用。只有//@EnableResourceServer才会加载OAuth2AuthenticationProcessingFilter)@EnableResourceServer@EnableAuthorizationServerpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125; //为什么不用自动配置。因为/oauth/check_token默认是denyAll. //必须手动设置oauthServer.checkTokenAccess("isAuthenticated()"); //才访问能验证Access Token。 @Configuration protected static class OAuthSecurityConfig extends AuthorizationServerConfigurerAdapter &#123; @Autowired private AuthenticationManager authenticationManager; @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception &#123; endpoints.authenticationManager(authenticationManager); &#125; @Override public void configure(AuthorizationServerSecurityConfigurer oauthServer) throws Exception &#123; oauthServer.checkTokenAccess("isAuthenticated()"); &#125; @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123; clients.inMemory() .withClient("clientId") .secret("secretId") .authorizedGrantTypes("authorization_code", "client_credentials") .scopes("app"); &#125; &#125; @Configuration protected static class RestSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.anonymous().disable() .sessionManagement() .sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .exceptionHandling()// .accessDeniedHandler(accessDeniedHandler()) // handle access denied in general (for example comming from @PreAuthorization// .authenticationEntryPoint(entryPointBean()) // handle authentication exceptions for unauthorized calls. .and() .authorizeRequests()// .antMatchers("/hystrix.stream/**", "/info", "/error").permitAll() .anyRequest().authenticated().and().csrf().disable(); &#125; // @Bean// @Autowired// AccessDeniedHandler accessDeniedHandler() &#123;// return new AccessDeniedExceptionHandler();// &#125;//// @Bean// @Autowired// AuthenticationEntryPoint entryPointBean() &#123;// return new UnauthorizedEntryPoint();// &#125; // 不需要权限控制的路径 @Override public void configure(WebSecurity web) throws Exception &#123; web.ignoring().antMatchers("/hystrix.stream/**", "/info", "/error"); &#125; &#125;&#125; 然后在API里同样加入依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;&lt;/dependency&gt; 在application.yml中加入以下配置: 12345678910security: oauth2: resource: token-info-uri: http://localhost:10000/oauth/check_token client: client-id: clientId client-secret: secretId user-authorization-uri: http://localhost:10000/oauth/authorize access-token-uri: http://localhost:10000/oauth/token grant-type: client_credentials Application.java中加上@EnableResourceServer 1234567891011121314151617@EnableResourceServerpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125; @Configuration protected static class RestSecurity extends WebSecurityConfigurerAdapter &#123; //不需要权限控制的URL @Override public void configure(WebSecurity web) throws Exception &#123; web.ignoring().antMatchers("/info", "/error"); &#125; &#125;&#125; 配置完了，启动应用。获取access_token。 1234567891011curl -s clientId:secretId@localhost:10000/oauth/token \ -d grant_type=client_credentials \ -d scope=app &#123; "access_token": "8265eee1-1309-4481-a734-24a2a4f19299", "token_type": "bearer", "expires_in": 43189, "scope": "app"&#125; 访问API的时候在Http Header中带上，Authorization: Bearer$access_token。即可…]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring cloud项目实践(三)]]></title>
    <url>%2F2016%2F03%2F22%2FSpring-cloud%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[持续集成配置jenkins构建项目，自动build出docker镜像，发布到docker私库中，或者从目标服务器中启动容器。 Maven的Docker插件http://www.cnblogs.com/skyblog/p/5163691.html 有讲到如何用Dockerfile构建，下面是采用Maven插件的方式构建，插件的文档在这里1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; &lt;version&gt;$&#123;docker.plugin.version&#125;&lt;/version&gt; &lt;executions&gt; &lt;!--绑定build命令到mvn package中--&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;build&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;!--绑定push命令到mvn deploy中--&gt; &lt;execution&gt; &lt;id&gt;push-image&lt;/id&gt; &lt;phase&gt;deploy&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;push&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;imageName&gt;$&#123;docker.image.prefix&#125;/$&#123;project.artifactId&#125;:$&#123;project.version&#125;&lt;/imageName&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;imageName&gt;$&#123;docker.image.prefix&#125;/$&#123;project.artifactId&#125;&lt;/imageName&gt; &lt;forceTags&gt;true&lt;/forceTags&gt; &lt;imageTags&gt; &lt;!--&lt;imageTag&gt;$&#123;project.version&#125;&lt;/imageTag&gt;--&gt; &lt;imageTag&gt;latest&lt;/imageTag&gt; &lt;/imageTags&gt; &lt;dockerDirectory&gt;$&#123;project.basedir&#125;/src/main/docker&lt;/dockerDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath&gt;/&lt;/targetPath&gt; &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt; &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; Dockerfile文件在src/main/docker/Dockerfile内容如下 123456FROM java:8VOLUME /tmpADD pin-user-0.1.0.jar app.jarRUN bash -c &apos;touch /app.jar&apos;EXPOSE 9000ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] https://spring.io/guides/gs/spring-boot-docker/ 特别解释一下ENTRYPOINT指令,docker run命令中的参数都会传递给ENTRYPOINT指令。执行docker run -d pin-user --config.host=localhost启动容器。会把–config.host加在ENTRYPOINT后面,相当于执行了java -Djava.security.egd=file:/dev/./urandom -jar /app.jar --config.host=localhost。有了这个参数后我们就能很方便的控制环境和配置文件了。 配置jenkinsjenkins中新建一个项目，配置好git后，执行目标服务器的一个shell脚本来启动容器。 然后开始构建项目，因为在pom.xml配置中绑定了docker:build到package命令中，所以会自动执行docker:build，这里遇到了一个docker命令的权限问题，jenkins抛出一个错误。1java.io.IOException: Permission denied 在jenkins所在的服务器上执行以下命令查看jenkins用户组 1id jenkins 将jenkins用户加入到docker组中。 1usermod -a -G docker jenkins 再构建，权限问题没有了，但是我又得到另外一个错误 [ERROR] Failed to execute goal com.spotify:docker-maven-plugin:0.3.258:build (default) on project pin-user: Exception caught: Error getting container 1e509efd653d0a3a942bf5ef34601305b7301d64378381614b55d3f5f88c7166 from driver devicemapper: open /dev/mapper/docker-202:33-5767218-1e509efd653d0a3a942bf5ef34601305b7301d64378381614b55d3f5f88c7166: no such file or directory 说是因为docker在centos下的存储驱动原因，我这里试试把devicemapper换成btrfs。在centos下只能选择这2种方式。 需要把docker使用的分区的文件系统换掉。这一步会镜像会被全部清除掉，记得备份镜像，因为我是测试环境，所以镜像全部丢了也无所谓。教程如下。 https://wiki.centos.org/PhilipJensen/CentOS6ConvertToBTRFS#head-c0851e0e7c9205aa8ca5616b85179b96981b24a7 1umount /dev/xvdc1 提示divice busy。下面命令把相关进程kill掉再umount 1fuser -m -v -i -k /dev/xvdc1 再执行这个命令。 1btrfs-convert /dev/xvdc1 完事后再挂载回去 1mount /dev/xvdc1 /mnt2 还是提示busy，reboot重启下，再mount。然后在/etc/sysconfig/docker加上--storage-driver btrfs参数。 1other_args=&quot;--graph=/mnt2/apps/docker --storage-driver btrfs --insecure-registry=10.168.248.36:5000&quot; 重启docker，再执行docker info就看到docker的存储驱动已经变了 启动docker容器的时候报错了，把/var/lib/docker/linkgraph.db删了因为我在/etc/sysconfig/docker修改了docker的目录。所以我这里是目录是/mnt2/apps/docker/linkgraph.db。service restart docker重启下docker即可。现在再用jenkins构建和发布就没有错误了。 启动脚本1/mnt/web/scripts/docker_run.sh 10.168.248.36:5000/pin-user 9000 "--config.profile=dev --config.host=10.168.248.36" 下面我解释一下这个启动docker容器的脚本。脚本后面跟了3个参数，一个是镜像名称，一个是端口号，一个是启动容器加在ENTRYPOINT的项目配置。先找出之前镜像对应的containerId，把它删除掉，然后再用新的镜像启动容器。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/bin/bash#defined export JAVA_HOME=/usr/java/jdk1.8.0_40/IMAGE="$1"OPTIONS=""PORT="$2"#param validateif [ $# -lt 2 ]; then echo "you must use like this : ./deploy_run.sh &lt;image&gt; &lt;port&gt; [options]" exitfiif [ "$3" != "" ]; then OPTIONS="$3"fi#拿到容器ID后kill掉并删除。delete_container()&#123; echo "the container id is $1" if [ -n "$1" ]; then echo "delete container:" $1 docker stop $1 docker rm -f $1 fi&#125;echo "&gt;&gt;&gt; Get old image $IMAGE container id"CID=$(docker ps | grep "$&#123;IMAGE&#125;" | awk '&#123;print $1&#125;')#因为jenkins每次的build的时候，如果镜像的tag没有指定，那么新的镜像build成功后，之前的镜像名称就会变成none。#所以我们找出为名字为none的就是之前的镜像。if [ ! -n "$CID" ]; then echo "get old image id" OLD_IMAGE_IDS=$(docker images --no-trunc| grep none | awk '&#123;print $3&#125;') echo $OLD_IMAGE_IDS if [ -n "$OLD_IMAGE_IDS" ]; then if [ -n $&#123;OLD_IMAGE_IDS[1]&#125; ]; then for OLD_IMAGE_ID in $OLD_IMAGE_IDS do CID=$(docker ps | grep "$&#123;OLD_IMAGE_ID:0:12&#125;" | awk '&#123;print $1&#125;') delete_container $CID done else delete_container $OLD_IMAGE_IDS fi fielse delete_container $CIDfi#启动容器echo "docker run -d -v /mnt:/mnt -p $&#123;PORT&#125;:$&#123;PORT&#125; $IMAGE $OPTIONS"docker run -d -v /mnt:/mnt -p $&#123;PORT&#125;:$&#123;PORT&#125; $IMAGE $OPTIONSecho "clean docker images"#再次清理名称为none的docker镜像。docker images --no-trunc| grep none | awk '&#123;print $3&#125;' | xargs -r docker rmi -f#清理所有已经退出的容器#docker rm `docker ps -a | grep Exited | awk '&#123;print $1&#125;'`echo "finished" 可能最好的方式还是每次用不同的tag来build镜像，不过我这里就偷懒了，等到发布到生产环境的时候再指定吧。注意到&quot;--config.profile=dev --config.host=10.168.248.36&quot;这个参数配合ENTRYPOINT就可以针对生产环境和测试环境加载不同的配置文件了。项目中的配置文件: 1234567891011spring: application: name: user cloud: config: uri: http://$&#123;config.host:192.168.99.100&#125;:8888 profile: $&#123;config.profile:dev&#125; name: userencrypt: failOnError: false 到此我们的一个基本的spring-cloud项目实践就完成了，其他特性和功能自行选择后再添加就可以了。我接下来要继续加入的模块就是使用API网关构建微服务。概念如下 http://www.infoq.com/cn/articles/construct-micro-service-using-api-gateway/]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring cloud项目实践(二)]]></title>
    <url>%2F2016%2F03%2F21%2FSpring-cloud%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[配置中心和服务注册中心我们先把配置中心和服务注册中心跑起来，这个先照着之前的教程做，很简单没什么变动。就是git仓库需要密码的话加入下面的配置就好。 1234567891011121314151617181920server: port: 8888eureka: instance: hostname: configserver client: registerWithEureka: true fetchRegistry: true serviceUrl: defaultZone: http://$&#123;config.host:192.168.99.100&#125;:8761/eureka/spring: cloud: config: server: git: uri: yourgiturl password: **** username: **** 这里的${config.host:192.168.99.100}表示没有读到config.host就用192.168.99.100这个值。 1java -jar cloud-simple-service-1.0.0.jar --config.host=localhost 这个用法就很灵活了，后面配合Dockerfile可以根据不同的环境来启动不同的配置。 微服务应用Mybatishttp://www.cnblogs.com/skyblog/p/5129603.html这篇文章讲了如何配置一个使用myabtis的项目，我们照着他的做就可以了。 Mongodb我这里说一下配置mongodb遇到的问题。首先在pom.xml中加入mongodb的依赖。因为我是用的mongodb3，spring-boot-starter-data-mongodb依赖的驱动是2.0版本的，需要修改一下，加入3.0驱动的依赖。 123456789101112131415161718192021222324&lt;!--mongo驱动版本过低--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.mongodb&lt;/groupId&gt; &lt;artifactId&gt;mongo-java-driver&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mongodb&lt;/groupId&gt; &lt;artifactId&gt;mongo-java-driver&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt;&lt;/dependency&gt;``` 不过还是认证会出错，解决方案参考下面的文章。 [http://zjumty.iteye.com/blog/2198432](http://zjumty.iteye.com/blog/2198432)照着这个文章做完依然还是有错误，所以我这里还有一些额外的改动，一共自建了3个类。首先在`Application.java`里新加上`MongoAutoConfiguration.class`，`MongoDataAutoConfiguration.class` @EnableAutoConfiguration(exclude = {DataSourceAutoConfiguration.class, MongoAutoConfiguration.class, MongoDataAutoConfiguration.class})123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185自定义的3个类如下 `MongoProperties.java` ```java@ConfigurationProperties(prefix = &quot;spring.data.mongodb&quot;)public class MongoProperties &#123; private static final int DEFAULT_PORT = 27017; /** * Mongo server host. */ private String host; /** * Mongo server port. */ private Integer port = null; /** * Mongo database URI. When set, host and port are ignored. */ private String uri = &quot;mongodb://localhost/test&quot;; /** * Database name. */ private String database; /** * Authentication database name. */ private String authenticationDatabase; /** * GridFS database name. */ private String gridFsDatabase; /** * Login user of the mongo server. */ private String username; /** * Login password of the mongo server. */ private char[] password; public String getHost() &#123; return this.host; &#125; public void setHost(String host) &#123; this.host = host; &#125; public String getDatabase() &#123; return this.database; &#125; public void setDatabase(String database) &#123; this.database = database; &#125; public String getAuthenticationDatabase() &#123; return this.authenticationDatabase; &#125; public void setAuthenticationDatabase(String authenticationDatabase) &#123; this.authenticationDatabase = authenticationDatabase; &#125; public String getUsername() &#123; return this.username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public char[] getPassword() &#123; return this.password; &#125; public void setPassword(char[] password) &#123; this.password = password; &#125; public void clearPassword() &#123; if (this.password == null) &#123; return; &#125; for (int i = 0; i &lt; this.password.length; i++) &#123; this.password[i] = 0; &#125; &#125; public String getUri() &#123; return this.uri; &#125; public void setUri(String uri) &#123; this.uri = uri; &#125; public Integer getPort() &#123; return this.port; &#125; public void setPort(Integer port) &#123; this.port = port; &#125; public String getGridFsDatabase() &#123; return this.gridFsDatabase; &#125; public void setGridFsDatabase(String gridFsDatabase) &#123; this.gridFsDatabase = gridFsDatabase; &#125; public String getMongoClientDatabase() &#123; if (this.database != null) &#123; return this.database; &#125; return new MongoClientURI(this.uri).getDatabase(); &#125; public MongoClient createMongoClient(MongoClientOptions options) throws UnknownHostException &#123; try &#123; if (hasCustomAddress() || hasCustomCredentials()) &#123; if (options == null) &#123; options = MongoClientOptions.builder().build(); &#125; List&lt;MongoCredential&gt; credentials = null; if (hasCustomCredentials()) &#123; String database = this.authenticationDatabase == null ? getMongoClientDatabase() : this.authenticationDatabase; credentials = Arrays.asList(MongoCredential.createScramSha1Credential( this.username, database, this.password)); &#125; String host = this.host == null ? &quot;localhost&quot; : this.host; int port = this.port == null ? DEFAULT_PORT : this.port; return new MongoClient(Arrays.asList(new ServerAddress(host, port)), credentials, options); &#125; // The options and credentials are in the URI return new MongoClient(new MongoClientURI(this.uri, builder(options))); &#125; finally &#123; clearPassword(); &#125; &#125; private boolean hasCustomAddress() &#123; return this.host != null || this.port != null; &#125; private boolean hasCustomCredentials() &#123; return this.username != null &amp;&amp; this.password != null; &#125; private MongoClientOptions.Builder builder(MongoClientOptions options) &#123; MongoClientOptions.Builder builder = MongoClientOptions.builder(); if (options != null) &#123; builder.alwaysUseMBeans(options.isAlwaysUseMBeans()); builder.connectionsPerHost(options.getConnectionsPerHost()); builder.connectTimeout(options.getConnectTimeout()); builder.cursorFinalizerEnabled(options.isCursorFinalizerEnabled()); builder.dbDecoderFactory(options.getDbDecoderFactory()); builder.dbEncoderFactory(options.getDbEncoderFactory()); builder.description(options.getDescription()); builder.maxWaitTime(options.getMaxWaitTime()); builder.readPreference(options.getReadPreference()); builder.socketFactory(options.getSocketFactory()); builder.socketKeepAlive(options.isSocketKeepAlive()); builder.socketTimeout(options.getSocketTimeout()); builder.threadsAllowedToBlockForConnectionMultiplier( options.getThreadsAllowedToBlockForConnectionMultiplier()); builder.writeConcern(options.getWriteConcern()); &#125; return builder; &#125;&#125; 这里跟上面的文章是一样的，就是MongoCredential.createScramSha1Credential这一句不一样而已。而且MongoCredential.createScramSha1Credential这个方法是在3.0的驱动里面才有的。 然后是MongoConfiguration.java 123456789101112131415161718192021222324@Configuration@EnableConfigurationProperties(MongoProperties.class)public class MongoConfiguration &#123; @Autowired private MongoProperties properties; @Autowired(required = false) private MongoClientOptions options; private Mongo mongo; @PreDestroy public void close() &#123; if (this.mongo != null) &#123; this.mongo.close(); &#125; &#125; @Bean public Mongo mongo() throws UnknownHostException &#123; this.mongo = this.properties.createMongoClient(this.options); return this.mongo; &#125;&#125; 这里就引用我们刚才自建的MongoProperties，这样spring在链接mngodb的时候就不会认证出错了。不过我还遇到了了另外一个问题，MongoDataAutoConfiguration引用的MongoProperties也得换成我们自己的，而且升级成3.0的驱动以后，MongoDataAutoConfiguration里面的代码还得修改一下才能正常运行。下面是我修改以后的: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149@Configuration@ConditionalOnClass(&#123;Mongo.class, MongoTemplate.class&#125;)@EnableConfigurationProperties(MongoProperties.class)@AutoConfigureAfter(MongoConfiguration.class)public class MongoDataConfiguration &#123; @Autowired private MongoProperties properties; @Autowired private Environment environment; @Autowired private ResourceLoader resourceLoader; @SuppressWarnings(&quot;deprecation&quot;) @Bean @ConditionalOnMissingBean public MongoDbFactory mongoDbFactory(Mongo mongo) throws Exception &#123; String database = this.properties.getMongoClientDatabase();// String authDatabase = this.properties.getAuthenticationDatabase();// if (StringUtils.hasLength(authDatabase)) &#123;// String username = this.properties.getUsername();// String password = new String(this.properties.getPassword());// UserCredentials credentials = new UserCredentials(username, password);// return new SimpleMongoDbFactory(mongo, database, credentials, authDatabase);// &#125; return new SimpleMongoDbFactory(mongo, database); &#125; @Bean @ConditionalOnMissingBean public MongoTemplate mongoTemplate(MongoDbFactory mongoDbFactory, MongoConverter converter) throws UnknownHostException &#123; return new MongoTemplate(mongoDbFactory, converter); &#125; @Bean @ConditionalOnMissingBean(MongoConverter.class) public MappingMongoConverter mappingMongoConverter(MongoDbFactory factory, MongoMappingContext context, BeanFactory beanFactory) &#123; DbRefResolver dbRefResolver = new DefaultDbRefResolver(factory); MappingMongoConverter mappingConverter = new MappingMongoConverter(dbRefResolver, context); try &#123; mappingConverter .setCustomConversions(beanFactory.getBean(CustomConversions.class)); &#125; catch (NoSuchBeanDefinitionException ex) &#123; // Ignore &#125; return mappingConverter; &#125; @Bean @ConditionalOnMissingBean public MongoMappingContext mongoMappingContext(BeanFactory beanFactory) throws ClassNotFoundException &#123; MongoMappingContext context = new MongoMappingContext(); context.setInitialEntitySet(getInitialEntitySet(beanFactory)); return context; &#125; private Set&lt;Class&lt;?&gt;&gt; getInitialEntitySet(BeanFactory beanFactory) throws ClassNotFoundException &#123; Set&lt;Class&lt;?&gt;&gt; entitySet = new HashSet&lt;Class&lt;?&gt;&gt;(); ClassPathScanningCandidateComponentProvider scanner = new ClassPathScanningCandidateComponentProvider( false); scanner.setEnvironment(this.environment); scanner.setResourceLoader(this.resourceLoader); scanner.addIncludeFilter(new AnnotationTypeFilter(Document.class)); scanner.addIncludeFilter(new AnnotationTypeFilter(Persistent.class)); for (String basePackage : getMappingBasePackages(beanFactory)) &#123; if (StringUtils.hasText(basePackage)) &#123; for (BeanDefinition candidate : scanner .findCandidateComponents(basePackage)) &#123; entitySet.add(ClassUtils.forName(candidate.getBeanClassName(), MongoDataConfiguration.class.getClassLoader())); &#125; &#125; &#125; return entitySet; &#125; private static Collection&lt;String&gt; getMappingBasePackages(BeanFactory beanFactory) &#123; try &#123; return AutoConfigurationPackages.get(beanFactory); &#125; catch (IllegalStateException ex) &#123; // no auto-configuration package registered yet return Collections.emptyList(); &#125; &#125; @Bean @ConditionalOnMissingBean public GridFsTemplate gridFsTemplate(MongoDbFactory mongoDbFactory, MongoTemplate mongoTemplate) &#123; return new GridFsTemplate( new GridFsMongoDbFactory(mongoDbFactory, this.properties), mongoTemplate.getConverter()); &#125; /** * &#123;@link MongoDbFactory&#125; decorator to respect * &#123;@link MongoProperties#getGridFsDatabase()&#125; if set. */ private static class GridFsMongoDbFactory implements MongoDbFactory &#123; private final MongoDbFactory mongoDbFactory; private final MongoProperties properties; public GridFsMongoDbFactory(MongoDbFactory mongoDbFactory, MongoProperties properties) &#123; Assert.notNull(mongoDbFactory, &quot;MongoDbFactory must not be null&quot;); Assert.notNull(properties, &quot;Properties must not be null&quot;); this.mongoDbFactory = mongoDbFactory; this.properties = properties; &#125; @Override public DB getDb() throws DataAccessException &#123; String gridFsDatabase = this.properties.getGridFsDatabase(); if (StringUtils.hasText(gridFsDatabase)) &#123; return this.mongoDbFactory.getDb(gridFsDatabase); &#125; return this.mongoDbFactory.getDb(); &#125; @Override public DB getDb(String dbName) throws DataAccessException &#123; return this.mongoDbFactory.getDb(dbName); &#125; @Override public PersistenceExceptionTranslator getExceptionTranslator() &#123; return this.mongoDbFactory.getExceptionTranslator(); &#125; &#125; @Bean public MongoTemplate syslogMongoTemplate(Mongo mongo) &#123; return new MongoTemplate(mongo, &quot;syslog&quot;); &#125;&#125; 我注释掉了一些代码，然后授权就正常了，估计3.0以后认证方式改了，这些API已经完全被弃用了，使用的话会直接抛异常。 12UserCredentials credentials = new UserCredentials(username, password);return new SimpleMongoDbFactory(mongo, database, credentials, authDatabase); 点进去看看源码 1234567891011121314/** * Create an instance of SimpleMongoDbFactory given the Mongo instance, database name, and username/password * * @param mongo Mongo instance, must not be &#123;@literal null&#125;. * @param databaseName Database name, must not be &#123;@literal null&#125; or empty. * @param credentials username and password. * @param authenticationDatabaseName the database name to use for authentication * @deprecated since 1.7. The credentials used should be provided by &#123;@link MongoClient#getCredentialsList()&#125;. */@Deprecatedpublic SimpleMongoDbFactory(Mongo mongo, String databaseName, UserCredentials credentials, String authenticationDatabaseName) &#123; this(mongo, databaseName, credentials, false, authenticationDatabaseName);&#125; 下面就是针对不同DB不同MongoTemplate的配置了，以后使用的话只需要在相应的类里注入就可以了。1234@Beanpublic MongoTemplate syslogMongoTemplate(Mongo mongo) &#123; return new MongoTemplate(mongo, &quot;syslog&quot;);&#125; 12@Autowiredprivate MongoTemplate syslogMongoTemplate; Mongodb配置信息可以看到在MongoProperties中有一个注解是@ConfigurationProperties(prefix = &quot;spring.data.mongodb&quot;)。spring-boot会默认读取这些配置，由于我们使用了配置中心。所以它也能从配置中心的配置文件中读取到，不需要配置在本地。(我把示例demo中的properties换成了yml的配置方式) 1234567891011121314mysqldb: datasource: url: jdbc\:mysql\://localhost\:3306/test?useUnicode\=true&amp;characterEncoding\=utf-8 username: csst password: csstspring: data: mongodb: host: 10.168.248.36 port: 27017 username: test password: test authenticationDatabase: admin 就这样加在之前配置文件中就好。如果在调试的过程中发现配置没有读取到，可以用下面的方式来查看配置中心是否配置正确并且已经开启服务。http://10.168.248.36:8888/user-dev.ymlhttp://10.168.248.36:8888/user-dev.properties在配置中心的后面加上配置文件的名字可以直接在浏览器中查看。在调试配置中心的时候也可以采取这样的操作，这样你能看到你的git地址和授权错误信息等。 spring-data-mongo提供了一个MongoRepository实现增删改查和复杂查询，在spring-boot中如何指定它使用哪个db呢？如果不配置他默认是使用的test。我测试了一下，加入下面的配置类就可以了。可以扫描一个包。 123456789101112131415161718@Configuration@EnableMongoRepositories(basePackageClasses = ApiLogRepository.class)@AutoConfigureAfter(MongoDataAutoConfiguration.class)public class SysLogDB extends AbstractMongoConfiguration &#123; @Autowired private Mongo mongo; @Override protected String getDatabaseName() &#123; return &quot;syslog&quot;; &#125; @Override public Mongo mongo() throws Exception &#123; return mongo; &#125;&#125; 到这里服务应用项目的mybatis和mongodb都配置好了，可以进行业务代码开发了。没有一个xml配置文件的感觉是不是很爽？下一篇文章讲解如何通过jenkins进行持续集成开发。]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring cloud项目实践(一)]]></title>
    <url>%2F2016%2F03%2F21%2FSpring-cloud%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[基本概念和重要组件最近看了一篇文章，了解到微服务架构的组成部分和概念，以前有看过一点dubbo，文章里介绍到Netflix这么一个公司： Netflix是一家成功实践微服务架构的互联网公司，几年前，Netflix就把它的几乎整个微服务框架栈开源贡献给了社区，这些框架和组件包括 Eureka: 服务注册发现框架 Zuul: 服务网关 Karyon: 服务端框架 Ribbon: 客户端框架 Hystrix: 服务容错组件 Archaius: 服务配置组件 Servo: Metrics组件 Blitz4j: 日志组件 Netflix的开源框架组件已经在Netflix的大规模分布式微服务环境中经过多年的生产实战验证，正逐步被社区接受为构造微服务框架的标准组件。Pivotal去年推出的Spring Cloud开源产品，主要是基于对Netflix开源组件的进一步封装，方便Spring开发人员构建微服务基础框架。对于一些打算构建微服务框架体系的公司来说，充分利用或参考借鉴Netflix的开源微服务组件(或Spring Cloud)，在此基础上进行必要的企业定制，无疑是通向微服务架构的捷径。 Spring Cloud是微服务工具包，为开发者提供了在分布式系统的配置管理、服务发现、断路器、智能路由、微代理、控制总线等开发工具包。 觉得挺不错的，就找找资料尝试实战一下。在此记录和回顾一下过程中遇到的问题和实际项目中需要解决的一些问题。接下来我看了2个文章第一个是http://www.kennybastani.com/2015/07/spring-cloud-docker-microservices.html中文版的：http://www.chinacloud.cn/show.aspx?id=20968&amp;cid=12第二个是http://www.cnblogs.com/skyblog/category/774535.html 在继续往下看之前，可以先把上面2个文章看了。第一个是老外写的，用一个实例的demo演示了spring-cloud构建微服务架构的项目。 第二个文章则很好的介绍了spring-cloud各个子项目的作用。也用了一个demo演示了spring-cloud构建的微服务架构的项目。建议也看看动手试试，我这里就不再赘述了。后面的文章都是在基于看过这2篇文章后的基础上写的，很多东西没有再进行二次解释。这里贴一下spring-cloud的子项目。 目前来说spring主要集中于spring boot（用于开发微服务）和spring cloud相关框架的开发，spring cloud子项目包括： Spring Cloud Config：配置管理开发工具包，可以让你把配置放到远程服务器，目前支持本地存储、Git以及Subversion。 Spring Cloud Bus：事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与Spring Cloud Config联合实现热部署。 Spring Cloud Netflix：针对多种Netflix组件提供的开发工具包，其中包括Eureka、Hystrix、Zuul、Archaius等。 Netflix Eureka：云端负载均衡，一个基于 REST 的服务，用于定位服务，以实现云端的负载均衡和中间层服务器的故障转移。 Netflix Hystrix：容错管理工具，旨在通过控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。 Netflix Zuul：边缘服务工具，是提供动态路由，监控，弹性，安全等的边缘服务。 Netflix Archaius：配置管理API，包含一系列配置管理API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能。 Spring Cloud for Cloud Foundry：通过Oauth2协议绑定服务到CloudFoundry，CloudFoundry是VMware推出的开源PaaS云平台。 Spring Cloud Sleuth：日志收集工具包，封装了Dapper,Zipkin和HTrace操作。 Spring Cloud Data Flow：大数据操作工具，通过命令行方式操作数据流。 Spring Cloud Security：安全工具包，为你的应用程序添加安全控制，主要是指OAuth2。 Spring Cloud Consul：封装了Consul操作，consul是一个服务发现与配置工具，与Docker容器可以无缝集成。 Spring Cloud Zookeeper：操作Zookeeper的工具包，用于使用zookeeper方式的服务注册和发现。 Spring Cloud Stream：数据流操作开发包，封装了与Redis,Rabbit、Kafka等发送接收消息。 Spring Cloud CLI：基于 Spring Boot CLI，可以让你以命令行方式快速建立云组件。 实践在了解了微服务的概念，以及spring-cloud各个子项目之间的关系后。接下来我们就自己动手构建一个项目，做一个能跑起来的项目实际上需要3个模块： Spring Cloud Config Spring Cloud Eureka 自己的项目 在配置好这几个项目后，我会用jenkins自动build项目，然后发布到docker中再启动容器。其中还可以针对生产和测试环境采用不同的配置。我的服务器环境是centos6.5。 我的服务应用目前做了以下2个配置。1.mongodb2.mybatis 下篇文章详细讲解。]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jenkins配合docker持续集成]]></title>
    <url>%2F2015%2F12%2F15%2Fjenkins%E9%85%8D%E5%90%88docker%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%2F</url>
    <content type="text"><![CDATA[我这里用docker来做持续集成的思路和jenkins和tomcat的持续集成是一样的。都是用jenkins拉取git的代码然后打war包，只不过重启tomcat步骤换成了docker的重启。直接展示一下docker的脚本吧。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!/bin/bash#defined export JAVA_HOME=/usr/java/jdk1.8.0_40/REGISTRY_URL=localhost:5000WEB_DIR=&quot;$WEB_DIR/webapps&quot;PORT=&quot;8080&quot;IMAGE=&quot;$1&quot;PROJECT=&quot;$2&quot;#param validateif [ $# -lt 2 ]; then echo &quot;you must use like this : ./deploy_docker.sh &lt;image&gt; &lt;project&gt; [war dir] [port]&quot; exitfiif [ &quot;$3&quot; != &quot;&quot; ]; then WEB_DIR=&quot;$3&quot;fiif [ &quot;$4&quot; != &quot;&quot; ]; then PORT=&quot;$4&quot;fi#publish projectecho &quot;delete old $PROJECT.war&quot;rm -rf &quot;$WEB_DIR&quot;/webapps/$PROJECTecho &quot;copy new $PROJECT.war&quot;cp $WEB_DIR/$PROJECT.war &quot;$WEB_DIR&quot;/webapps/$PROJECT.war#bak projectBAK_DIR=$WEB_DIR/bak/$PROJECT/`date +%Y%m%d`mkdir -p &quot;$BAK_DIR&quot;cp &quot;$WEB_DIR&quot;/$PROJECT.war &quot;$BAK_DIR&quot;/&quot;$PROJECT&quot;_`date +%H%M%S`.war#remove tmprm -rf $WEB_DIR/$PROJECT.warecho &quot;build image:&quot; $IMAGEdocker build -t $REGISTRY_URL/$IMAGE $WEB_DIRecho &quot;push image:&quot; $IMAGEdocker push $REGISTRY_URL/$IMAGEecho &apos;&gt;&gt;&gt; Get old container id&apos;CID=`docker ps | grep &quot;dev&quot; | awk &apos;&#123;print $1&#125;&apos;`if [ -n &quot;$CID&quot; ]; then echo &quot;delete container:&quot; $CID docker stop $CID docker rm -f $CIDfiecho &quot;delete local image:&quot; $IMAGEdocker rmi -f $REGISTRY_URL/$IMAGEdocker run -d -p $PORT:8080 -v /mnt:/mnt --name dev $REGISTRY_URL/$IMAGEecho &quot;finished&quot; 上面是步骤是这样： jenkins将war包上传到$WEB_DIR目录下，然后执行脚本。 这个目录下有一个webapps目录，用来存放正在运行的项目war包，是从$WEB_DIR拷贝过去的。 然后build docker的镜像，并push到私库中。docker build -t $REGISTRY_URL/$IMAGE $WEB_DIR这里最后一个参数是Dockerfile的路径，我在这个目录下还写了一个docker的配置。 停止之前正在运行的Container。 删除本地的镜像。 启动镜像：-v /mnt:/mnt是要映射宿主机的的目录(保存错误日志到宿主机)。--name dev是容器的名字，这个自行修改。docker ps | grep &quot;dev&quot; | awk &#39;{print $1}&#39;这里的dev也需要更换。因为删除了本地的镜像，所以会去私库重新里面下载。 这个脚本有一点问题，local的image有时候删除不掉，不影响运行，但是随着编译的次数，存储空间会越用越多（因为我最终没有采用docker，所以没去深究了）。 还有Dockerfile如下： 12FROM tomcat:8.0.30-jre8ADD webapps /usr/local/tomcat/webapps 基于官方的tomcat8构建，并且把webapps下的文件拷贝到容器中的tomcat webapps下，这个webapps必须是Dockerfile同级目录下的，也就是$WEB_DIR这个目录下。 还有另外一种方式操作起来更加简单，就是映射宿主机的路径直接写成-v $WEB_DIR/webapps:/usr/local/tomcat/webapps，这样还省去了build时拷贝项目的过程。 但是我觉得都不是很方便，查看日志不太方便，而且docker编译和启动也比较耗时，相比直接kill掉tomcat重启要慢一些。目前没有找到一个更好的实践方式，需要慢慢探索一下，为了不影响开发，我又换回了之前直接kill tomcat的方式。]]></content>
      <categories>
        <category>CI</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jenkins和tomcat的持续集成]]></title>
    <url>%2F2015%2F12%2F14%2Fjenkins%E5%92%8Ctomcat%E7%9A%84%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%2F</url>
    <content type="text"><![CDATA[今天来说一下如何用jenkins做持续集成。jenkins我这里就不介绍了，重点介绍一下如何用jenkins对tomcat进行持续集成。 思路流程是这样的： jenkins从git(or svn)拉取代码，进行构建。 将打出来的war包用jenkins的插件(Publish over SSH)传到你要部署的服务器。 执行一个shell脚本，将正在运行的tomcat进程kill掉，把war包拷到tomcat目录的webapps下。然后在运行${TOMCAT_DIR}/bin/startup.sh。 是不是很简单？这样我们在发布应用的时候就再也不需要每次先在本地打包，再手动去删除之前的项目，然后通过ftp工具上传到服务器上，最后再重启tomcat。如果一天要进行几十次类似的操作，其实还是非常耗时的。 实践配置jenkins拉取git代码首先配置在jenkins中配置好，然后再去gitlab里面配上hook触发点。我这里是配置的当gitlab中merge的时候触发构建操作。 用Maven打包应用这个很简单： 上传包到服务器并执行脚本这里需要在jenkins里安装Publish over SSH插件，并在全局配置中配置一下。 然后下面是项目中的配置 上图中的war其实是基于全局配置中的路径，举个例子： 全局配置中的Remote Directory是 /web，项目配置中的Remote directory是war，那么实际上war传送的路径是/web/war 最后就是最重要的脚本 脚本脚本的目的就是kill掉当前tomcat的进程，复制war包，启动tomcat。脚本如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!/bin/bash#defined export JAVA_HOME=/usr/java/jdk1.8.0_40/TOMCAT_HOME="/mnt/web/apache-tomcat-7.0.54"TOMCAT_PORT=8080PROJECT="$1"#param validateif [ $# -lt 1 ]; then echo "you must use like this : ./deploy.sh &lt;projectname&gt; [tomcat port] [tomcat home dir]" exitfiif [ "$2" != "" ]; then TOMCAT_PORT=$2fiif [ "$3" != "" ]; then TOMCAT_HOME="$3"fi#shutdown tomcat#"$TOMCAT_HOME"/bin/shutdown.sh#echo "tomcat shutdown"#check tomcat processtomcat_pid=`/usr/sbin/lsof -n -P -t -i :$TOMCAT_PORT`echo "current :" $tomcat_pidwhile [ -n "$tomcat_pid" ]do sleep 5 tomcat_pid=`/usr/sbin/lsof -n -P -t -i :$TOMCAT_PORT` echo "scan tomcat pid :" $tomcat_pid if [ -n "$tomcat_pid" ]; then echo "kill tomcat :" $tomcat_pid kill -9 $tomcat_pid fidone#publish projectecho "scan no tomcat pid,$PROJECT publishing"rm -rf "$TOMCAT_HOME"/webapps/$PROJECTcp /yourwarpath/$PROJECT.war "$TOMCAT_HOME"/webapps/$PROJECT.war#bak projectBAK_DIR=/yourwarpath/bak/$PROJECT/`date +%Y%m%d`mkdir -p "$BAK_DIR"cp "$TOMCAT_HOME"/webapps/$PROJECT.war "$BAK_DIR"/"$PROJECT"_`date +%H%M%S`.war#remove tmprm -rf /yourwarpath/$PROJECT.war#start tomcat"$TOMCAT_HOME"/bin/startup.shecho "tomcat is starting,please try to access $PROJECT conslone url" PS还有一种方式是通过jenkins的deploy plugin来部署应用，我最早的时候用过一段时间这种方式。不知道是什么原因，部署多次之后会导致内存溢出，每部署一次服务器被占用的内存就多一点。最终导致服务器崩溃，ssh都连接不上去，所以最后换了shell脚本的方案。]]></content>
      <categories>
        <category>CI</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis 枚举存储]]></title>
    <url>%2F2015%2F12%2F11%2FMybatis-%E6%9E%9A%E4%B8%BE%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[枚举我们在写程序的时候会遇到这种需求。就是我的对象里面有一个属性是一个枚举值，但是mybatis默认是不支持的，官方提供了一个typeHandler可以用枚举的ordinal()来进行存和取的自动转换。把它配置在mybatis-configuration.xml里。 123&lt;typeHandlers&gt; &lt;typeHandler handler=&quot;org.apache.ibatis.type.EnumOrdinalTypeHandler&quot; javaType=&quot;com.xxx.user.UserType&quot;/&gt;&lt;/typeHandlers&gt; 问题但是这里有一些问题，必须如果数据库里面存在了别的数字，举个例，有以下枚举 123public enum UserType&#123; ADMIN, EDITOR&#125; 这个枚举在数据库中对应的数字应该是0和1，问题如下 枚举写的顺序不能变，否则数据库数据会错乱 枚举序数中间不能中断(0，2) 数据库里有除了0和1之外的数字，在查询数据的时候程序会得到一个异常(ArrayIndexOutOfBoundsException) 最怕的就是程序出异常了，这里ArrayIndexOutOfBoundsException的原因是因为EnumOrdinalTypeHandler的代码大致是下面这个的意思。 UserType.values()[i] 所以就出现了我们写代码其实并不经常会遇到的ArrayIndexOutOfBoundsException 解决方案为了避免出现这些情况，有个简单的办法就是重写一个EnumOrdinalTypeHandler，我这里贴一下我的解决方案。首先要为所有枚举写一个接口，为了获取枚举对应的intValue,代码如下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public interface CommonEnum&lt;E&gt; &#123; int getValue(); /** * 获取枚举值对应的枚举 * * @param enumClass 枚举类 * @param enumValue 枚举值 * @return 枚举 */ static &lt;E extends CommonEnum&lt;E&gt;&gt; E getEnum(final Class&lt;E&gt; enumClass, final Integer enumValue) &#123; if (enumValue == null) &#123; return null; &#125; try &#123; return valueOf(enumClass, enumValue); &#125; catch (final IllegalArgumentException ex) &#123; return null; &#125; &#125; /** * 获取枚举值对应的枚举 * * @param enumClass 枚举类 * @param enumValue 枚举值 * @return 枚举 */ static &lt;E extends CommonEnum&gt; E valueOf(Class&lt;E&gt; enumClass, Integer enumValue) &#123; if (enumValue == null) throw new NullPointerException("EnumValue is null"); return getEnumMap(enumClass).get(enumValue); &#125; /** * 获取枚举键值对 * * @param enumClass 枚举类型 * @return 键值对 */ static &lt;E extends CommonEnum&gt; Map&lt;Integer, E&gt; getEnumMap(Class&lt;E&gt; enumClass) &#123; E[] enums = enumClass.getEnumConstants(); if (enums == null) throw new IllegalArgumentException(enumClass.getSimpleName() + " does not represent an enum type."); Map&lt;Integer, E&gt; map = new HashMap&lt;&gt;(2 * enums.length); for (E t : enums)&#123; map.put(t.getValue(), t); &#125; return map; &#125;&#125; 上面3个静态方法也可以提取到工具类中，我这里偷了一下懒，也因为我是用的JDK8。枚举实例如下： 123456789101112131415public enum UserType implements CommonEnum&lt;UserType&gt; &#123; ADMIN(0), EDITOR(2); private int value; UserType(int value) &#123; this.value = value; &#125; @Override public int getValue() &#123; return this.value; &#125;&#125; 这里就是一个很常见的枚举，重点在下面的typeHandler。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class CustomEnumTypeHandler&lt;E extends CommonEnum&lt;E&gt;&gt; extends BaseTypeHandler&lt;E&gt; &#123; private Class&lt;E&gt; type; public CustomEnumTypeHandler(Class&lt;E&gt; type) &#123; if (type == null) throw new IllegalArgumentException("Type argument cannot be null"); this.type = type; E[] enums = type.getEnumConstants(); if (enums == null) throw new IllegalArgumentException(type.getSimpleName() + " does not represent an enum type."); &#125; @Override public void setNonNullParameter(PreparedStatement ps, int i, E parameter, JdbcType jdbcType) throws SQLException &#123; ps.setInt(i, parameter.getValue()); &#125; @Override public E getNullableResult(ResultSet rs, String columnName) throws SQLException &#123; int i = rs.getInt(columnName); if (rs.wasNull()) &#123; return null; &#125; else &#123; try &#123; return CommonEnum.getEnum(type, i); &#125; catch (Exception ex) &#123; throw new IllegalArgumentException("Cannot convert " + i + " to " + type.getSimpleName() + " by int value.", ex); &#125; &#125; &#125; @Override public E getNullableResult(ResultSet rs, int columnIndex) throws SQLException &#123; int i = rs.getInt(columnIndex); if (rs.wasNull()) &#123; return null; &#125; else &#123; try &#123; return CommonEnum.getEnum(type, i); &#125; catch (Exception ex) &#123; throw new IllegalArgumentException("Cannot convert " + i + " to " + type.getSimpleName() + " by int value.", ex); &#125; &#125; &#125; @Override public E getNullableResult(CallableStatement cs, int columnIndex) throws SQLException &#123; int i = cs.getInt(columnIndex); if (cs.wasNull()) &#123; return null; &#125; else &#123; try &#123; return CommonEnum.getEnum(type, i); &#125; catch (Exception ex) &#123; throw new IllegalArgumentException("Cannot convert " + i + " to " + type.getSimpleName() + " by int value.", ex); &#125; &#125; &#125;&#125; 这个类基本上也是拷的EnumOrdinalTypeHandler。重要的改动的代码如下： ps.setInt(i, parameter.getValue()); return CommonEnum.getEnum(type, i); 第一句是插入和更新的时候用到的，第二句是查询的时候用到的，最后把mybatis-configuration.xml里的改一下。 123&lt;typeHandlers&gt; &lt;typeHandler handler="xxx.CustomEnumTypeHandler" javaType="com.xxx.user.UserType"/&gt;&lt;/typeHandlers&gt;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos 6.5 安装docker]]></title>
    <url>%2F2015%2F12%2F08%2Fcentos-6-5-%E5%AE%89%E8%A3%85docker%2F</url>
    <content type="text"><![CDATA[先试试把开环境用docker来部署。 http://docs.docker.com/engine/installation/centos/直接按照这里安装就可以了，不过我在这里遇到了一点问题。我是centos6.5，内核在 3.8 以上通过以下命令查看您的 CentOS 内核： uname -r 如果执行以上命令后，输出的内核版本号低于 3.8，请参考下面的方法来来升级您的 Linux 内核。 对于 CentOS 6.5 而言，内核版本默认是 2.6。首先，可通过以下命令安装最新内核： rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org rpm -ivh http://www.elrepo.org/elrepo-release-6-5.el6.elrepo.noarch.rpm yum -y --enablerepo=elrepo-kernel install kernel-lt 随后，编辑以下配置文件： vi /etc/grub.conf 将default=1修改为default=0。最后，通过reboot命令重启操作系统。 重启后如果不出意外的话，再次查看内核，您的 CentOS 内核将会显示为 3.10。 如果到这里，您和我们所期望的结果是一致的。恭喜您！下面我们就一起来安装 Docker 了。 接下来按照官网文档的步骤安装 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364sudo yum updatesudo tee /etc/yum.repos.d/docker.repo &lt;&lt;-&apos;EOF&apos;[dockerrepo]name=Docker Repositorybaseurl=https://yum.dockerproject.org/repo/main/centos/$releasever/enabled=1gpgcheck=1gpgkey=https://yum.dockerproject.org/gpgEOFsudo yum install docker-engine``` 我在这里遇到了下面的一个问题： Error: docker-engine conflicts with docker-io-1.7.1-2.el6.x86_64 查了一会发现是因为docker-io改名为docker-engine，所以造成冲突了，我这台服务器还安装过以前版本的，执行以下命令来删除老的版本。 yum remove docker-io然后再来安装 sudo yum install docker-engine就可以安装成功了，继续下一步。我试着部署一个tomcat，执行以下命令下载一个centos镜像 docker pull centos然后我发现每次命令都要用sudo，很不方便原来默认安装完 docker 后，每次执行 docker 都需要运行 sudo 命令，非常浪费时间影响效率。如果不跟 sudo，直接执行 `docker images` 命令会有如下问题： FATA[0000] Get http:///var/run/docker.sock/v1.18/images/json: dial unix /var/run/docker.sock: permission denied. Are you trying to connect to a TLS-enabled daemon without TLS? 参考这里 http://bsaunder.github.io/2014/12/21/running-docker-without-sudo/ 执行以下命令来解决 sudo groupadd docker 将用户加入该 group 内。 sudo gpasswd -a $&#123;USER&#125; docker重启docker sudo service docker restart **切换当前会话到新group** (如果想立即生效此步不可少，因为 `groups` 命令获取到的是缓存的组信息，刚添加的组信息未能生效，所以 docker images 执行时同样有错。) newgrp - docker 还有就是docker的官方镜像下载实在是太慢了，找到一个国内提供加速服务的[daocloud](https://dashboard.daocloud.io/)注册登录后使用加速器功能就可以了docker默认的images存放路径是/var/lib/docker 我的服务器系统硬盘自带的容量很小 所以我要修改他的存放路径，修改下面文件里的other_args参数，重启docker。 sudo vim /etc/sysconfig/docker other_args=&quot;--graph=yourpath&quot; 下面还有一个私库的问题，不用localhost访问出现了： unable to ping registry endpoint https://10.168.248.36:5000/v0/v2 ping attempt failed with error: Get https://10.168.248.36:5000/v2/: tls: oversized record received with length 20527 v1 ping attempt failed with error: Get https://10.168.248.36:5000/v1/_ping: tls: oversized record received with length 20527 `` 依然是修改/etc/sysconfig/docker`里面的other_args，加上部署私库的机器的IP。 --insecure-registry=yourip:5000 这样就可以正常的push和pull了]]></content>
      <categories>
        <category>centos</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gitlab替换nginx服务]]></title>
    <url>%2F2015%2F10%2F29%2Fgitlab%E6%9B%BF%E6%8D%A2nginx%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[之前在自己服务器上搭建服务器，这是之前的文章gitlab安装需要注意的问题 后来在按照官网上替换自带服务器上的nginx的时候出现了一点问题。也是找了很久才找到这么一篇帖子，我在这里把nginx的部分转载过来一下。原文地址 其次，我替换自己的nginx服务器的时候，nginx官方提供的包并不带gitlab要求的passenger模块，所以不能直接用官方提供的方法。我是用gitlab-ctl reconfigure生成了nginx的配置以后复制到自己的nginx里去的。生成的配置在 /var/opt/gitlab/nginx/conf/gitlab-http.conf 还是nginx，我的nginx的启动账户不是gitlab的（默认是gitlab-www），所以会出现502错误。日志里内容是访问fastcgi权限不足。所以还要chmod 755 /var/opt/gitlab/gitlab-rails/sockets]]></content>
      <categories>
        <category>centos</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]Twitter的分布式自增ID算法Snowflake实现分析及其Java、Php和Python版]]></title>
    <url>%2F2015%2F04%2F22%2F-%E8%BD%AC-Twitter%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E8%87%AA%E5%A2%9EID%E7%AE%97%E6%B3%95Snowflake%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90%E5%8F%8A%E5%85%B6Java%E3%80%81Php%E5%92%8CPython%E7%89%88%2F</url>
    <content type="text"><![CDATA[转载：http://www.dengchuanhua.com/132.html 在分布式系统中，需要生成全局UID的场合还是比较多的，twitter的snowflake解决了这种需求，实现也还是很简单的，除去配置信息，核心代码就是毫秒级时间41位+机器ID 10位+毫秒内序列12位。 该项目地址为：https://github.com/twitter/snowflake是用Scala实现的。 python版详见开源项目https://github.com/erans/pysnowflake。 核心代码为其IdWorker这个类实现，其原理结构如下，我分别用一个0表示一位，用—分割开部分的作用： 10---0000000000 0000000000 0000000000 0000000000 0 --- 00000 ---00000 ---0000000000 00 在上面的字符串中，第一位为未使用（实际上也可作为long的符号位），接下来的41位为毫秒级时间，然后5位datacenter标识位，5位机器ID（并不算标识符，实际是为线程标识），然后12位该毫秒内的当前毫秒内的计数，加起来刚好64位，为一个Long型。 这样的好处是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和机器ID作区分），并且效率较高，经测试，snowflake每秒能够产生26万ID左右，完全满足需要。且看其核心代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&lt;/pre&gt;/** Copyright 2010-2012 Twitter, Inc.*/package com.twitter.service.snowflakeimport com.twitter.ostrich.stats.Statsimport com.twitter.service.snowflake.gen._import java.util.Randomimport com.twitter.logging.Logger/** * An object that generates IDs. * This is broken into a separate class in case * we ever want to support multiple worker threads * per process */class IdWorker(val workerId: Long, val datacenterId: Long, private val reporter: Reporter, var sequence: Long = 0L)extends Snowflake.Iface &#123; private[this] def genCounter(agent: String) = &#123; Stats.incr("ids_generated") Stats.incr("ids_generated_%s".format(agent)) &#125; private[this] val exceptionCounter = Stats.getCounter("exceptions") private[this] val log = Logger.get private[this] val rand = new Random val twepoch = 1288834974657L //机器标识位数 private[this] val workerIdBits = 5L//数据中心标识位数 private[this] val datacenterIdBits = 5L//机器ID最大值 private[this] val maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits)//数据中心ID最大值 private[this] val maxDatacenterId = -1L ^ (-1L &lt;&lt; datacenterIdBits)//毫秒内自增位 private[this] val sequenceBits = 12L//机器ID偏左移12位 private[this] val workerIdShift = sequenceBits//数据中心ID左移17位 private[this] val datacenterIdShift = sequenceBits + workerIdBits//时间毫秒左移22位 private[this] val timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits private[this] val sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits) private[this] var lastTimestamp = -1L // sanity check for workerId if (workerId &gt; maxWorkerId || workerId &lt; 0) &#123; exceptionCounter.incr(1) throw new IllegalArgumentException("worker Id can't be greater than %d or less than 0".format(maxWorkerId)) &#125; if (datacenterId &gt; maxDatacenterId || datacenterId &lt; 0) &#123; exceptionCounter.incr(1) throw new IllegalArgumentException("datacenter Id can't be greater than %d or less than 0".format(maxDatacenterId)) &#125; log.info("worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d", timestampLeftShift, datacenterIdBits, workerIdBits, sequenceBits, workerId) def get_id(useragent: String): Long = &#123; if (!validUseragent(useragent)) &#123; exceptionCounter.incr(1) throw new InvalidUserAgentError &#125; val id = nextId() genCounter(useragent) reporter.report(new AuditLogEntry(id, useragent, rand.nextLong)) id &#125; def get_worker_id(): Long = workerId def get_datacenter_id(): Long = datacenterId def get_timestamp() = System.currentTimeMillis protected[snowflake] def nextId(): Long = synchronized &#123; var timestamp = timeGen() //时间错误 if (timestamp &lt; lastTimestamp) &#123; exceptionCounter.incr(1) log.error("clock is moving backwards. Rejecting requests until %d.", lastTimestamp); throw new InvalidSystemClock("Clock moved backwards. Refusing to generate id for %d milliseconds".format( lastTimestamp - timestamp)) &#125; if (lastTimestamp == timestamp) &#123;//当前毫秒内，则+1 sequence = (sequence + 1) &amp; sequenceMask if (sequence == 0) &#123;//当前毫秒内计数满了，则等待下一秒 timestamp = tilNextMillis(lastTimestamp) &#125; &#125; else &#123; sequence = 0 &#125; lastTimestamp = timestamp//ID偏移组合生成最终的ID，并返回ID ((timestamp - twepoch) &lt;&lt; timestampLeftShift) | (datacenterId &lt;&lt; datacenterIdShift) | (workerId &lt;&lt; workerIdShift) | sequence &#125;//等待下一个毫秒的到来 protected def tilNextMillis(lastTimestamp: Long): Long = &#123; var timestamp = timeGen() while (timestamp &lt;= lastTimestamp) &#123; timestamp = timeGen() &#125; timestamp &#125; protected def timeGen(): Long = System.currentTimeMillis() val AgentParser = """([a-zA-Z][a-zA-Z\-0-9]*)""".r def validUseragent(useragent: String): Boolean = useragent match &#123; case AgentParser(_) =&gt; true case _ =&gt; false &#125;&#125;&lt;pre&gt; 上述为twitter的实现，下面且看一个Java实现，貌似为淘宝的朋友写的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class IdWorker &#123; private final long workerId; private final static long twepoch = 1361753741828L; private long sequence = 0L; private final static long workerIdBits = 4L; public final static long maxWorkerId = -1L ^ -1L &lt;&lt; workerIdBits; private final static long sequenceBits = 10L; private final static long workerIdShift = sequenceBits; private final static long timestampLeftShift = sequenceBits + workerIdBits; public final static long sequenceMask = -1L ^ -1L &lt;&lt; sequenceBits; private long lastTimestamp = -1L; public IdWorker(final long workerId) &#123; super(); if (workerId &gt; this.maxWorkerId || workerId &lt; 0) &#123; throw new IllegalArgumentException(String.format( "worker Id can't be greater than %d or less than 0", this.maxWorkerId)); &#125; this.workerId = workerId; &#125; public synchronized long nextId() &#123; long timestamp = this.timeGen(); if (this.lastTimestamp == timestamp) &#123; this.sequence = (this.sequence + 1) &amp; this.sequenceMask; if (this.sequence == 0) &#123; System.out.println("###########" + sequenceMask); timestamp = this.tilNextMillis(this.lastTimestamp); &#125; &#125; else &#123; this.sequence = 0; &#125; if (timestamp &lt; this.lastTimestamp) &#123; try &#123; throw new Exception( String.format( "Clock moved backwards. Refusing to generate id for %d milliseconds", this.lastTimestamp - timestamp)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; this.lastTimestamp = timestamp; long nextId = ((timestamp - twepoch &lt;&lt; timestampLeftShift)) | (this.workerId &lt;&lt; this.workerIdShift) | (this.sequence);// System.out.println("timestamp:" + timestamp + ",timestampLeftShift:"// + timestampLeftShift + ",nextId:" + nextId + ",workerId:"// + workerId + ",sequence:" + sequence); return nextId; &#125; private long tilNextMillis(final long lastTimestamp) &#123; long timestamp = this.timeGen(); while (timestamp &lt;= lastTimestamp) &#123; timestamp = this.timeGen(); &#125; return timestamp; &#125; private long timeGen() &#123; return System.currentTimeMillis(); &#125; public static void main(String[] args)&#123; IdWorker worker2 = new IdWorker(2); System.out.println(worker2.nextId()); &#125;&#125; 再来看一个php的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;?phpclass Idwork&#123;const debug = 1;static $workerId;static $twepoch = 1361775855078;static $sequence = 0;const workerIdBits = 4;static $maxWorkerId = 15;const sequenceBits = 10;static $workerIdShift = 10;static $timestampLeftShift = 14;static $sequenceMask = 1023;private static $lastTimestamp = -1;function __construct($workId)&#123;if($workId &gt; self::$maxWorkerId || $workId&lt; 0 )&#123;throw new Exception("worker Id can't be greater than 15 or less than 0");&#125;self::$workerId=$workId;echo 'logdebug-&gt;__construct()-&gt;self::$workerId:'.self::$workerId;echo '&lt;/br&gt;';&#125;function timeGen()&#123;//获得当前时间戳$time = explode(' ', microtime());$time2= substr($time[0], 2, 3);$timestramp = $time[1].$time2;echo 'logdebug-&gt;timeGen()-&gt;$timestramp:'.$time[1].$time2;echo '&lt;/br&gt;';return $time[1].$time2;&#125;function tilNextMillis($lastTimestamp) &#123;$timestamp = $this-&gt;timeGen();while ($timestamp &lt;= $lastTimestamp) &#123;$timestamp = $this-&gt;timeGen();&#125;echo 'logdebug-&gt;tilNextMillis()-&gt;$timestamp:'.$timestamp;echo '&lt;/br&gt;';return $timestamp;&#125;function nextId()&#123;$timestamp=$this-&gt;timeGen();echo 'logdebug-&gt;nextId()-&gt;self::$lastTimestamp1:'.self::$lastTimestamp;echo '&lt;/br&gt;';if(self::$lastTimestamp == $timestamp) &#123;self::$sequence = (self::$sequence + 1) &amp; self::$sequenceMask;if (self::$sequence == 0) &#123; echo "###########".self::$sequenceMask; $timestamp = $this-&gt;tilNextMillis(self::$lastTimestamp); echo 'logdebug-&gt;nextId()-&gt;self::$lastTimestamp2:'.self::$lastTimestamp; echo '&lt;/br&gt;'; &#125;&#125; else &#123;self::$sequence = 0; echo 'logdebug-&gt;nextId()-&gt;self::$sequence:'.self::$sequence; echo '&lt;/br&gt;';&#125;if ($timestamp &lt; self::$lastTimestamp) &#123; throw new Excwption("Clock moved backwards. Refusing to generate id for ".(self::$lastTimestamp-$timestamp)." milliseconds"); &#125;self::$lastTimestamp = $timestamp;echo 'logdebug-&gt;nextId()-&gt;self::$lastTimestamp3:'.self::$lastTimestamp;echo '&lt;/br&gt;';echo 'logdebug-&gt;nextId()-&gt;(($timestamp - self::$twepoch &lt;&lt; self::$timestampLeftShift )):'.((sprintf('%.0f', $timestamp) - sprintf('%.0f', self::$twepoch) ));echo '&lt;/br&gt;';$nextId = ((sprintf('%.0f', $timestamp) - sprintf('%.0f', self::$twepoch) )) | ( self::$workerId &lt;&lt; self::$workerIdShift ) | self::$sequence;echo 'timestamp:'.$timestamp.'-----';echo 'twepoch:'.sprintf('%.0f', self::$twepoch).'-----';echo 'timestampLeftShift ='.self::$timestampLeftShift.'-----';echo 'nextId:'.$nextId.'----';echo 'workId:'.self::$workerId.'-----';echo 'workerIdShift:'.self::$workerIdShift.'-----';return $nextId;&#125;&#125;$Idwork = new Idwork(1);$a= $Idwork-&gt;nextId();$Idwork = new Idwork(2);$a= $Idwork-&gt;nextId();?&gt;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>分布式自增ID算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring MVC 接口版本管理]]></title>
    <url>%2F2015%2F03%2F31%2FSpring-MVC-%E6%8E%A5%E5%8F%A3%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[随着我们的应用后台不断的发版，因为改动导致了数据结构的变化，这个时候就需要对HTTP API进行版本控制了。对原有的客户端进行兼容，搜索一番后找到一个方法。先看这个文章，提供了一个解决方案。http://www.cnblogs.com/jcli/p/springmvc_restful_version.html Spring MVC通过在方法上使用RequestMapping来确认应该使用哪个方法来响应相应的请求，而RequestMapping又通过各种RequestCondition的实现来完成各种过滤（比如：consumes，headers，methods，params，produces以及value等）。在Spring MVC框架中使用RequestConditionHolder和RequestMappingInfo这两个实现。 自定义RequestCondition 实现RequestCondition接口 12345678910package org.springframework.web.servlet.mvc.condition;import javax.servlet.http.HttpServletRequest;import org.springframework.web.bind.annotation.RequestMapping;public interface RequestCondition&lt;T&gt; &#123; T combine(T other); T getMatchingCondition(HttpServletRequest request); int compareTo(T other, HttpServletRequest request);&#125; 继承RequestMappingHandlerMapping getCustomTypeCondition方法根据对应的Handler类返回类级别的condition getCustomMethodCondition方法根据对应的Handler方法返回方法级别的condition 基本上我是照着他做的，不过我这里也是遇到不少的问题，因为数据是直接post的json，需要转换为实体对象，所以还需要一些额外的配置。文中提到： 最后，得让SpringMVC加载我们定义的CustomRequestMappingHandlerMapping以覆盖原先的RequestMappingHandlerMapping, 所以要去掉前面说的这个配置，我们通过JavaConfig的方式注入 我是不太愿意去掉&lt;mvc:annotation-driven/&gt;的，不过试了半天也没有好的效果，因为&lt;mvc:annotation-driven/&gt;注册的东西太多了。我尝试直接写一个org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping 一样包名的类来覆盖掉spring的类，来改掉getCustomTypeCondition和getCustomMethodCondition的方法实现。现在来看应该是可行的，但我没有这样干是因为中途遇见一个问题一直没调试好，最终又换成了自定义的类。这个问题就是因为客户端目前的版本号全部是在post的json中传过来的，就不考虑在路径上做改动。所以我出现了这样的操作，在没找到问题之前我一直以为我重写的类这一种方式有问题，看代码 123456789101112public ApiVersionCondition getMatchingCondition(HttpServletRequest request) &#123; String device = null; try &#123; device = JSONUtil.parse(request.getInputStream()).getString("device"); &#125; catch (IOException e) &#123; log.error(e.getMessage(), e); &#125; int version = VersionUtil.getVersion(JSON.parseObject(device).getString("app_ver")); if (version &gt;= this.apiVersion) // 如果请求的版本号大于配置版本号， 则满足 return this; return null;&#125; 这个就是把post过来的json数据取出来，然后取出里面的version进行判断，不过我得到这样一个错误，看了很久也没看懂1234567891011121314org.springframework.http.converter.HttpMessageNotReadableException: Required request body content is missing: org.springframework.web.method.HandlerMethod$HandlerMethodParameter@bee0537e at org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor.handleEmptyBody(RequestResponseBodyMethodProcessor.java:189) ~[spring-webmvc-4.1.3.RELEASE.jar:4.1.3.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor.readWithMessageConverters(RequestResponseBodyMethodProcessor.java:170) ~[spring-webmvc-4.1.3.RELEASE.jar:4.1.3.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor.resolveArgument(RequestResponseBodyMethodProcessor.java:105) ~[spring-webmvc-4.1.3.RELEASE.jar:4.1.3.RELEASE] at org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:77) ~[spring-web-4.1.3.RELEASE.jar:4.1.3.RELEASE] at org.springframework.web.method.support.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:162) ~[spring-web-4.1.3.RELEASE.jar:4.1.3.RELEASE] at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:129) ~[spring-web-4.1.3.RELEASE.jar:4.1.3.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:110) ~[spring-webmvc-4.1.3.RELEASE.jar:4.1.3.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandleMethod(RequestMappingHandlerAdapter.java:777) ~[spring-webmvc-4.1.3.RELEASE.jar:4.1.3.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:706) ~[spring-webmvc-4.1.3.RELEASE.jar:4.1.3.RELEASE] at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85) ~[spring-webmvc-4.1.3.RELEASE.jar:4.1.3.RELEASE] at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:943) ~[spring-webmvc-4.1.3.RELEASE.jar:4.1.3.RELEASE] at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:877) ~[spring-webmvc-4.1.3.RELEASE.jar:4.1.3.RELEASE] at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:966) [spring-webmvc-4.1.3.RELEASE.jar:4.1.3.RELEASE] 然后才发现我在这里把inputStream读了以后，到controller那一层已经没有任何数据了。基本上是算得上自己作死加犯傻了。结果还是采取的在Http Header里面放一个版本号来进行判断。12345678public ApiVersionCondition getMatchingCondition(HttpServletRequest request) &#123; int version = VersionUtil.getVersion(request.getHeader(&quot;App-Version&quot;)); if (version &gt;= this.apiVersion) // 如果请求的版本号大于配置版本号， 则满足 return this; return null;&#125; 说一下配置的地方，我没有用WebConfig的配置方式，但还是去掉了&lt;mvc:annotation-driven&gt;换成了几个bean。下面贴上我的配置123456789101112131415161718192021222324252627282930&lt;!--RequestMapping解析器--&gt;&lt;bean class=&quot;com.xiaomaihd.xueshaqu.version.CustomRequestMappingHandlerMapping&quot;&gt; &lt;property name=&quot;order&quot; value=&quot;0&quot;/&gt; &lt;property name=&quot;interceptors&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;conversionServiceExposingInterceptor&quot;/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt; &lt;property name=&quot;webBindingInitializer&quot;&gt; &lt;bean class=&quot;org.springframework.web.bind.support.ConfigurableWebBindingInitializer&quot;&gt; &lt;property name=&quot;conversionService&quot; ref=&quot;conversionService&quot;/&gt; &lt;property name=&quot;validator&quot; ref=&quot;validator&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;property name=&quot;messageConverters&quot; ref=&quot;messageConverters&quot;&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;/&gt;&lt;bean id=&quot;conversionServiceExposingInterceptor&quot; class=&quot;org.springframework.web.servlet.handler.ConversionServiceExposingInterceptor&quot;&gt; &lt;constructor-arg ref=&quot;conversionService&quot;/&gt;&lt;/bean&gt; 大功告成，目前还没发现其他的问题]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Rest</tag>
        <tag>Spring Mvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[发现tomcat的一个bug]]></title>
    <url>%2F2015%2F03%2F10%2F%E5%8F%91%E7%8E%B0tomcat%E7%9A%84%E4%B8%80%E4%B8%AAbug%2F</url>
    <content type="text"><![CDATA[在做项目的时候出现一个错误，看了半天没看出来是什么问题1234567891011121314151617181920212223242526272829root causejava.util.NoSuchElementException java.util.ArrayList$Itr.next(ArrayList.java:834) org.apache.jasper.compiler.Validator$ValidateVisitor.getJspAttribute(Validator.java:1385) org.apache.jasper.compiler.Validator$ValidateVisitor.visit(Validator.java:772) org.apache.jasper.compiler.Node$UninterpretedTag.accept(Node.java:1251) org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2377) org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2429) org.apache.jasper.compiler.Validator$ValidateVisitor.visit(Validator.java:779) org.apache.jasper.compiler.Node$UninterpretedTag.accept(Node.java:1251) org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2377) org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2429) org.apache.jasper.compiler.Validator$ValidateVisitor.visit(Validator.java:529) org.apache.jasper.compiler.Node$JspRoot.accept(Node.java:564) org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2377) org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2429) org.apache.jasper.compiler.Node$Visitor.visit(Node.java:2435) org.apache.jasper.compiler.Node$Root.accept(Node.java:474) org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2377) org.apache.jasper.compiler.Validator.validateExDirectives(Validator.java:1841) org.apache.jasper.compiler.Compiler.generateJava(Compiler.java:217) org.apache.jasper.compiler.Compiler.compile(Compiler.java:373) org.apache.jasper.compiler.Compiler.compile(Compiler.java:353) org.apache.jasper.compiler.Compiler.compile(Compiler.java:340) org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:657) org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:357) org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:390) org.apache.jasper.servlet.JspServlet.service(JspServlet.java:334) javax.servlet.http.HttpServlet.service(HttpServlet.java:727) 找了半天才发现是tomcat的一个bug，换了一个tomcat版本就好了导致这个错误的原因如下1&lt;jsp:param name=&quot;test&quot; value=&quot;&quot; /&gt; 如果是value是空值，在某些tomcat版本下就会出现这个情况，如果你遇见了，不妨换个版本试试。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Mvc 3.1 之后如何配置messageConverters]]></title>
    <url>%2F2015%2F03%2F06%2FSpring-Mvc-3-1-%E4%B9%8B%E5%90%8E%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEmessageConverters%2F</url>
    <content type="text"><![CDATA[&lt;mvc:annotation-driven /&gt; 是一种简写形式，完全可以手动配置替代这种简写形式，简写形式可以让初学都快速应用默认配置方案。&lt;mvc:annotation-driven /&gt; 会自动注册DefaultAnnotationHandlerMapping与AnnotationMethodHandlerAdapter 两个bean,是spring MVC为@Controllers分发请求所必须的。 这句话我在很多帖子都看到过，我自己的项目本身使用的Spring MVC 3.2，实际上在3.1之后，注册的类发生了变化 Spring Framework 3.1 introduces a new set of support classes for processing requests with annotated controllers: RequestMappingHandlerMappingRequestMappingHandlerAdapterExceptionHandlerExceptionResolverThese classes are a replacement for the existing: DefaultAnnotationHandlerMappingAnnotationMethodHandlerAdapterAnnotationMethodHandlerExceptionResolver1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;mvc:annotation-driven /&gt;&lt;/beans&gt;&gt; The above registers a RequestMappingHandlerMapping, a RequestMappingHandlerAdapter, and an ExceptionHandlerExceptionResolver (among others) in support of processing requests with annotated controller methods using annotations such as @RequestMapping , @ExceptionHandler, and others. It also enables the following: Spring 3 style type conversion through a ConversionService instance in addition to the JavaBeans PropertyEditors used for Data Binding. Support for formatting Number fields using the @NumberFormat annotation through the ConversionService. Support for formatting Date, Calendar, Long, and Joda Time fields using the @DateTimeFormat annotation. Support for validating @Controller inputs with @Valid, if a JSR-303 Provider is present on the classpath. HttpMessageConverter support for @RequestBody method parameters and @ResponseBody method return values from @RequestMapping or @ExceptionHandler methods.This is the complete list of HttpMessageConverters set up by mvc:annotation-driven: ByteArrayHttpMessageConverter converts byte arrays. StringHttpMessageConverter converts strings. ResourceHttpMessageConverter converts to/from org.springframework.core.io.Resource for all media types. SourceHttpMessageConverter converts to/from a javax.xml.transform.Source. FormHttpMessageConverter converts form data to/from a MultiValueMap. Jaxb2RootElementHttpMessageConverter converts Java objects to/from XML — added if JAXB2 is present on the classpath. MappingJackson2HttpMessageConverter (or MappingJacksonHttpMessageConverter) converts to/from JSON — added if Jackson 2 (or Jackson) is present on the classpath. AtomFeedHttpMessageConverter converts Atom feeds — added if Rome is present on the classpath. RssChannelHttpMessageConverter converts RSS feeds — added if Rome is present on the classpath. 这是摘取的官方文档，可以看出，注册的类已经变成了RequestMappingHandlerMapping和 RequestMappingHandlerAdapter。我之前在不知道的时候，使用AnnotationMethodHandlerAdapter 进行配置，结果在有存在的情况下，我自己配置的AnnotationMethodHandlerAdapter 怎么都不起作用，于是去掉了标签，手动注册了AnnotationMethodHandlerAdapter ，和DefaultAnnotationHandlerMapping。结果引发了其他问题，比如文件无法上传的问题。 阅读文档发现Spring提供了基于自定义messageConverters的方法，如下所示：123456&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;&gt; &lt;mvc:message-converters&gt; &lt;bean class=&quot;org.example.MyHttpMessageConverter&quot;/&gt; &lt;bean class=&quot;org.example.MyOtherHttpMessageConverter&quot;/&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; 下面展示我自己的配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-3.2.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd&quot;&gt; &lt;!-- spring自动扫描注解的组件 --&gt; &lt;context:component-scan base-package=&quot;cn.xx.xx&quot; use-default-filters=&quot;false&quot;&gt; &lt;context:include-filter expression=&quot;org.springframework.stereotype.Controller&quot; type=&quot;annotation&quot; /&gt; &lt;/context:component-scan&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;ref bean=&quot;stringHttpMessageConverter&quot; /&gt; &lt;ref bean=&quot;fastJsonHttpMessageConverter&quot; /&gt; &lt;ref bean=&quot;marshallingHttpMessageConverter&quot; /&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; &lt;bean id=&quot;stringHttpMessageConverter&quot; class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;constructor-arg value=&quot;UTF-8&quot; index=&quot;0&quot;&gt;&lt;/constructor-arg&gt;&lt;!-- 避免出现乱码 --&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;value&gt;text/plain;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;fastJsonHttpMessageConverter&quot; class=&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt;&lt;!-- 避免IE出现下载JSON文件的情况 --&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;features&quot;&gt; &lt;util:list&gt; &lt;!-- &lt;value&gt;WriteMapNullValue&lt;/value&gt; --&gt; &lt;value&gt;QuoteFieldNames&lt;/value&gt; &lt;value&gt;WriteDateUseDateFormat&lt;/value&gt; &lt;/util:list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;marshallingHttpMessageConverter&quot; class=&quot;org.springframework.http.converter.xml.MarshallingHttpMessageConverter&quot;&gt; &lt;property name=&quot;marshaller&quot; ref=&quot;castorMarshaller&quot; /&gt; &lt;property name=&quot;unmarshaller&quot; ref=&quot;castorMarshaller&quot; /&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;value&gt;text/xml;charset=UTF-8&lt;/value&gt; &lt;value&gt;application/xml;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 返回类型定义 --&gt; &lt;util:list id=&quot;messageConverters&quot;&gt; &lt;ref bean=&quot;stringHttpMessageConverter&quot; /&gt; &lt;ref bean=&quot;fastJsonHttpMessageConverter&quot; /&gt; &lt;ref bean=&quot;marshallingHttpMessageConverter&quot; /&gt; &lt;/util:list&gt; &lt;bean id=&quot;castorMarshaller&quot; class=&quot;org.springframework.oxm.castor.CastorMarshaller&quot; /&gt; &lt;!-- AOP自动注解功能 --&gt; &lt;aop:aspectj-autoproxy /&gt; &lt;!-- 不进行拦截的 --&gt; &lt;mvc:resources location=&quot;/&quot; mapping=&quot;/**/*.html&quot; order=&quot;0&quot; /&gt; &lt;mvc:resources location=&quot;/images/&quot; mapping=&quot;/images/**&quot; /&gt; &lt;mvc:resources location=&quot;/img/&quot; mapping=&quot;/img/**&quot; /&gt; &lt;mvc:resources location=&quot;/download/&quot; mapping=&quot;/download/**&quot; /&gt; &lt;mvc:resources location=&quot;/js/&quot; mapping=&quot;/js/**&quot; /&gt; &lt;mvc:resources location=&quot;/css/&quot; mapping=&quot;/css/**&quot; /&gt; &lt;mvc:resources location=&quot;/plugin/&quot; mapping=&quot;/plugin/**&quot; /&gt; &lt;mvc:resources location=&quot;/WEB-INF/pages/&quot; mapping=&quot;/pages/**&quot; /&gt; &lt;bean id=&quot;messageSource&quot; class=&quot;org.springframework.context.support.ResourceBundleMessageSource&quot;&gt; &lt;property name=&quot;basename&quot; value=&quot;messages&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; &lt;!-- 支持上传文件 --&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot; /&gt; &lt;!-- restTemplate --&gt; &lt;bean id=&quot;restTemplate&quot; class=&quot;org.springframework.web.client.RestTemplate&quot;&gt; &lt;property name=&quot;messageConverters&quot; ref=&quot;messageConverters&quot;&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring mvc</tag>
        <tag>messageConverters</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS Jenkins + Sonar + Nexus 环境搭建]]></title>
    <url>%2F2015%2F03%2F06%2FCentOS-Jenkins-Sonar-Nexus-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Nexus篇在Centos上安装 如果机器上是JDK1.6的话，nexus-2.5.1是最后一个支持JDK1.6的版本。 下载地址：http://www.sonatype.org/nexus/archived 我这里使用FTP工具上传到服务器上。执行命令的时候如果遇到没有权限的地方用chmod改变文件权限。 设置为系统自启动服务（使用root用户）12cd /etc/init.d/cp /usr/local/jdk/nexus-2.5.1-01/bin/jsw/linux-x86-64/nexus nexus 编辑/etc/init.d/nexus文件，添加以下变量定义：123NEXUS_HOME=/usr/local/jdk/nexus-2.5.1-01PLATFORM=linux-x86-64PLATFORM_DIR="$&#123;NEXUS_HOME&#125;/bin/jsw/$&#123;PLATFORM&#125;" 修改如下变量，设置启动用户为ycftp(这里用你自己的用户)1RUN_AS_USER=ycftp 执行命令添加nexus自启动服务12chkconfig –add nexuschkconfig –levels 345 nexus on 执行如下命令启动、停止nexus服务12service nexus startservice nexus stop 启动后可通过http://yourip:8081/nexus访问 用admin/admin123登陆登陆后点击左侧Repositories，将下图所示设置为true，就可以搜索了这个时候还搜索不到 需要再右击选项点击 Repair Index如下所示修复完成后便可以搜索了。 Jenkins篇添加Jenkins的源（repository）:12sudo wget -O/etc/yum.repos.d/jenkins.repo http://jenkins-ci.org/redhat/jenkins.reposudo rpm--import http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key 不然你在启动jenkins服务的时候他会说你没有什么key啥的。 安装Jenkins：1sudo yum installjenkins 安装完成后，有如下相关目录： /usr/lib/jenkins/：jenkins安装目录，WAR包会放在这里。 注意修改端口号 /etc/sysconfig/jenkins：jenkins配置文件，“端口”，“JENKINS_HOME”等都可以在这里配置。内容如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798## Path: Development/Jenkins## Description: Configuration for theJenkins continuous build server## Type: string## Default: "/var/lib/jenkins"## ServiceRestart: jenkins## Directory where Jenkins store itsconfiguration and working# files (checkouts, build reports, artifacts,...).#JENKINS_HOME="/var/lib/jenkins" ## Type: string## Default: ""## ServiceRestart: jenkins## Java executable to run Jenkins# When left empty, we'll try to find thesuitable Java.#JENKINS_JAVA_CMD="" ## Type: string## Default: "jenkins"## ServiceRestart: jenkins## Unix user account that runs the Jenkinsdaemon# Be careful when you change this, as youneed to update# permissions of $JENKINS_HOME and/var/log/jenkins.#JENKINS_USER="jenkins" ## Type: string## Default: "-Djava.awt.headless=true"## ServiceRestart: jenkins## Options to pass to java when runningJenkins.#JENKINS_JAVA_OPTIONS="-Djava.awt.headless=true" ## Type: integer(0:65535)## Default: 8080## ServiceRestart: jenkins## Port Jenkins is listening on.# Set to -1 to disable#JENKINS_PORT="8085" ## Type: integer(0:65535)## Default: 8009## ServiceRestart: jenkins## Ajp13 Port Jenkins is listening on.# Set to -1 to disable#JENKINS_AJP_PORT="8019" ## Type: integer(1:9)## Default: 5## ServiceRestart: jenkins## Debug level for logs -- the higher thevalue, the more verbose.# 5 is INFO.#JENKINS_DEBUG_LEVEL="5" ## Type: yesno## Default: no## ServiceRestart: jenkins## Whether to enable access logging or not.#JENKINS_ENABLE_ACCESS_LOG="no" ## Type: integer## Default: 100## ServiceRestart: jenkins## Maximum number of HTTP worker threads.#JENKINS_HANDLER_MAX="100" ## Type: integer## Default: 20## ServiceRestart: jenkins## Maximum number of idle HTTP workerthreads.#JENKINS_HANDLER_IDLE="20" ## Type: string## Default: ""## ServiceRestart: jenkins## Pass arbitrary arguments to Jenkins.# Full option list: java -jar jenkins.war--help#JENKINS_ARGS="" 我这里修改端口号为8085，避免和本机tomcat冲突 启动Jenkins1sudo servicejenkins start 启动后用 http://yourip:8085/ 访问 Sonar篇首先下载http://www.sonarqube.org/downloads/ 我用的ftp工具上传到服务器。 编辑~/.bash_profile，添加环境变量 添加SONAR_RUNNER_HOME(就是sonar-runner-2.4的全路径名，比如/usr/local/sonar-runner-2.4)环境变量，并将SONAR_RUNNER_HOME/bin加入PATH变量中 记得使环境变量生效 source ~/.bash_profile 我这里使用mysql数据库，但不说mysql怎么安装了。 先配置Sonar要用的数据库环境： 创建数据库 在mysql中执行如下脚本创建数据库及mysql用户 1234CREATE DATABASE sonar CHARACTER SET utf8 COLLATE utf8_general_ci;CREATE USER 'sonar' IDENTIFIED BY 'sonar';GRANT ALL ON sonar.* TO 'sonar'@'%' IDENTIFIED BY 'sonar';GRANT ALL ON sonar.* TO 'sonar'@'localhost' IDENTIFIED BY 'sonar'; 编辑${SONAR_HOME}/conf/sonar.properties配置数据库: 12345678sonar.jdbc.username=sonarsonar.jdbc.password=sonarsonar.jdbc.url=jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true# Optionalpropertiessonar.jdbc.driverClassName:com.mysql.jdbc.Driver 配置DB驱动包如果使用Oracle数据库，必须手动复制驱动类到${SONAR_HOME}/extensions/jdbc-driver/oracle/目录下。其它支持的数据库默认提供了驱动，http://docs.codehaus.org/display/SONAR/Analysis+Parameters 列举了一些常用的配置及默认值. 修改sonar配置文件编辑sonar所在的目录（比如/usr/local/sonar-4.4）中conf/sonar.properties文件，配置数据库设置，默认已经提供了各类数据库的支持，只要将注释去掉就可以。这里使用mysql，因此取消mysql模块的注释，并将sonar中原有的嵌入式的数据库的jdbc.url注释掉。 1234567891011121314151617#vi sonar.properties#需要注释下面这条语句#sonar.jdbc.url=jdbc:h2:tcp://localhost:9092/sonarsonar.jdbc.username=sonarsonar.jdbc.password=sonarsonar.jdbc.url=jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true# Optional propertiessonar.jdbc.driverClassName=com.mysql.jdbc.Driver 修改sonar-runner的配置文件切换至sonar-runner的安装目录下，修改sonar-runner.properties根据实际使用数据库情况取消相应注释，这里需要和sonar.properties中保持一致。123456789101112131415161718192021#Configure here general information about the environment， such as SonarQube DB details for example#No information about specific project should appear here#----- Default SonarQube serversonar.host.url=http://localhost:9000#----- PostgreSQL#sonar.jdbc.url=jdbc:postgresql://localhost/sonar#----- MySQLsonar.jdbc.url=jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;characterEncoding=utf8sonar.jdbc.driverClassName=com.mysql.jdbc.Driver#----- Oracle#sonar.jdbc.url=jdbc:oracle:thin:@localhost/XE#----- Microsoft SQLServer#sonar.jdbc.url=jdbc:jtds:sqlserver://localhost/sonar;SelectMethod=Cursor#----- Global database settingssonar.jdbc.username=sonarsonar.jdbc.password=sonar#----- Default source code encodingsonar.sourceEncoding=UTF-8#----- Security (when 'sonar.forceAuthentication' is set to 'true')sonar.login=adminsonar.password=admin 运行如下命令启动sonar，其它操作系统sonar均提供了启动脚本1$&#123;SONAR_HOME&#125;/bin/linux-x86-64/sonar.sh start 如果遇到wrapper没有执行权限，用chmod命令赋予权限 如：1chmod 777 wrapper 在浏览器中访问: http://yourip:9000/ ，运行界面如下：配置为自启动服务 使用root账户或者开启sudo权限操作。 创建自启动脚本文件/etc/init.d/sonar 1vi/etc/init.d/sonar 添加如下内容123456789101112131415161718#!/bin/sh## rc file for SonarQube## chkconfig: 345 96 10# description: SonarQube system (www.sonarsource.org)#### BEGIN INIT INFO# Provides: sonar# Required-Start: $network# Required-Stop: $network# Default-Start: 3 4 5# Default-Stop: 0 1 2 6# Short-Description: SonarQube system (www.sonarsource.org)# Description: SonarQube system (www.sonarsource.org)### END INIT INFO/usr/bin/sonar $* 添加启动服务123ln -s $SONAR_HOME/bin/linux-x86-64/sonar.sh /usr/bin/sonarchmod 755 /etc/init.d/sonarchkconfig --add sonar 与Jenkins集成在jenkins的插件管理中选择安装sonar jenkins plugin，该插件可以使项目每次构建都调用sonar进行代码度量。具体配置方式不再叙述。]]></content>
      <categories>
        <category>CI</category>
      </categories>
      <tags>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos 6.5 安装gitlab安装需注意的问题]]></title>
    <url>%2F2015%2F02%2F06%2Fcentos-6-5-%E5%AE%89%E8%A3%85gitlab%E5%AE%89%E8%A3%85%E9%9C%80%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[安装gitlab首先按照官网进行操作，环境为centos 6.5https://about.gitlab.com/downloads/注意安装过程中执行命令1sudo gitlab-ctl reconfigure 出现错误，在/etc/gitlab/gitlab.rb中修改域名后再执行一次方可启动成功进页面提示502，用命令查看日志1sudo gitlab-ctl tail postgresql 提示内存不足，官方也是建议1g内存进行搭建，512m的话也可以安装但是要添加swap，不然启动后就会提示内存不足，我目前是512的，添加swap后访问成功，但是有点慢可能，还是升为1g最好。 上面的图是我目前的配置，注意这里修改了gitlab默认的仓库存储路径，教程官网有https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/README.md我这里贴出来给大家看看 Storing Git data in an alternative directory1234567891011121314# Prevent users from writing to the repositories while you move them.sudo gitlab-ctl stop# Only move 'repositories'; 'gitlab-satellites' will be recreated# automatically. Note there is _no_ slash behind 'repositories', but there _is_ a# slash behind 'git-data'.sudo rsync -av /var/opt/gitlab/git-data/repositories /mnt/nas/git-data/# Fix permissions if necessarysudo gitlab-ctl reconfigure# Double-check directory layout in /mnt/nas/git-data. Expected output:# gitlab-satellites repositoriessudo ls /mnt/nas/git-data/# Done! Start GitLab and verify that you can browse through the repositories in# the web interface.sudo gitlab-ctl start 可以看到这下面是安装完成后gitlab一些文件和数据的路径 注：看到网上很多资料都不对，可能是过时了，所以搞gitlab建议大家还是以官网为主，说不定你在看我这个文章的时候也过时了 Omnibus-gitlab uses four different directories. /opt/gitlab holds application code for GitLab and its dependencies. /var/opt/gitlab holds application data and configuration files that gitlab-ctl reconfigure writes to. /etc/gitlab holds configuration files for omnibus-gitlab. These are the only files that you should ever have to edit manually. /var/log/gitlab contains all log data generated by components of omnibus-gitlab. 有错误的时候尽量用1234567891011121314151617181920sudo gitlab-ctl tail``` 查看日志分析错误原因，我在配置邮件的时候也是试了很久才用上接下来我们来配置邮件，我这里使用SMTP，用腾讯企业邮箱还是修改`/etc/gitlab/gitlab.rb` 配置文件，再次**提醒**网上很多文章可以已经过时了附上官网地址https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/doc/settings/smtp.md```rubygitlab_rails['smtp_enable'] = true gitlab_rails['smtp_address'] = "smtp.exmail.qq.com" gitlab_rails['smtp_port'] = 25 gitlab_rails['smtp_user_name'] = "xx@xxx.com" gitlab_rails['smtp_password'] = "password" gitlab_rails['smtp_domain'] = "exmail.qq.com" gitlab_rails['smtp_authentication'] = "login" gitlab_rails['smtp_enable_starttls_auto'] = true gitlab_rails['gitlab_email_from'] = 'xx@xxx.com' ##修改gitlab配置的发信人 user["git_user_email"] = "xx@xxx.com" 保持发信人和登录邮箱一致,我配置这里的时候也出错了，原因是我在看腾讯官网时候写的是用的SSL，端口是465但是gitlab好像不是用的ssl，gitlab的教程里也没找到是否启用ssl的配置，我也没去深究了，于是把端口号改为25，邮件发送成功。大家在测试邮件的时候可以用忘记密码来发送邮件测试，然后用gitlab-ctl tail来查看，大概等1分钟就能看到发送邮件的日志，出错了再具体分析原因]]></content>
      <categories>
        <category>centos</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis-memcached框架配置]]></title>
    <url>%2F2015%2F02%2F06%2Fmybatis-memcached%E6%A1%86%E6%9E%B6%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[官方放出了mybatis和memcached的整合包，先附上官方文档地址http://mybatis.github.io/memcached-cache/文档很简洁，事实证明使用起来也很简单memcached的安装我这里就不再讲了，网上很容易找到在项目中引入12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt; &lt;artifactId&gt;mybatis-memcached&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt;&lt;/dependency&gt; 然后在想使用的mapper中加入1234&lt;mapper namespace="org.acme.FooMapper"&gt; &lt;cache type="org.mybatis.caches.memcached.MemcachedCache" /&gt; ...&lt;/mapper&gt; 就可以用了 再建一个memcached.properties，对他进行配置我简单测试了一下发现它可以配置多个服务器，用逗号分隔，经测试如果某一台挂掉，他会选择正常的那台如果2台都挂掉，就会报错,估计我们还是希望在memcached服务器挂掉后从数据库读取数据，不知道大家有什么好的实现方式或者思路吗123org.mybatis.caches.memcached.servers=172.29.33.201:11211,localhost:11211org.mybatis.caches.memcached.expiration=30 org.mybatis.caches.memcached.asyncget=false]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>memcached</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos6.5使用yum安装mysql]]></title>
    <url>%2F2015%2F01%2F31%2Fcentos6-5%E4%BD%BF%E7%94%A8yum%E5%AE%89%E8%A3%85mysql%2F</url>
    <content type="text"><![CDATA[要使用yum 安装mysql，要使用mysql的yum仓库，先从官网下载适合你系统的仓库http://dev.mysql.com/downloads/repo/yum/centos 6.5 对应的是mysql-community-release-el6-5.noarch.rpm然后安装一下这个仓库列表1sudo yum localinstall mysql-community-release-el6-5.noarch.rpm 执行这个命令后就能看到可安装的mysql1yum repolist enabled | grep "mysql.*-community.*" 如果我们是要安装最新的版本，那么可以直接执行1sudo yum install mysql-community-server 如果我们要选择版本，可以先执行下面这个命令查看一下有哪些版本1yum repolist all | grep mysql 如果要选择版本的话，有两种方式，一种是使用命令来12shell&gt; sudo yum-config-manager --disable mysql56-communityshell&gt; sudo yum-config-manager --enable mysql57-community-dmr 这个命令就是在仓库中启用5.7版本的，禁用5.6版本子仓库或者编辑/etc/yum.repos.d/mysql-community.repo文件1234567# Enable to use MySQL 5.6[mysql56-community]name=MySQL 5.6 Community Serverbaseurl=//repo.mysql.com/yum/mysql-5.6-community/el/5/$basearch/enabled=1gpgcheck=1gpgkey=file:/etc/pki/rpm-gpg/RPM-GPG-KEY-mysql enabled=0表示禁用比如要安装5.7版本的mysql，要确定5.6的enabled=0，5.7的enabled=1，一次保证只启用一个子仓库12345678# Note: MySQL 5.7 is currently in development. For use at your own risk.# Please read with sub pages: https://dev.mysql.com/doc/relnotes/mysql/5.7/en/[mysql57-community-dmr]name=MySQL 5.7 Community Server Development Milestone Releasebaseurl=http://repo.mysql.com/yum/mysql-5.7-community/el/6/$basearch/enabled=1gpgcheck=1gpgkey=file:/etc/pki/rpm-gpg/RPM-GPG-KEY-mysql 然后我们就可以愉快的安装mysql了1sudo yum install mysql-community-server 安装完成后我们启动mysql1sudo service mysqld start 查看mysql状态1sudo service mysqld status]]></content>
      <categories>
        <category>centos</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring mvc @ResponseBody 返回枚举类型]]></title>
    <url>%2F2015%2F01%2F31%2FSpring-mvc-ResponseBody-%E8%BF%94%E5%9B%9E%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[我们在用@ResponseBody返回实体对象可以用spring mvc自动帮我们转化成json串但是当实体中包含了枚举类型的属性的时候怎么办，我这里使用的是fastjson，他默认是转换成了字符串。根据我上一篇博文的解决方案，我们这里自定义一个FastJsonHttpMessageConverter1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class FastJsonHttpMessageConverter extends AbstractHttpMessageConverter&lt;Object&gt; &#123; public final static Charset UTF8 = Charset.forName("UTF-8"); private Charset charset = UTF8; private SerializerFeature[] features = new SerializerFeature[0]; public FastJsonHttpMessageConverter()&#123; super(new MediaType("application", "json", UTF8), new MediaType("application", "*+json", UTF8)); &#125; @Override protected boolean supports(Class&lt;?&gt; clazz) &#123; return true; &#125; public Charset getCharset() &#123; return this.charset; &#125; public void setCharset(Charset charset) &#123; this.charset = charset; &#125; public SerializerFeature[] getFeatures() &#123; return features; &#125; public void setFeatures(SerializerFeature... features) &#123; this.features = features; &#125; @Override protected Object readInternal(Class&lt;? extends Object&gt; clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException &#123; ByteArrayOutputStream baos = new ByteArrayOutputStream(); InputStream in = inputMessage.getBody(); byte[] buf = new byte[1024]; for (;;) &#123; int len = in.read(buf); if (len == -1) &#123; break; &#125; if (len &gt; 0) &#123; baos.write(buf, 0, len); &#125; &#125; byte[] bytes = baos.toByteArray(); return JSON.parseObject(bytes, 0, bytes.length, charset.newDecoder(), clazz); &#125; @Override protected void writeInternal(Object obj, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException &#123; OutputStream out = outputMessage.getBody(); String text = JSONUtil.toJSONString(obj, features); byte[] bytes = text.getBytes(charset); out.write(bytes); &#125; &#125; 其实我就改了一句代码，如下所示，这样我们就可以返回想要的索引数字了。1String text = JSONUtil.toJSONString(obj, features);]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring mvc</tag>
        <tag>fastjson</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fastjson序列化枚举属性]]></title>
    <url>%2F2015%2F01%2F30%2Ffastjson%E5%BA%8F%E5%88%97%E5%8C%96%E6%9E%9A%E4%B8%BE%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[我的实体类里面有一个属性是枚举类型的，但是我在转换的时候我不希望取它的name，而是它的索引值0,1,2,3,搜索一番后发现这个回答 fastjson enum 枚举 反序列化为了方便大家查看，我把内容贴过来看fastjson源码，SerializeWriter1234567891011121314151617181920212223242526272829public void writeEnum( Enum &lt; ?&gt;value, char c )&#123; if ( value == null ) &#123; writeNull(); write( ',' ); return; &#125; if ( isEnabled( SerializerFeature.WriteEnumUsingToString ) ) &#123; if ( isEnabled( SerializerFeature.UseSingleQuotes ) ) &#123; write( '\'' ); write( value.name() ); write( '\'' ); write( c ); &#125; else &#123; write( '\"' ); write( value.name() ); write( '\"' ); write( c ); &#125; return; &#125; writeIntAndChar( value.ordinal(), c ); &#125; 可以看出SerializeWriter在初始化的时候，features不要设置SerializerFeature.WriteEnumUsingToString因为JSON.DEFAULT_PARSER_FEATURE是enable了SerializerFeature.WriteEnumUsingToString，也就是说是读枚举的value值而不是int值12345678910public static int DEFAULT_GENERATE_FEATURE; static &#123; int features = 0; features |= com.alibaba.fastjson.serializer.SerializerFeature.QuoteFieldNames.getMask(); features |= com.alibaba.fastjson.serializer.SerializerFeature.SkipTransientField.getMask(); features |= com.alibaba.fastjson.serializer.SerializerFeature.WriteEnumUsingToString.getMask(); features |= com.alibaba.fastjson.serializer.SerializerFeature.SortField.getMask(); // features |= com.alibaba.fastjson.serializer.SerializerFeature.WriteSlashAsSpecial.getMask(); DEFAULT_GENERATE_FEATURE = features; &#125; 所以，解决你这个问题的方法就是之前调用1JSONSerializer.config(SerializerFeature.WriteEnumUsingToString,false); 但是JSONSerializer.config不是一个静态方法，不能直接调用而且如果直接调用JSON.toJSON把实体类转为json，这里还有另外一句代码12345678910111213141516171819202122232425if (clazz.isEnum()) &#123; return ((Enum&lt;?&gt;) javaObject).name(); &#125;``` 如果是枚举类型，不管你怎么改配置都不会给你转成索引值的情况，所以我们这里就先想把实体转成`jsonString`，再把`jsonString`转成`JSONObject`。再继续看`fastjson`的源码在`JOSN.toJSONString`中```javapublic static final String toJSONString(Object object, SerializerFeature... features) &#123; SerializeWriter out = new SerializeWriter(); try &#123; JSONSerializer serializer = new JSONSerializer(out); for (com.alibaba.fastjson.serializer.SerializerFeature feature : features) &#123; serializer.config(feature, true); &#125; serializer.write(object); return out.toString(); &#125; finally &#123; out.close(); &#125; &#125; 他这里也是用的serializer.config来配置的，干脆我们自己写个工具方法吧，同时把WriteEnumUsingToString禁用掉1234567891011121314151617181920212223242526272829private static final SerializerFeature[] CONFIG = new SerializerFeature[]&#123; SerializerFeature.WriteNullBooleanAsFalse,//boolean为null时输出false SerializerFeature.WriteMapNullValue, //输出空置的字段 SerializerFeature.WriteNonStringKeyAsString,//如果key不为String 则转换为String 比如Map的key为Integer SerializerFeature.WriteNullListAsEmpty,//list为null时输出[] SerializerFeature.WriteNullNumberAsZero,//number为null时输出0 SerializerFeature.WriteNullStringAsEmpty//String为null时输出"" &#125;; public static JSONObject toJSON(Object javaObject) &#123; SerializeWriter out = new SerializeWriter(); String jsonStr; try &#123; JSONSerializer serializer = new JSONSerializer(out); for (com.alibaba.fastjson.serializer.SerializerFeature feature : CONFIG) &#123; serializer.config(feature, true); &#125; serializer.config(SerializerFeature.WriteEnumUsingToString, false); serializer.write(javaObject); jsonStr = out.toString(); &#125; finally &#123; out.close(); &#125; JSONObject jsonObject = JSON.parseObject(jsonStr); return jsonObject; &#125; 这样调用我们的工具类方法转换出来的结果，就是我们想要的数字了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>fastjson</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
</search>
